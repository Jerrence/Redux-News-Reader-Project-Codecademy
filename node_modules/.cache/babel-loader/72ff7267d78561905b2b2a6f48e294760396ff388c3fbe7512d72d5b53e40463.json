{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.doTypesOverlap = doTypesOverlap;\nexports.isEqualType = isEqualType;\nexports.isTypeSubTypeOf = isTypeSubTypeOf;\nvar _definition = require('../type/definition.js');\n\n/**\n * Provided two types, return true if the types are equal (invariant).\n */\nfunction isEqualType(typeA, typeB) {\n  // Equivalent types are equal.\n  if (typeA === typeB) {\n    return true;\n  } // If either type is non-null, the other must also be non-null.\n\n  if ((0, _definition.isNonNullType)(typeA) && (0, _definition.isNonNullType)(typeB)) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // If either type is a list, the other must also be a list.\n\n  if ((0, _definition.isListType)(typeA) && (0, _definition.isListType)(typeB)) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // Otherwise the types are not equal.\n\n  return false;\n}\n/**\n * Provided a type and a super type, return true if the first type is either\n * equal or a subset of the second super type (covariant).\n */\n\nfunction isTypeSubTypeOf(schema, maybeSubType, superType) {\n  // Equivalent type is a valid subtype\n  if (maybeSubType === superType) {\n    return true;\n  } // If superType is non-null, maybeSubType must also be non-null.\n\n  if ((0, _definition.isNonNullType)(superType)) {\n    if ((0, _definition.isNonNullType)(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n    return false;\n  }\n  if ((0, _definition.isNonNullType)(maybeSubType)) {\n    // If superType is nullable, maybeSubType may be non-null or nullable.\n    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);\n  } // If superType type is a list, maybeSubType type must also be a list.\n\n  if ((0, _definition.isListType)(superType)) {\n    if ((0, _definition.isListType)(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n    return false;\n  }\n  if ((0, _definition.isListType)(maybeSubType)) {\n    // If superType is not a list, maybeSubType must also be not a list.\n    return false;\n  } // If superType type is an abstract type, check if it is super type of maybeSubType.\n  // Otherwise, the child type is not a valid subtype of the parent type.\n\n  return (0, _definition.isAbstractType)(superType) && ((0, _definition.isInterfaceType)(maybeSubType) || (0, _definition.isObjectType)(maybeSubType)) && schema.isSubType(superType, maybeSubType);\n}\n/**\n * Provided two composite types, determine if they \"overlap\". Two composite\n * types overlap when the Sets of possible concrete types for each intersect.\n *\n * This is often used to determine if a fragment of a given type could possibly\n * be visited in a context of another type.\n *\n * This function is commutative.\n */\n\nfunction doTypesOverlap(schema, typeA, typeB) {\n  // Equivalent types overlap\n  if (typeA === typeB) {\n    return true;\n  }\n  if ((0, _definition.isAbstractType)(typeA)) {\n    if ((0, _definition.isAbstractType)(typeB)) {\n      // If both types are abstract, then determine if there is any intersection\n      // between possible concrete types of each.\n      return schema.getPossibleTypes(typeA).some(type => schema.isSubType(typeB, type));\n    } // Determine if the latter type is a possible concrete type of the former.\n\n    return schema.isSubType(typeA, typeB);\n  }\n  if ((0, _definition.isAbstractType)(typeB)) {\n    // Determine if the former type is a possible concrete type of the latter.\n    return schema.isSubType(typeB, typeA);\n  } // Otherwise the types do not overlap.\n\n  return false;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","doTypesOverlap","isEqualType","isTypeSubTypeOf","_definition","require","typeA","typeB","isNonNullType","ofType","isListType","schema","maybeSubType","superType","isAbstractType","isInterfaceType","isObjectType","isSubType","getPossibleTypes","some","type"],"sources":["/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/graphql/utilities/typeComparators.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.doTypesOverlap = doTypesOverlap;\nexports.isEqualType = isEqualType;\nexports.isTypeSubTypeOf = isTypeSubTypeOf;\n\nvar _definition = require('../type/definition.js');\n\n/**\n * Provided two types, return true if the types are equal (invariant).\n */\nfunction isEqualType(typeA, typeB) {\n  // Equivalent types are equal.\n  if (typeA === typeB) {\n    return true;\n  } // If either type is non-null, the other must also be non-null.\n\n  if (\n    (0, _definition.isNonNullType)(typeA) &&\n    (0, _definition.isNonNullType)(typeB)\n  ) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // If either type is a list, the other must also be a list.\n\n  if (\n    (0, _definition.isListType)(typeA) &&\n    (0, _definition.isListType)(typeB)\n  ) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // Otherwise the types are not equal.\n\n  return false;\n}\n/**\n * Provided a type and a super type, return true if the first type is either\n * equal or a subset of the second super type (covariant).\n */\n\nfunction isTypeSubTypeOf(schema, maybeSubType, superType) {\n  // Equivalent type is a valid subtype\n  if (maybeSubType === superType) {\n    return true;\n  } // If superType is non-null, maybeSubType must also be non-null.\n\n  if ((0, _definition.isNonNullType)(superType)) {\n    if ((0, _definition.isNonNullType)(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n\n    return false;\n  }\n\n  if ((0, _definition.isNonNullType)(maybeSubType)) {\n    // If superType is nullable, maybeSubType may be non-null or nullable.\n    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);\n  } // If superType type is a list, maybeSubType type must also be a list.\n\n  if ((0, _definition.isListType)(superType)) {\n    if ((0, _definition.isListType)(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n\n    return false;\n  }\n\n  if ((0, _definition.isListType)(maybeSubType)) {\n    // If superType is not a list, maybeSubType must also be not a list.\n    return false;\n  } // If superType type is an abstract type, check if it is super type of maybeSubType.\n  // Otherwise, the child type is not a valid subtype of the parent type.\n\n  return (\n    (0, _definition.isAbstractType)(superType) &&\n    ((0, _definition.isInterfaceType)(maybeSubType) ||\n      (0, _definition.isObjectType)(maybeSubType)) &&\n    schema.isSubType(superType, maybeSubType)\n  );\n}\n/**\n * Provided two composite types, determine if they \"overlap\". Two composite\n * types overlap when the Sets of possible concrete types for each intersect.\n *\n * This is often used to determine if a fragment of a given type could possibly\n * be visited in a context of another type.\n *\n * This function is commutative.\n */\n\nfunction doTypesOverlap(schema, typeA, typeB) {\n  // Equivalent types overlap\n  if (typeA === typeB) {\n    return true;\n  }\n\n  if ((0, _definition.isAbstractType)(typeA)) {\n    if ((0, _definition.isAbstractType)(typeB)) {\n      // If both types are abstract, then determine if there is any intersection\n      // between possible concrete types of each.\n      return schema\n        .getPossibleTypes(typeA)\n        .some((type) => schema.isSubType(typeB, type));\n    } // Determine if the latter type is a possible concrete type of the former.\n\n    return schema.isSubType(typeA, typeB);\n  }\n\n  if ((0, _definition.isAbstractType)(typeB)) {\n    // Determine if the former type is a possible concrete type of the latter.\n    return schema.isSubType(typeB, typeA);\n  } // Otherwise the types do not overlap.\n\n  return false;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}