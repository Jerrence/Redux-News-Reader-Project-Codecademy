{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.buildClientSchema = buildClientSchema;\nvar _devAssert = require('../jsutils/devAssert.js');\nvar _inspect = require('../jsutils/inspect.js');\nvar _isObjectLike = require('../jsutils/isObjectLike.js');\nvar _keyValMap = require('../jsutils/keyValMap.js');\nvar _parser = require('../language/parser.js');\nvar _definition = require('../type/definition.js');\nvar _directives = require('../type/directives.js');\nvar _introspection = require('../type/introspection.js');\nvar _scalars = require('../type/scalars.js');\nvar _schema = require('../type/schema.js');\nvar _valueFromAST = require('./valueFromAST.js');\n\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\nfunction buildClientSchema(introspection, options) {\n  (0, _isObjectLike.isObjectLike)(introspection) && (0, _isObjectLike.isObjectLike)(introspection.__schema) || (0, _devAssert.devAssert)(false, `Invalid or incomplete introspection result. Ensure that you are passing \"data\" property of introspection response and no \"errors\" was returned alongside: ${(0, _inspect.inspect)(introspection)}.`); // Get the schema from the introspection result.\n\n  const schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.\n\n  const typeMap = (0, _keyValMap.keyValMap)(schemaIntrospection.types, typeIntrospection => typeIntrospection.name, typeIntrospection => buildType(typeIntrospection)); // Include standard types only if they are used.\n\n  for (const stdType of [..._scalars.specifiedScalarTypes, ..._introspection.introspectionTypes]) {\n    if (typeMap[stdType.name]) {\n      typeMap[stdType.name] = stdType;\n    }\n  } // Get the root Query, Mutation, and Subscription types.\n\n  const queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n  const mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  const subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  const directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\n\n  return new _schema.GraphQLSchema({\n    description: schemaIntrospection.description,\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: Object.values(typeMap),\n    directives,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === _introspection.TypeKind.LIST) {\n      const itemRef = typeRef.ofType;\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n      return new _definition.GraphQLList(getType(itemRef));\n    }\n    if (typeRef.kind === _introspection.TypeKind.NON_NULL) {\n      const nullableRef = typeRef.ofType;\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n      const nullableType = getType(nullableRef);\n      return new _definition.GraphQLNonNull((0, _definition.assertNullableType)(nullableType));\n    }\n    return getNamedType(typeRef);\n  }\n  function getNamedType(typeRef) {\n    const typeName = typeRef.name;\n    if (!typeName) {\n      throw new Error(`Unknown type reference: ${(0, _inspect.inspect)(typeRef)}.`);\n    }\n    const type = typeMap[typeName];\n    if (!type) {\n      throw new Error(`Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`);\n    }\n    return type;\n  }\n  function getObjectType(typeRef) {\n    return (0, _definition.assertObjectType)(getNamedType(typeRef));\n  }\n  function getInterfaceType(typeRef) {\n    return (0, _definition.assertInterfaceType)(getNamedType(typeRef));\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n  function buildType(type) {\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (type != null && type.name != null && type.kind != null) {\n      // FIXME: Properly type IntrospectionType, it's a breaking change so fix in v17\n      // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n      switch (type.kind) {\n        case _introspection.TypeKind.SCALAR:\n          return buildScalarDef(type);\n        case _introspection.TypeKind.OBJECT:\n          return buildObjectDef(type);\n        case _introspection.TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n        case _introspection.TypeKind.UNION:\n          return buildUnionDef(type);\n        case _introspection.TypeKind.ENUM:\n          return buildEnumDef(type);\n        case _introspection.TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n    const typeStr = (0, _inspect.inspect)(type);\n    throw new Error(`Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`);\n  }\n  function buildScalarDef(scalarIntrospection) {\n    return new _definition.GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      specifiedByURL: scalarIntrospection.specifiedByURL\n    });\n  }\n  function buildImplementationsList(implementingIntrospection) {\n    // TODO: Temporary workaround until GraphQL ecosystem will fully support\n    // 'interfaces' on interface types.\n    if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === _introspection.TypeKind.INTERFACE) {\n      return [];\n    }\n    if (!implementingIntrospection.interfaces) {\n      const implementingIntrospectionStr = (0, _inspect.inspect)(implementingIntrospection);\n      throw new Error(`Introspection result missing interfaces: ${implementingIntrospectionStr}.`);\n    }\n    return implementingIntrospection.interfaces.map(getInterfaceType);\n  }\n  function buildObjectDef(objectIntrospection) {\n    return new _definition.GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: () => buildImplementationsList(objectIntrospection),\n      fields: () => buildFieldDefMap(objectIntrospection)\n    });\n  }\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new _definition.GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      interfaces: () => buildImplementationsList(interfaceIntrospection),\n      fields: () => buildFieldDefMap(interfaceIntrospection)\n    });\n  }\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      const unionIntrospectionStr = (0, _inspect.inspect)(unionIntrospection);\n      throw new Error(`Introspection result missing possibleTypes: ${unionIntrospectionStr}.`);\n    }\n    return new _definition.GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: () => unionIntrospection.possibleTypes.map(getObjectType)\n    });\n  }\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      const enumIntrospectionStr = (0, _inspect.inspect)(enumIntrospection);\n      throw new Error(`Introspection result missing enumValues: ${enumIntrospectionStr}.`);\n    }\n    return new _definition.GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: (0, _keyValMap.keyValMap)(enumIntrospection.enumValues, valueIntrospection => valueIntrospection.name, valueIntrospection => ({\n        description: valueIntrospection.description,\n        deprecationReason: valueIntrospection.deprecationReason\n      }))\n    });\n  }\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      const inputObjectIntrospectionStr = (0, _inspect.inspect)(inputObjectIntrospection);\n      throw new Error(`Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`);\n    }\n    return new _definition.GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields)\n    });\n  }\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error(`Introspection result missing fields: ${(0, _inspect.inspect)(typeIntrospection)}.`);\n    }\n    return (0, _keyValMap.keyValMap)(typeIntrospection.fields, fieldIntrospection => fieldIntrospection.name, buildField);\n  }\n  function buildField(fieldIntrospection) {\n    const type = getType(fieldIntrospection.type);\n    if (!(0, _definition.isOutputType)(type)) {\n      const typeStr = (0, _inspect.inspect)(type);\n      throw new Error(`Introspection must provide output type for fields, but received: ${typeStr}.`);\n    }\n    if (!fieldIntrospection.args) {\n      const fieldIntrospectionStr = (0, _inspect.inspect)(fieldIntrospection);\n      throw new Error(`Introspection result missing field args: ${fieldIntrospectionStr}.`);\n    }\n    return {\n      description: fieldIntrospection.description,\n      deprecationReason: fieldIntrospection.deprecationReason,\n      type,\n      args: buildInputValueDefMap(fieldIntrospection.args)\n    };\n  }\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return (0, _keyValMap.keyValMap)(inputValueIntrospections, inputValue => inputValue.name, buildInputValue);\n  }\n  function buildInputValue(inputValueIntrospection) {\n    const type = getType(inputValueIntrospection.type);\n    if (!(0, _definition.isInputType)(type)) {\n      const typeStr = (0, _inspect.inspect)(type);\n      throw new Error(`Introspection must provide input type for arguments, but received: ${typeStr}.`);\n    }\n    const defaultValue = inputValueIntrospection.defaultValue != null ? (0, _valueFromAST.valueFromAST)((0, _parser.parseValue)(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type,\n      defaultValue,\n      deprecationReason: inputValueIntrospection.deprecationReason\n    };\n  }\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      const directiveIntrospectionStr = (0, _inspect.inspect)(directiveIntrospection);\n      throw new Error(`Introspection result missing directive args: ${directiveIntrospectionStr}.`);\n    }\n    if (!directiveIntrospection.locations) {\n      const directiveIntrospectionStr = (0, _inspect.inspect)(directiveIntrospection);\n      throw new Error(`Introspection result missing directive locations: ${directiveIntrospectionStr}.`);\n    }\n    return new _directives.GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      isRepeatable: directiveIntrospection.isRepeatable,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","buildClientSchema","_devAssert","require","_inspect","_isObjectLike","_keyValMap","_parser","_definition","_directives","_introspection","_scalars","_schema","_valueFromAST","introspection","options","isObjectLike","__schema","devAssert","inspect","schemaIntrospection","typeMap","keyValMap","types","typeIntrospection","name","buildType","stdType","specifiedScalarTypes","introspectionTypes","queryType","getObjectType","mutationType","subscriptionType","directives","map","buildDirective","GraphQLSchema","description","query","mutation","subscription","values","assumeValid","getType","typeRef","kind","TypeKind","LIST","itemRef","ofType","Error","GraphQLList","NON_NULL","nullableRef","nullableType","GraphQLNonNull","assertNullableType","getNamedType","typeName","type","assertObjectType","getInterfaceType","assertInterfaceType","SCALAR","buildScalarDef","OBJECT","buildObjectDef","INTERFACE","buildInterfaceDef","UNION","buildUnionDef","ENUM","buildEnumDef","INPUT_OBJECT","buildInputObjectDef","typeStr","scalarIntrospection","GraphQLScalarType","specifiedByURL","buildImplementationsList","implementingIntrospection","interfaces","implementingIntrospectionStr","objectIntrospection","GraphQLObjectType","fields","buildFieldDefMap","interfaceIntrospection","GraphQLInterfaceType","unionIntrospection","possibleTypes","unionIntrospectionStr","GraphQLUnionType","enumIntrospection","enumValues","enumIntrospectionStr","GraphQLEnumType","valueIntrospection","deprecationReason","inputObjectIntrospection","inputFields","inputObjectIntrospectionStr","GraphQLInputObjectType","buildInputValueDefMap","fieldIntrospection","buildField","isOutputType","args","fieldIntrospectionStr","inputValueIntrospections","inputValue","buildInputValue","inputValueIntrospection","isInputType","defaultValue","valueFromAST","parseValue","undefined","directiveIntrospection","directiveIntrospectionStr","locations","GraphQLDirective","isRepeatable","slice"],"sources":["/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/graphql/utilities/buildClientSchema.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.buildClientSchema = buildClientSchema;\n\nvar _devAssert = require('../jsutils/devAssert.js');\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _isObjectLike = require('../jsutils/isObjectLike.js');\n\nvar _keyValMap = require('../jsutils/keyValMap.js');\n\nvar _parser = require('../language/parser.js');\n\nvar _definition = require('../type/definition.js');\n\nvar _directives = require('../type/directives.js');\n\nvar _introspection = require('../type/introspection.js');\n\nvar _scalars = require('../type/scalars.js');\n\nvar _schema = require('../type/schema.js');\n\nvar _valueFromAST = require('./valueFromAST.js');\n\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\nfunction buildClientSchema(introspection, options) {\n  ((0, _isObjectLike.isObjectLike)(introspection) &&\n    (0, _isObjectLike.isObjectLike)(introspection.__schema)) ||\n    (0, _devAssert.devAssert)(\n      false,\n      `Invalid or incomplete introspection result. Ensure that you are passing \"data\" property of introspection response and no \"errors\" was returned alongside: ${(0,\n      _inspect.inspect)(introspection)}.`,\n    ); // Get the schema from the introspection result.\n\n  const schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.\n\n  const typeMap = (0, _keyValMap.keyValMap)(\n    schemaIntrospection.types,\n    (typeIntrospection) => typeIntrospection.name,\n    (typeIntrospection) => buildType(typeIntrospection),\n  ); // Include standard types only if they are used.\n\n  for (const stdType of [\n    ..._scalars.specifiedScalarTypes,\n    ..._introspection.introspectionTypes,\n  ]) {\n    if (typeMap[stdType.name]) {\n      typeMap[stdType.name] = stdType;\n    }\n  } // Get the root Query, Mutation, and Subscription types.\n\n  const queryType = schemaIntrospection.queryType\n    ? getObjectType(schemaIntrospection.queryType)\n    : null;\n  const mutationType = schemaIntrospection.mutationType\n    ? getObjectType(schemaIntrospection.mutationType)\n    : null;\n  const subscriptionType = schemaIntrospection.subscriptionType\n    ? getObjectType(schemaIntrospection.subscriptionType)\n    : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  const directives = schemaIntrospection.directives\n    ? schemaIntrospection.directives.map(buildDirective)\n    : []; // Then produce and return a Schema with these types.\n\n  return new _schema.GraphQLSchema({\n    description: schemaIntrospection.description,\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: Object.values(typeMap),\n    directives,\n    assumeValid:\n      options === null || options === void 0 ? void 0 : options.assumeValid,\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === _introspection.TypeKind.LIST) {\n      const itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return new _definition.GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === _introspection.TypeKind.NON_NULL) {\n      const nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      const nullableType = getType(nullableRef);\n      return new _definition.GraphQLNonNull(\n        (0, _definition.assertNullableType)(nullableType),\n      );\n    }\n\n    return getNamedType(typeRef);\n  }\n\n  function getNamedType(typeRef) {\n    const typeName = typeRef.name;\n\n    if (!typeName) {\n      throw new Error(\n        `Unknown type reference: ${(0, _inspect.inspect)(typeRef)}.`,\n      );\n    }\n\n    const type = typeMap[typeName];\n\n    if (!type) {\n      throw new Error(\n        `Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`,\n      );\n    }\n\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    return (0, _definition.assertObjectType)(getNamedType(typeRef));\n  }\n\n  function getInterfaceType(typeRef) {\n    return (0, _definition.assertInterfaceType)(getNamedType(typeRef));\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n  function buildType(type) {\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (type != null && type.name != null && type.kind != null) {\n      // FIXME: Properly type IntrospectionType, it's a breaking change so fix in v17\n      // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n      switch (type.kind) {\n        case _introspection.TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case _introspection.TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case _introspection.TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case _introspection.TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case _introspection.TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case _introspection.TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    const typeStr = (0, _inspect.inspect)(type);\n    throw new Error(\n      `Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`,\n    );\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new _definition.GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      specifiedByURL: scalarIntrospection.specifiedByURL,\n    });\n  }\n\n  function buildImplementationsList(implementingIntrospection) {\n    // TODO: Temporary workaround until GraphQL ecosystem will fully support\n    // 'interfaces' on interface types.\n    if (\n      implementingIntrospection.interfaces === null &&\n      implementingIntrospection.kind === _introspection.TypeKind.INTERFACE\n    ) {\n      return [];\n    }\n\n    if (!implementingIntrospection.interfaces) {\n      const implementingIntrospectionStr = (0, _inspect.inspect)(\n        implementingIntrospection,\n      );\n      throw new Error(\n        `Introspection result missing interfaces: ${implementingIntrospectionStr}.`,\n      );\n    }\n\n    return implementingIntrospection.interfaces.map(getInterfaceType);\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    return new _definition.GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: () => buildImplementationsList(objectIntrospection),\n      fields: () => buildFieldDefMap(objectIntrospection),\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new _definition.GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      interfaces: () => buildImplementationsList(interfaceIntrospection),\n      fields: () => buildFieldDefMap(interfaceIntrospection),\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      const unionIntrospectionStr = (0, _inspect.inspect)(unionIntrospection);\n      throw new Error(\n        `Introspection result missing possibleTypes: ${unionIntrospectionStr}.`,\n      );\n    }\n\n    return new _definition.GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: () => unionIntrospection.possibleTypes.map(getObjectType),\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      const enumIntrospectionStr = (0, _inspect.inspect)(enumIntrospection);\n      throw new Error(\n        `Introspection result missing enumValues: ${enumIntrospectionStr}.`,\n      );\n    }\n\n    return new _definition.GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: (0, _keyValMap.keyValMap)(\n        enumIntrospection.enumValues,\n        (valueIntrospection) => valueIntrospection.name,\n        (valueIntrospection) => ({\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason,\n        }),\n      ),\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      const inputObjectIntrospectionStr = (0, _inspect.inspect)(\n        inputObjectIntrospection,\n      );\n      throw new Error(\n        `Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`,\n      );\n    }\n\n    return new _definition.GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields),\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error(\n        `Introspection result missing fields: ${(0, _inspect.inspect)(\n          typeIntrospection,\n        )}.`,\n      );\n    }\n\n    return (0, _keyValMap.keyValMap)(\n      typeIntrospection.fields,\n      (fieldIntrospection) => fieldIntrospection.name,\n      buildField,\n    );\n  }\n\n  function buildField(fieldIntrospection) {\n    const type = getType(fieldIntrospection.type);\n\n    if (!(0, _definition.isOutputType)(type)) {\n      const typeStr = (0, _inspect.inspect)(type);\n      throw new Error(\n        `Introspection must provide output type for fields, but received: ${typeStr}.`,\n      );\n    }\n\n    if (!fieldIntrospection.args) {\n      const fieldIntrospectionStr = (0, _inspect.inspect)(fieldIntrospection);\n      throw new Error(\n        `Introspection result missing field args: ${fieldIntrospectionStr}.`,\n      );\n    }\n\n    return {\n      description: fieldIntrospection.description,\n      deprecationReason: fieldIntrospection.deprecationReason,\n      type,\n      args: buildInputValueDefMap(fieldIntrospection.args),\n    };\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return (0, _keyValMap.keyValMap)(\n      inputValueIntrospections,\n      (inputValue) => inputValue.name,\n      buildInputValue,\n    );\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    const type = getType(inputValueIntrospection.type);\n\n    if (!(0, _definition.isInputType)(type)) {\n      const typeStr = (0, _inspect.inspect)(type);\n      throw new Error(\n        `Introspection must provide input type for arguments, but received: ${typeStr}.`,\n      );\n    }\n\n    const defaultValue =\n      inputValueIntrospection.defaultValue != null\n        ? (0, _valueFromAST.valueFromAST)(\n            (0, _parser.parseValue)(inputValueIntrospection.defaultValue),\n            type,\n          )\n        : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type,\n      defaultValue,\n      deprecationReason: inputValueIntrospection.deprecationReason,\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      const directiveIntrospectionStr = (0, _inspect.inspect)(\n        directiveIntrospection,\n      );\n      throw new Error(\n        `Introspection result missing directive args: ${directiveIntrospectionStr}.`,\n      );\n    }\n\n    if (!directiveIntrospection.locations) {\n      const directiveIntrospectionStr = (0, _inspect.inspect)(\n        directiveIntrospection,\n      );\n      throw new Error(\n        `Introspection result missing directive locations: ${directiveIntrospectionStr}.`,\n      );\n    }\n\n    return new _directives.GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      isRepeatable: directiveIntrospection.isRepeatable,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args),\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}