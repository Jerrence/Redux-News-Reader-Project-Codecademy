{"ast":null,"code":"var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source) if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)) {\n    if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n  }\n  return target;\n};\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  GraphQLHandler: () => GraphQLHandler,\n  MockedRequest: () => MockedRequest,\n  RESTMethods: () => RESTMethods,\n  RequestHandler: () => RequestHandler,\n  RestHandler: () => RestHandler,\n  SetupApi: () => SetupApi,\n  SetupWorkerApi: () => SetupWorkerApi,\n  cleanUrl: () => cleanUrl,\n  compose: () => compose,\n  context: () => context_exports,\n  createResponseComposition: () => createResponseComposition,\n  defaultContext: () => defaultContext,\n  defaultResponse: () => defaultResponse,\n  graphql: () => graphql,\n  graphqlContext: () => graphqlContext,\n  handleRequest: () => handleRequest,\n  matchRequestUrl: () => matchRequestUrl,\n  response: () => response,\n  rest: () => rest,\n  restContext: () => restContext,\n  setupWorker: () => setupWorker\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/context/index.ts\nvar context_exports = {};\n__export(context_exports, {\n  body: () => body,\n  cookie: () => cookie,\n  data: () => data,\n  delay: () => delay,\n  errors: () => errors,\n  extensions: () => extensions,\n  fetch: () => fetch,\n  json: () => json,\n  set: () => set,\n  status: () => status,\n  text: () => text,\n  xml: () => xml\n});\n\n// node_modules/statuses/codes.json\nvar _00 = \"Continue\";\nvar _01 = \"Switching Protocols\";\nvar _02 = \"Processing\";\nvar _03 = \"Early Hints\";\nvar _002 = \"OK\";\nvar _012 = \"Created\";\nvar _022 = \"Accepted\";\nvar _032 = \"Non-Authoritative Information\";\nvar _04 = \"No Content\";\nvar _05 = \"Reset Content\";\nvar _06 = \"Partial Content\";\nvar _07 = \"Multi-Status\";\nvar _08 = \"Already Reported\";\nvar _26 = \"IM Used\";\nvar _003 = \"Multiple Choices\";\nvar _013 = \"Moved Permanently\";\nvar _023 = \"Found\";\nvar _033 = \"See Other\";\nvar _042 = \"Not Modified\";\nvar _052 = \"Use Proxy\";\nvar _072 = \"Temporary Redirect\";\nvar _082 = \"Permanent Redirect\";\nvar _004 = \"Bad Request\";\nvar _014 = \"Unauthorized\";\nvar _024 = \"Payment Required\";\nvar _034 = \"Forbidden\";\nvar _043 = \"Not Found\";\nvar _053 = \"Method Not Allowed\";\nvar _062 = \"Not Acceptable\";\nvar _073 = \"Proxy Authentication Required\";\nvar _083 = \"Request Timeout\";\nvar _09 = \"Conflict\";\nvar _10 = \"Gone\";\nvar _11 = \"Length Required\";\nvar _12 = \"Precondition Failed\";\nvar _13 = \"Payload Too Large\";\nvar _14 = \"URI Too Long\";\nvar _15 = \"Unsupported Media Type\";\nvar _16 = \"Range Not Satisfiable\";\nvar _17 = \"Expectation Failed\";\nvar _18 = \"I'm a Teapot\";\nvar _21 = \"Misdirected Request\";\nvar _22 = \"Unprocessable Entity\";\nvar _23 = \"Locked\";\nvar _24 = \"Failed Dependency\";\nvar _25 = \"Too Early\";\nvar _262 = \"Upgrade Required\";\nvar _28 = \"Precondition Required\";\nvar _29 = \"Too Many Requests\";\nvar _31 = \"Request Header Fields Too Large\";\nvar _51 = \"Unavailable For Legal Reasons\";\nvar _005 = \"Internal Server Error\";\nvar _015 = \"Not Implemented\";\nvar _025 = \"Bad Gateway\";\nvar _035 = \"Service Unavailable\";\nvar _044 = \"Gateway Timeout\";\nvar _054 = \"HTTP Version Not Supported\";\nvar _063 = \"Variant Also Negotiates\";\nvar _074 = \"Insufficient Storage\";\nvar _084 = \"Loop Detected\";\nvar _092 = \"Bandwidth Limit Exceeded\";\nvar _102 = \"Not Extended\";\nvar _112 = \"Network Authentication Required\";\nvar codes_default = {\n  \"100\": _00,\n  \"101\": _01,\n  \"102\": _02,\n  \"103\": _03,\n  \"200\": _002,\n  \"201\": _012,\n  \"202\": _022,\n  \"203\": _032,\n  \"204\": _04,\n  \"205\": _05,\n  \"206\": _06,\n  \"207\": _07,\n  \"208\": _08,\n  \"226\": _26,\n  \"300\": _003,\n  \"301\": _013,\n  \"302\": _023,\n  \"303\": _033,\n  \"304\": _042,\n  \"305\": _052,\n  \"307\": _072,\n  \"308\": _082,\n  \"400\": _004,\n  \"401\": _014,\n  \"402\": _024,\n  \"403\": _034,\n  \"404\": _043,\n  \"405\": _053,\n  \"406\": _062,\n  \"407\": _073,\n  \"408\": _083,\n  \"409\": _09,\n  \"410\": _10,\n  \"411\": _11,\n  \"412\": _12,\n  \"413\": _13,\n  \"414\": _14,\n  \"415\": _15,\n  \"416\": _16,\n  \"417\": _17,\n  \"418\": _18,\n  \"421\": _21,\n  \"422\": _22,\n  \"423\": _23,\n  \"424\": _24,\n  \"425\": _25,\n  \"426\": _262,\n  \"428\": _28,\n  \"429\": _29,\n  \"431\": _31,\n  \"451\": _51,\n  \"500\": _005,\n  \"501\": _015,\n  \"502\": _025,\n  \"503\": _035,\n  \"504\": _044,\n  \"505\": _054,\n  \"506\": _063,\n  \"507\": _074,\n  \"508\": _084,\n  \"509\": _092,\n  \"510\": _102,\n  \"511\": _112\n};\n\n// src/context/status.ts\nvar status = (statusCode, statusText) => {\n  return res => {\n    res.status = statusCode;\n    res.statusText = statusText || codes_default[String(statusCode)];\n    return res;\n  };\n};\n\n// src/context/set.ts\nvar import_headers_polyfill = require(\"headers-polyfill\");\nfunction set() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  return res => {\n    const [name, value] = args;\n    if (typeof name === \"string\") {\n      res.headers.append(name, value);\n    } else {\n      const headers = (0, import_headers_polyfill.objectToHeaders)(name);\n      headers.forEach((value2, name2) => {\n        res.headers.append(name2, value2);\n      });\n    }\n    return res;\n  };\n}\n\n// src/context/cookie.ts\nvar cookieUtils = __toESM(require(\"cookie\"));\nvar cookie = (name, value, options) => {\n  return res => {\n    const serializedCookie = cookieUtils.serialize(name, value, options);\n    res.headers.append(\"Set-Cookie\", serializedCookie);\n    if (typeof document !== \"undefined\") {\n      document.cookie = serializedCookie;\n    }\n    return res;\n  };\n};\n\n// src/context/body.ts\nvar body = value => {\n  return res => {\n    res.body = value;\n    return res;\n  };\n};\n\n// src/utils/internal/jsonParse.ts\nfunction jsonParse(value) {\n  try {\n    return JSON.parse(value);\n  } catch (error2) {\n    return void 0;\n  }\n}\n\n// src/utils/internal/isObject.ts\nfunction isObject(value) {\n  return value != null && typeof value === \"object\" && !Array.isArray(value);\n}\n\n// src/utils/internal/mergeRight.ts\nfunction mergeRight(left, right) {\n  return Object.entries(right).reduce((result, _ref) => {\n    let [key, rightValue] = _ref;\n    const leftValue = result[key];\n    if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n      result[key] = leftValue.concat(rightValue);\n      return result;\n    }\n    if (isObject(leftValue) && isObject(rightValue)) {\n      result[key] = mergeRight(leftValue, rightValue);\n      return result;\n    }\n    result[key] = rightValue;\n    return result;\n  }, Object.assign({}, left));\n}\n\n// src/context/json.ts\nvar json = body2 => {\n  return res => {\n    res.headers.set(\"Content-Type\", \"application/json\");\n    res.body = JSON.stringify(body2);\n    return res;\n  };\n};\n\n// src/context/data.ts\nvar data = payload => {\n  return res => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      data: payload\n    });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/extensions.ts\nvar extensions = payload => {\n  return res => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      extensions: payload\n    });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/delay.ts\nvar import_is_node_process = require(\"is-node-process\");\nvar SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647;\nvar MIN_SERVER_RESPONSE_TIME = 100;\nvar MAX_SERVER_RESPONSE_TIME = 400;\nvar NODE_SERVER_RESPONSE_TIME = 5;\nvar getRandomServerResponseTime = () => {\n  if ((0, import_is_node_process.isNodeProcess)()) {\n    return NODE_SERVER_RESPONSE_TIME;\n  }\n  return Math.floor(Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) + MIN_SERVER_RESPONSE_TIME);\n};\nvar delay = durationOrMode => {\n  return res => {\n    let delayTime;\n    if (typeof durationOrMode === \"string\") {\n      switch (durationOrMode) {\n        case \"infinite\":\n          {\n            delayTime = SET_TIMEOUT_MAX_ALLOWED_INT;\n            break;\n          }\n        case \"real\":\n          {\n            delayTime = getRandomServerResponseTime();\n            break;\n          }\n        default:\n          {\n            throw new Error(`Failed to delay a response: unknown delay mode \"${durationOrMode}\". Please make sure you provide one of the supported modes (\"real\", \"infinite\") or a number to \"ctx.delay\".`);\n          }\n      }\n    } else if (typeof durationOrMode === \"undefined\") {\n      delayTime = getRandomServerResponseTime();\n    } else {\n      if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {\n        throw new Error(`Failed to delay a response: provided delay duration (${durationOrMode}) exceeds the maximum allowed duration for \"setTimeout\" (${SET_TIMEOUT_MAX_ALLOWED_INT}). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the \"infinite\" delay mode to delay the response indefinitely.`);\n      }\n      delayTime = durationOrMode;\n    }\n    res.delay = delayTime;\n    return res;\n  };\n};\n\n// src/context/errors.ts\nvar errors = errorsList => {\n  return res => {\n    if (errorsList == null) {\n      return res;\n    }\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      errors: errorsList\n    });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/fetch.ts\nvar import_is_node_process2 = require(\"is-node-process\");\nvar import_headers_polyfill2 = require(\"headers-polyfill\");\nvar useFetch = (0, import_is_node_process2.isNodeProcess)() ? (input, init) => Promise.resolve().then(() => __toESM(require(\"node-fetch\"))).then(_ref2 => {\n  let {\n    default: nodeFetch\n  } = _ref2;\n  return nodeFetch(input, init);\n}) : globalThis.fetch;\nvar augmentRequestInit = requestInit => {\n  const headers = new import_headers_polyfill2.Headers(requestInit.headers);\n  headers.set(\"x-msw-bypass\", \"true\");\n  return __spreadProps(__spreadValues({}, requestInit), {\n    headers: headers.all()\n  });\n};\nvar createFetchRequestParameters = input => {\n  const {\n    body: body2,\n    method\n  } = input;\n  const requestParameters = __spreadProps(__spreadValues({}, input), {\n    body: void 0\n  });\n  if ([\"GET\", \"HEAD\"].includes(method)) {\n    return requestParameters;\n  }\n  if (typeof body2 === \"object\" || typeof body2 === \"number\" || typeof body2 === \"boolean\") {\n    requestParameters.body = JSON.stringify(body2);\n  } else {\n    requestParameters.body = body2;\n  }\n  return requestParameters;\n};\nvar fetch = function (input) {\n  let requestInit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof input === \"string\") {\n    return useFetch(input, augmentRequestInit(requestInit));\n  }\n  const requestParameters = createFetchRequestParameters(input);\n  const derivedRequestInit = augmentRequestInit(requestParameters);\n  return useFetch(input.url.href, derivedRequestInit);\n};\n\n// src/context/text.ts\nvar text = body2 => {\n  return res => {\n    res.headers.set(\"Content-Type\", \"text/plain\");\n    res.body = body2;\n    return res;\n  };\n};\n\n// src/context/xml.ts\nvar xml = body2 => {\n  return res => {\n    res.headers.set(\"Content-Type\", \"text/xml\");\n    res.body = body2;\n    return res;\n  };\n};\n\n// src/utils/internal/checkGlobals.ts\nvar import_outvariant2 = require(\"outvariant\");\n\n// src/utils/internal/devUtils.ts\nvar import_outvariant = require(\"outvariant\");\nvar LIBRARY_PREFIX = \"[MSW]\";\nfunction formatMessage(message) {\n  for (var _len2 = arguments.length, positionals = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    positionals[_key2 - 1] = arguments[_key2];\n  }\n  const interpolatedMessage = (0, import_outvariant.format)(message, ...positionals);\n  return `${LIBRARY_PREFIX} ${interpolatedMessage}`;\n}\nfunction warn(message) {\n  for (var _len3 = arguments.length, positionals = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    positionals[_key3 - 1] = arguments[_key3];\n  }\n  console.warn(formatMessage(message, ...positionals));\n}\nfunction error(message) {\n  for (var _len4 = arguments.length, positionals = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    positionals[_key4 - 1] = arguments[_key4];\n  }\n  console.error(formatMessage(message, ...positionals));\n}\nvar devUtils = {\n  formatMessage,\n  warn,\n  error\n};\n\n// src/utils/internal/checkGlobals.ts\nfunction checkGlobals() {\n  (0, import_outvariant2.invariant)(typeof URL !== \"undefined\", devUtils.formatMessage(`Global \"URL\" class is not defined. This likely means that you're running MSW in an environment that doesn't support all Node.js standard API (e.g. React Native). If that's the case, please use an appropriate polyfill for the \"URL\" class, like \"react-native-url-polyfill\".`));\n}\n\n// src/setupWorker/setupWorker.ts\nvar import_outvariant5 = require(\"outvariant\");\nvar import_is_node_process3 = require(\"is-node-process\");\n\n// src/setupWorker/start/createStartHandler.ts\nvar import_until4 = require(\"@open-draft/until\");\n\n// src/setupWorker/start/utils/getWorkerInstance.ts\nvar import_until = require(\"@open-draft/until\");\n\n// src/setupWorker/start/utils/getWorkerByRegistration.ts\nvar getWorkerByRegistration = (registration, absoluteWorkerUrl, findWorker) => {\n  const allStates = [registration.active, registration.installing, registration.waiting];\n  const existingStates = allStates.filter(Boolean);\n  const mockWorker = existingStates.find(worker => {\n    return findWorker(worker.scriptURL, absoluteWorkerUrl);\n  });\n  return mockWorker || null;\n};\n\n// src/utils/url/getAbsoluteWorkerUrl.ts\nfunction getAbsoluteWorkerUrl(workerUrl) {\n  return new URL(workerUrl, location.href).href;\n}\n\n// src/setupWorker/start/utils/getWorkerInstance.ts\nvar getWorkerInstance = async function (url) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let findWorker = arguments.length > 2 ? arguments[2] : undefined;\n  const absoluteWorkerUrl = getAbsoluteWorkerUrl(url);\n  const mockRegistrations = await navigator.serviceWorker.getRegistrations().then(registrations => registrations.filter(registration => getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker)));\n  if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n    location.reload();\n  }\n  const [existingRegistration] = mockRegistrations;\n  if (existingRegistration) {\n    return existingRegistration.update().then(() => {\n      return [getWorkerByRegistration(existingRegistration, absoluteWorkerUrl, findWorker), existingRegistration];\n    });\n  }\n  const [error2, instance] = await (0, import_until.until)(async () => {\n    const registration = await navigator.serviceWorker.register(url, options);\n    return [getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker), registration];\n  });\n  if (error2) {\n    const isWorkerMissing = error2.message.includes(\"(404)\");\n    if (isWorkerMissing) {\n      const scopeUrl = new URL((options == null ? void 0 : options.scope) || \"/\", location.href);\n      throw new Error(devUtils.formatMessage(`Failed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`));\n    }\n    throw new Error(devUtils.formatMessage(\"Failed to register the Service Worker:\\n\\n%s\", error2.message));\n  }\n  return instance;\n};\n\n// src/setupWorker/start/utils/printStartMessage.ts\nfunction printStartMessage() {\n  let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  if (args.quiet) {\n    return;\n  }\n  const message = args.message || \"Mocking enabled.\";\n  console.groupCollapsed(`%c${devUtils.formatMessage(message)}`, \"color:orangered;font-weight:bold;\");\n  console.log(\"%cDocumentation: %chttps://mswjs.io/docs\", \"font-weight:bold\", \"font-weight:normal\");\n  console.log(\"Found an issue? https://github.com/mswjs/msw/issues\");\n  if (args.workerUrl) {\n    console.log(\"Worker script URL:\", args.workerUrl);\n  }\n  if (args.workerScope) {\n    console.log(\"Worker scope:\", args.workerScope);\n  }\n  console.groupEnd();\n}\n\n// src/setupWorker/start/utils/enableMocking.ts\nasync function enableMocking(context, options) {\n  var _a, _b;\n  context.workerChannel.send(\"MOCK_ACTIVATE\");\n  await context.events.once(\"MOCKING_ENABLED\");\n  if (context.isMockingEnabled) {\n    devUtils.warn(`Found a redundant \"worker.start()\" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this \"worker.start()\" call.`);\n    return;\n  }\n  context.isMockingEnabled = true;\n  printStartMessage({\n    quiet: options.quiet,\n    workerScope: (_a = context.registration) == null ? void 0 : _a.scope,\n    workerUrl: (_b = context.worker) == null ? void 0 : _b.scriptURL\n  });\n}\n\n// src/setupWorker/start/utils/createMessageChannel.ts\nvar WorkerChannel = class {\n  constructor(port) {\n    this.port = port;\n  }\n  postMessage(event) {\n    for (var _len5 = arguments.length, rest2 = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      rest2[_key5 - 1] = arguments[_key5];\n    }\n    const [data2, transfer] = rest2;\n    this.port.postMessage({\n      type: event,\n      data: data2\n    }, {\n      transfer\n    });\n  }\n};\n\n// src/utils/NetworkError.ts\nvar NetworkError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"NetworkError\";\n  }\n};\n\n// src/utils/request/parseWorkerRequest.ts\nvar import_interceptors2 = require(\"@mswjs/interceptors\");\nvar import_headers_polyfill5 = require(\"headers-polyfill\");\n\n// src/utils/request/MockedRequest.ts\nvar cookieUtils3 = __toESM(require(\"cookie\"));\nvar import_cookies = require(\"@mswjs/cookies\");\nvar import_interceptors = require(\"@mswjs/interceptors\");\nvar import_bufferUtils = require(\"@mswjs/interceptors/lib/utils/bufferUtils.js\");\nvar import_headers_polyfill4 = require(\"headers-polyfill\");\n\n// src/utils/request/getRequestCookies.ts\nvar cookieUtils2 = __toESM(require(\"cookie\"));\nfunction getAllCookies() {\n  return cookieUtils2.parse(document.cookie);\n}\nfunction getRequestCookies(request) {\n  if (typeof document === \"undefined\" || typeof location === \"undefined\") {\n    return {};\n  }\n  switch (request.credentials) {\n    case \"same-origin\":\n      {\n        return location.origin === request.url.origin ? getAllCookies() : {};\n      }\n    case \"include\":\n      {\n        return getAllCookies();\n      }\n    default:\n      {\n        return {};\n      }\n  }\n}\n\n// src/utils/internal/parseMultipartData.ts\nvar import_headers_polyfill3 = require(\"headers-polyfill\");\nfunction parseContentHeaders(headersString) {\n  var _a, _b;\n  const headers = (0, import_headers_polyfill3.stringToHeaders)(headersString);\n  const contentType = headers.get(\"content-type\") || \"text/plain\";\n  const disposition = headers.get(\"content-disposition\");\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.');\n  }\n  const directives = disposition.split(\";\").reduce((acc, chunk) => {\n    const [name2, ...rest2] = chunk.trim().split(\"=\");\n    acc[name2] = rest2.join(\"=\");\n    return acc;\n  }, {});\n  const name = (_a = directives.name) == null ? void 0 : _a.slice(1, -1);\n  const filename = (_b = directives.filename) == null ? void 0 : _b.slice(1, -1);\n  return {\n    name,\n    filename,\n    contentType\n  };\n}\nfunction parseMultipartData(data2, headers) {\n  const contentType = headers == null ? void 0 : headers.get(\"content-type\");\n  if (!contentType) {\n    return void 0;\n  }\n  const [, ...directives] = contentType.split(/; */);\n  const boundary = directives.filter(d => d.startsWith(\"boundary=\")).map(s => s.replace(/^boundary=/, \"\"))[0];\n  if (!boundary) {\n    return void 0;\n  }\n  const boundaryRegExp = new RegExp(`--+${boundary}`);\n  const fields = data2.split(boundaryRegExp).filter(chunk => chunk.startsWith(\"\\r\\n\") && chunk.endsWith(\"\\r\\n\")).map(chunk => chunk.trimStart().replace(/\\r\\n$/, \"\"));\n  if (!fields.length) {\n    return void 0;\n  }\n  const parsedBody = {};\n  try {\n    for (const field2 of fields) {\n      const [contentHeaders, ...rest2] = field2.split(\"\\r\\n\\r\\n\");\n      const contentBody = rest2.join(\"\\r\\n\\r\\n\");\n      const {\n        contentType: contentType2,\n        filename,\n        name\n      } = parseContentHeaders(contentHeaders);\n      const value = filename === void 0 ? contentBody : new File([contentBody], filename, {\n        type: contentType2\n      });\n      const parsedValue = parsedBody[name];\n      if (parsedValue === void 0) {\n        parsedBody[name] = value;\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value];\n      } else {\n        parsedBody[name] = [parsedValue, value];\n      }\n    }\n    return parsedBody;\n  } catch (error2) {\n    return void 0;\n  }\n}\n\n// src/utils/request/parseBody.ts\nfunction parseBody(body2, headers) {\n  var _a;\n  if (!body2) {\n    return body2;\n  }\n  const contentType = ((_a = headers == null ? void 0 : headers.get(\"content-type\")) == null ? void 0 : _a.toLowerCase()) || \"\";\n  const hasMultipartContent = contentType.startsWith(\"multipart/form-data\");\n  if (hasMultipartContent && typeof body2 !== \"object\") {\n    return parseMultipartData(body2.toString(), headers) || body2;\n  }\n  const hasJsonContent = contentType.includes(\"json\");\n  if (hasJsonContent && typeof body2 !== \"object\") {\n    return jsonParse(body2.toString()) || body2;\n  }\n  return body2;\n}\n\n// src/utils/internal/isStringEqual.ts\nfunction isStringEqual(actual, expected) {\n  return actual.toLowerCase() === expected.toLowerCase();\n}\n\n// src/utils/request/MockedRequest.ts\nvar MockedRequest = class extends import_interceptors.IsomorphicRequest {\n  constructor(url) {\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(url, init);\n    if (init.id) {\n      this.id = init.id;\n    }\n    this.cache = init.cache || \"default\";\n    this.destination = init.destination || \"\";\n    this.integrity = init.integrity || \"\";\n    this.keepalive = init.keepalive || false;\n    this.mode = init.mode || \"cors\";\n    this.priority = init.priority || \"auto\";\n    this.redirect = init.redirect || \"follow\";\n    this.referrer = init.referrer || \"\";\n    this.referrerPolicy = init.referrerPolicy || \"no-referrer\";\n    this.cookies = init.cookies || this.getCookies();\n  }\n  get body() {\n    const text2 = (0, import_bufferUtils.decodeBuffer)(this[\"_body\"]);\n    const body2 = parseBody(text2, this.headers);\n    if (isStringEqual(this.method, \"GET\") && body2 === \"\") {\n      return void 0;\n    }\n    return body2;\n  }\n  passthrough() {\n    return {\n      status: 101,\n      statusText: \"Continue\",\n      headers: new import_headers_polyfill4.Headers(),\n      body: null,\n      passthrough: true,\n      once: false\n    };\n  }\n  getCookies() {\n    var _a;\n    const requestCookiesString = this.headers.get(\"cookie\");\n    const ownCookies = requestCookiesString ? cookieUtils3.parse(requestCookiesString) : {};\n    import_cookies.store.hydrate();\n    const cookiesFromStore = Array.from((_a = import_cookies.store.get(__spreadProps(__spreadValues({}, this), {\n      url: this.url.href\n    }))) == null ? void 0 : _a.entries()).reduce((cookies, _ref3) => {\n      let [name, {\n        value\n      }] = _ref3;\n      return Object.assign(cookies, {\n        [name.trim()]: value\n      });\n    }, {});\n    const cookiesFromDocument = getRequestCookies(this);\n    const forwardedCookies = __spreadValues(__spreadValues({}, cookiesFromDocument), cookiesFromStore);\n    for (const [name, value] of Object.entries(forwardedCookies)) {\n      this.headers.append(\"cookie\", `${name}=${value}`);\n    }\n    return __spreadValues(__spreadValues({}, forwardedCookies), ownCookies);\n  }\n};\n\n// src/utils/request/parseWorkerRequest.ts\nfunction parseWorkerRequest(rawRequest) {\n  const url = new URL(rawRequest.url);\n  const headers = new import_headers_polyfill5.Headers(rawRequest.headers);\n  return new MockedRequest(url, __spreadProps(__spreadValues({}, rawRequest), {\n    body: (0, import_interceptors2.encodeBuffer)(rawRequest.body || \"\"),\n    headers\n  }));\n}\n\n// src/utils/handleRequest.ts\nvar import_until2 = require(\"@open-draft/until\");\n\n// src/utils/getResponse.ts\nvar getResponse = async (request, handlers, resolutionContext) => {\n  const relevantHandlers = handlers.filter(handler => {\n    return handler.test(request, resolutionContext);\n  });\n  if (relevantHandlers.length === 0) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n  const result = await relevantHandlers.reduce(async (executionResult, handler) => {\n    const previousResults = await executionResult;\n    if (!!(previousResults == null ? void 0 : previousResults.response)) {\n      return executionResult;\n    }\n    const result2 = await handler.run(request, resolutionContext);\n    if (result2 === null || result2.handler.shouldSkip) {\n      return null;\n    }\n    if (!result2.response) {\n      return {\n        request: result2.request,\n        handler: result2.handler,\n        response: void 0,\n        parsedResult: result2.parsedResult\n      };\n    }\n    if (result2.response.once) {\n      handler.markAsSkipped(true);\n    }\n    return result2;\n  }, Promise.resolve(null));\n  if (!result) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n  return {\n    handler: result.handler,\n    publicRequest: result.request,\n    parsedRequest: result.parsedResult,\n    response: result.response\n  };\n};\n\n// src/utils/request/onUnhandledRequest.ts\nvar import_js_levenshtein = __toESM(require(\"js-levenshtein\"));\n\n// src/utils/internal/parseGraphQLRequest.ts\nvar import_graphql = require(\"graphql\");\n\n// src/utils/request/getPublicUrlFromRequest.ts\nvar getPublicUrlFromRequest = request => {\n  return request.referrer.startsWith(request.url.origin) ? request.url.pathname : new URL(request.url.pathname, `${request.url.protocol}//${request.url.host}`).href;\n};\n\n// src/utils/internal/parseGraphQLRequest.ts\nfunction parseDocumentNode(node) {\n  var _a;\n  const operationDef = node.definitions.find(def => {\n    return def.kind === \"OperationDefinition\";\n  });\n  return {\n    operationType: operationDef == null ? void 0 : operationDef.operation,\n    operationName: (_a = operationDef == null ? void 0 : operationDef.name) == null ? void 0 : _a.value\n  };\n}\nfunction parseQuery(query) {\n  try {\n    const ast = (0, import_graphql.parse)(query);\n    return parseDocumentNode(ast);\n  } catch (error2) {\n    return error2;\n  }\n}\nfunction extractMultipartVariables(variables, map, files) {\n  const operations = {\n    variables\n  };\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(`Given files do not have a key '${key}' .`);\n    }\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split(\".\").reverse();\n      const paths = reversedPaths.reverse();\n      let target = operations;\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(`Property '${paths}' is not in operations.`);\n        }\n        target = target[path];\n      }\n      target[lastPath] = files[key];\n    }\n  }\n  return operations.variables;\n}\nfunction getGraphQLInput(request) {\n  var _a, _b;\n  switch (request.method) {\n    case \"GET\":\n      {\n        const query = request.url.searchParams.get(\"query\");\n        const variables = request.url.searchParams.get(\"variables\") || \"\";\n        return {\n          query,\n          variables: jsonParse(variables)\n        };\n      }\n    case \"POST\":\n      {\n        if ((_a = request.body) == null ? void 0 : _a.query) {\n          const {\n            query,\n            variables\n          } = request.body;\n          return {\n            query,\n            variables\n          };\n        }\n        if ((_b = request.body) == null ? void 0 : _b.operations) {\n          const _c = request.body,\n            {\n              operations,\n              map\n            } = _c,\n            files = __objRest(_c, [\"operations\", \"map\"]);\n          const parsedOperations = jsonParse(operations) || {};\n          if (!parsedOperations.query) {\n            return null;\n          }\n          const parsedMap = jsonParse(map || \"\") || {};\n          const variables = parsedOperations.variables ? extractMultipartVariables(parsedOperations.variables, parsedMap, files) : {};\n          return {\n            query: parsedOperations.query,\n            variables\n          };\n        }\n      }\n    default:\n      return null;\n  }\n}\nfunction parseGraphQLRequest(request) {\n  const input = getGraphQLInput(request);\n  if (!input || !input.query) {\n    return void 0;\n  }\n  const {\n    query,\n    variables\n  } = input;\n  const parsedResult = parseQuery(query);\n  if (parsedResult instanceof Error) {\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    throw new Error(devUtils.formatMessage('Failed to intercept a GraphQL request to \"%s %s\": cannot parse query. See the error message from the parser below.\\n\\n%s', request.method, requestPublicUrl, parsedResult.message));\n  }\n  return {\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables\n  };\n}\n\n// src/utils/logging/getStatusCodeColor.ts\nfunction getStatusCodeColor(status2) {\n  if (status2 < 300) {\n    return \"#69AB32\" /* Success */;\n  }\n\n  if (status2 < 400) {\n    return \"#F0BB4B\" /* Warning */;\n  }\n\n  return \"#E95F5D\" /* Danger */;\n}\n\n// src/utils/logging/getTimestamp.ts\nfunction getTimestamp() {\n  const now = new Date();\n  return [now.getHours(), now.getMinutes(), now.getSeconds()].map(String).map(chunk => chunk.slice(0, 2)).map(chunk => chunk.padStart(2, \"0\")).join(\":\");\n}\n\n// src/utils/logging/prepareRequest.ts\nfunction prepareRequest(request) {\n  return __spreadProps(__spreadValues({}, request), {\n    body: request.body,\n    headers: request.headers.all()\n  });\n}\n\n// src/utils/logging/prepareResponse.ts\nvar import_headers_polyfill6 = require(\"headers-polyfill\");\nfunction prepareResponse(res) {\n  const responseHeaders = (0, import_headers_polyfill6.objectToHeaders)(res.headers);\n  return __spreadProps(__spreadValues({}, res), {\n    body: parseBody(res.body, responseHeaders)\n  });\n}\n\n// src/utils/matching/matchRequestUrl.ts\nvar import_path_to_regexp = require(\"path-to-regexp\");\nvar import_getCleanUrl = require(\"@mswjs/interceptors/lib/utils/getCleanUrl.js\");\n\n// src/utils/url/cleanUrl.ts\nvar REDUNDANT_CHARACTERS_EXP = /[\\?|#].*$/g;\nfunction getSearchParams(path) {\n  return new URL(`/${path}`, \"http://localhost\").searchParams;\n}\nfunction cleanUrl(path) {\n  return path.replace(REDUNDANT_CHARACTERS_EXP, \"\");\n}\n\n// src/utils/url/isAbsoluteUrl.ts\nfunction isAbsoluteUrl(url) {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n}\n\n// src/utils/url/getAbsoluteUrl.ts\nfunction getAbsoluteUrl(path, baseUrl) {\n  if (isAbsoluteUrl(path)) {\n    return path;\n  }\n  if (path.startsWith(\"*\")) {\n    return path;\n  }\n  const origin = baseUrl || typeof document !== \"undefined\" && document.baseURI;\n  return origin ? decodeURI(new URL(encodeURI(path), origin).href) : path;\n}\n\n// src/utils/matching/normalizePath.ts\nfunction normalizePath(path, baseUrl) {\n  if (path instanceof RegExp) {\n    return path;\n  }\n  const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl);\n  return cleanUrl(maybeAbsoluteUrl);\n}\n\n// src/utils/matching/matchRequestUrl.ts\nfunction coercePath(path) {\n  return path.replace(/([:a-zA-Z_-]*)(\\*{1,2})+/g, (_, parameterName, wildcard) => {\n    const expression = \"(.*)\";\n    if (!parameterName) {\n      return expression;\n    }\n    return parameterName.startsWith(\":\") ? `${parameterName}${wildcard}` : `${parameterName}${expression}`;\n  }).replace(/([^\\/])(:)(?=\\d+)/, \"$1\\\\$2\").replace(/^([^\\/]+)(:)(?=\\/\\/)/, \"$1\\\\$2\");\n}\nfunction matchRequestUrl(url, path, baseUrl) {\n  const normalizedPath = normalizePath(path, baseUrl);\n  const cleanPath = typeof normalizedPath === \"string\" ? coercePath(normalizedPath) : normalizedPath;\n  const cleanUrl2 = (0, import_getCleanUrl.getCleanUrl)(url);\n  const result = (0, import_path_to_regexp.match)(cleanPath, {\n    decode: decodeURIComponent\n  })(cleanUrl2);\n  const params = result && result.params || {};\n  return {\n    matches: result !== false,\n    params\n  };\n}\n\n// src/handlers/RequestHandler.ts\nvar import_headers_polyfill8 = require(\"headers-polyfill\");\n\n// src/response.ts\nvar import_headers_polyfill7 = require(\"headers-polyfill\");\n\n// src/utils/internal/compose.ts\nfunction compose() {\n  for (var _len6 = arguments.length, fns = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    fns[_key6] = arguments[_key6];\n  }\n  return function () {\n    return fns.reduceRight((leftFn, rightFn) => {\n      return leftFn instanceof Promise ? Promise.resolve(leftFn).then(rightFn) : rightFn(leftFn);\n    }, arguments.length <= 0 ? undefined : arguments[0]);\n  };\n}\n\n// src/response.ts\nvar defaultResponse = {\n  status: 200,\n  statusText: \"OK\",\n  body: null,\n  delay: 0,\n  once: false,\n  passthrough: false\n};\nvar defaultResponseTransformers = [];\nfunction createResponseComposition(responseOverrides) {\n  let defaultTransformers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultResponseTransformers;\n  return async function () {\n    const initialResponse = Object.assign({}, defaultResponse, {\n      headers: new import_headers_polyfill7.Headers({\n        \"x-powered-by\": \"msw\"\n      })\n    }, responseOverrides);\n    for (var _len7 = arguments.length, transformers = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      transformers[_key7] = arguments[_key7];\n    }\n    const resolvedTransformers = [...defaultTransformers, ...transformers].filter(Boolean);\n    const resolvedResponse = resolvedTransformers.length > 0 ? compose(...resolvedTransformers)(initialResponse) : initialResponse;\n    return resolvedResponse;\n  };\n}\nvar response = Object.assign(createResponseComposition(), {\n  once: createResponseComposition({\n    once: true\n  }),\n  networkError(message) {\n    throw new NetworkError(message);\n  }\n});\n\n// src/utils/internal/getCallFrame.ts\nvar SOURCE_FRAME = /[\\/\\\\]msw[\\/\\\\]src[\\/\\\\](.+)/;\nvar BUILD_FRAME = /(node_modules)?[\\/\\\\]lib[\\/\\\\](umd|esm|iief|cjs)[\\/\\\\]|^[^\\/\\\\]*$/;\nfunction getCallFrame(error2) {\n  const stack = error2.stack;\n  if (!stack) {\n    return;\n  }\n  const frames = stack.split(\"\\n\").slice(1);\n  const declarationFrame = frames.find(frame => {\n    return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame));\n  });\n  if (!declarationFrame) {\n    return;\n  }\n  const declarationPath = declarationFrame.replace(/\\s*at [^()]*\\(([^)]+)\\)/, \"$1\").replace(/^@/, \"\");\n  return declarationPath;\n}\n\n// src/utils/internal/isIterable.ts\nfunction isIterable(fn) {\n  if (!fn) {\n    return false;\n  }\n  return typeof fn[Symbol.iterator] == \"function\";\n}\n\n// src/handlers/RequestHandler.ts\nvar defaultContext = {\n  status,\n  set,\n  delay,\n  fetch\n};\nvar RequestHandler = class {\n  constructor(options) {\n    this.shouldSkip = false;\n    this.ctx = options.ctx || defaultContext;\n    this.resolver = options.resolver;\n    const callFrame = getCallFrame(new Error());\n    this.info = __spreadProps(__spreadValues({}, options.info), {\n      callFrame\n    });\n  }\n  parse(_request, _resolutionContext) {\n    return null;\n  }\n  test(request, resolutionContext) {\n    return this.predicate(request, this.parse(request, resolutionContext), resolutionContext);\n  }\n  getPublicRequest(request, _parsedResult) {\n    return request;\n  }\n  markAsSkipped() {\n    let shouldSkip = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this.shouldSkip = shouldSkip;\n  }\n  async run(request, resolutionContext) {\n    if (this.shouldSkip) {\n      return null;\n    }\n    const parsedResult = this.parse(request, resolutionContext);\n    const shouldIntercept = this.predicate(request, parsedResult, resolutionContext);\n    if (!shouldIntercept) {\n      return null;\n    }\n    const publicRequest = this.getPublicRequest(request, parsedResult);\n    const executeResolver = this.wrapResolver(this.resolver);\n    const mockedResponse = await executeResolver(publicRequest, response, this.ctx);\n    return this.createExecutionResult(parsedResult, publicRequest, mockedResponse);\n  }\n  wrapResolver(resolver) {\n    return async (req, res, ctx) => {\n      const result = this.resolverGenerator || (await resolver(req, res, ctx));\n      if (isIterable(result)) {\n        const {\n          value,\n          done\n        } = result[Symbol.iterator]().next();\n        const nextResponse = await value;\n        if (!nextResponse && done) {\n          return this.resolverGeneratorResult;\n        }\n        if (!this.resolverGenerator) {\n          this.resolverGenerator = result;\n        }\n        this.resolverGeneratorResult = nextResponse;\n        return nextResponse;\n      }\n      return result;\n    };\n  }\n  createExecutionResult(parsedResult, request, response2) {\n    return {\n      handler: this,\n      parsedResult: parsedResult || null,\n      request,\n      response: response2 || null\n    };\n  }\n};\n\n// src/handlers/RestHandler.ts\nvar RESTMethods = /* @__PURE__ */(RESTMethods2 => {\n  RESTMethods2[\"HEAD\"] = \"HEAD\";\n  RESTMethods2[\"GET\"] = \"GET\";\n  RESTMethods2[\"POST\"] = \"POST\";\n  RESTMethods2[\"PUT\"] = \"PUT\";\n  RESTMethods2[\"PATCH\"] = \"PATCH\";\n  RESTMethods2[\"OPTIONS\"] = \"OPTIONS\";\n  RESTMethods2[\"DELETE\"] = \"DELETE\";\n  return RESTMethods2;\n})(RESTMethods || {});\nvar restContext = __spreadProps(__spreadValues({}, defaultContext), {\n  cookie,\n  body,\n  text,\n  json,\n  xml\n});\nvar RestRequest = class extends MockedRequest {\n  constructor(request, params) {\n    super(request.url, __spreadProps(__spreadValues({}, request), {\n      body: request[\"_body\"]\n    }));\n    this.params = params;\n    this.id = request.id;\n  }\n};\nvar RestHandler = class extends RequestHandler {\n  constructor(method, path, resolver) {\n    super({\n      info: {\n        header: `${method} ${path}`,\n        path,\n        method\n      },\n      ctx: restContext,\n      resolver\n    });\n    this.checkRedundantQueryParameters();\n  }\n  checkRedundantQueryParameters() {\n    const {\n      method,\n      path\n    } = this.info;\n    if (path instanceof RegExp) {\n      return;\n    }\n    const url = cleanUrl(path);\n    if (url === path) {\n      return;\n    }\n    const searchParams = getSearchParams(path);\n    const queryParams = [];\n    searchParams.forEach((_, paramName) => {\n      queryParams.push(paramName);\n    });\n    devUtils.warn(`Found a redundant usage of query parameters in the request handler URL for \"${method} ${path}\". Please match against a path instead and access query parameters in the response resolver function using \"req.url.searchParams\".`);\n  }\n  parse(request, resolutionContext) {\n    return matchRequestUrl(request.url, this.info.path, resolutionContext == null ? void 0 : resolutionContext.baseUrl);\n  }\n  getPublicRequest(request, parsedResult) {\n    return new RestRequest(request, parsedResult.params || {});\n  }\n  predicate(request, parsedResult) {\n    const matchesMethod = this.info.method instanceof RegExp ? this.info.method.test(request.method) : isStringEqual(this.info.method, request.method);\n    return matchesMethod && parsedResult.matches;\n  }\n  log(request, response2) {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    console.groupCollapsed(devUtils.formatMessage(\"%s %s %s (%c%s%c)\"), getTimestamp(), request.method, publicUrl, `color:${statusColor}`, `${response2.status} ${response2.statusText}`, \"color:inherit\");\n    console.log(\"Request\", loggedRequest);\n    console.log(\"Handler:\", this);\n    console.log(\"Response\", loggedResponse);\n    console.groupEnd();\n  }\n};\n\n// src/context/field.ts\nvar import_outvariant3 = require(\"outvariant\");\nvar field = (fieldName, fieldValue) => {\n  return res => {\n    validateFieldName(fieldName);\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      [fieldName]: fieldValue\n    });\n    return json(nextBody)(res);\n  };\n};\nfunction validateFieldName(fieldName) {\n  (0, import_outvariant3.invariant)(fieldName.trim() !== \"\", devUtils.formatMessage(\"Failed to set a custom field on a GraphQL response: field name cannot be empty.\"));\n  (0, import_outvariant3.invariant)(fieldName !== \"data\", devUtils.formatMessage('Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.data()\" instead?', fieldName));\n  (0, import_outvariant3.invariant)(fieldName !== \"errors\", devUtils.formatMessage('Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.errors()\" instead?', fieldName));\n  (0, import_outvariant3.invariant)(fieldName !== \"extensions\", devUtils.formatMessage('Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.extensions()\" instead?', fieldName));\n}\n\n// src/utils/internal/tryCatch.ts\nfunction tryCatch(fn, onException) {\n  try {\n    const result = fn();\n    return result;\n  } catch (error2) {\n    onException == null ? void 0 : onException(error2);\n  }\n}\n\n// src/handlers/GraphQLHandler.ts\nvar graphqlContext = __spreadProps(__spreadValues({}, defaultContext), {\n  data,\n  extensions,\n  errors,\n  cookie,\n  field\n});\nfunction isDocumentNode(value) {\n  if (value == null) {\n    return false;\n  }\n  return typeof value === \"object\" && \"kind\" in value && \"definitions\" in value;\n}\nvar GraphQLRequest = class extends MockedRequest {\n  constructor(request, variables) {\n    super(request.url, __spreadProps(__spreadValues({}, request), {\n      body: request[\"_body\"]\n    }));\n    this.variables = variables;\n  }\n};\nvar GraphQLHandler = class extends RequestHandler {\n  constructor(operationType, operationName, endpoint, resolver) {\n    let resolvedOperationName = operationName;\n    if (isDocumentNode(operationName)) {\n      const parsedNode = parseDocumentNode(operationName);\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(`Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected \"${operationType}\", but got \"${parsedNode.operationType}\").`);\n      }\n      if (!parsedNode.operationName) {\n        throw new Error(`Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`);\n      }\n      resolvedOperationName = parsedNode.operationName;\n    }\n    const header = operationType === \"all\" ? `${operationType} (origin: ${endpoint.toString()})` : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`;\n    super({\n      info: {\n        header,\n        operationType,\n        operationName: resolvedOperationName\n      },\n      ctx: graphqlContext,\n      resolver\n    });\n    this.endpoint = endpoint;\n  }\n  parse(request) {\n    return tryCatch(() => parseGraphQLRequest(request), error2 => console.error(error2.message));\n  }\n  getPublicRequest(request, parsedResult) {\n    return new GraphQLRequest(request, (parsedResult == null ? void 0 : parsedResult.variables) || {});\n  }\n  predicate(request, parsedResult) {\n    if (!parsedResult) {\n      return false;\n    }\n    if (!parsedResult.operationName && this.info.operationType !== \"all\") {\n      const publicUrl = getPublicUrlFromRequest(request);\n      devUtils.warn(`Failed to intercept a GraphQL request at \"${request.method} ${publicUrl}\": anonymous GraphQL operations are not supported.\n\nConsider naming this operation or using \"graphql.operation\" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/operation      `);\n      return false;\n    }\n    const hasMatchingUrl = matchRequestUrl(request.url, this.endpoint);\n    const hasMatchingOperationType = this.info.operationType === \"all\" || parsedResult.operationType === this.info.operationType;\n    const hasMatchingOperationName = this.info.operationName instanceof RegExp ? this.info.operationName.test(parsedResult.operationName || \"\") : parsedResult.operationName === this.info.operationName;\n    return hasMatchingUrl.matches && hasMatchingOperationType && hasMatchingOperationName;\n  }\n  log(request, response2, parsedRequest) {\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    const requestInfo = (parsedRequest == null ? void 0 : parsedRequest.operationName) ? `${parsedRequest == null ? void 0 : parsedRequest.operationType} ${parsedRequest == null ? void 0 : parsedRequest.operationName}` : `anonymous ${parsedRequest == null ? void 0 : parsedRequest.operationType}`;\n    console.groupCollapsed(devUtils.formatMessage(\"%s %s (%c%s%c)\"), getTimestamp(), `${requestInfo}`, `color:${statusColor}`, `${response2.status} ${response2.statusText}`, \"color:inherit\");\n    console.log(\"Request:\", loggedRequest);\n    console.log(\"Handler:\", this);\n    console.log(\"Response:\", loggedResponse);\n    console.groupEnd();\n  }\n};\n\n// src/utils/request/onUnhandledRequest.ts\nvar MAX_MATCH_SCORE = 3;\nvar MAX_SUGGESTION_COUNT = 4;\nvar TYPE_MATCH_DELTA = 0.5;\nfunction groupHandlersByType(handlers) {\n  return handlers.reduce((groups, handler) => {\n    if (handler instanceof RestHandler) {\n      groups.rest.push(handler);\n    }\n    if (handler instanceof GraphQLHandler) {\n      groups.graphql.push(handler);\n    }\n    return groups;\n  }, {\n    rest: [],\n    graphql: []\n  });\n}\nfunction getRestHandlerScore() {\n  return (request, handler) => {\n    const {\n      path,\n      method\n    } = handler.info;\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity;\n    }\n    const hasSameMethod = isStringEqual(request.method, method);\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0;\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    const score = (0, import_js_levenshtein.default)(requestPublicUrl, path);\n    return score - methodScoreDelta;\n  };\n}\nfunction getGraphQLHandlerScore(parsedQuery) {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === \"undefined\") {\n      return Infinity;\n    }\n    const {\n      operationType,\n      operationName\n    } = handler.info;\n    if (typeof operationName !== \"string\") {\n      return Infinity;\n    }\n    const hasSameOperationType = parsedQuery.operationType === operationType;\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0;\n    const score = (0, import_js_levenshtein.default)(parsedQuery.operationName, operationName);\n    return score - operationTypeScoreDelta;\n  };\n}\nfunction getSuggestedHandler(request, handlers, getScore) {\n  const suggestedHandlers = handlers.reduce((suggestions, handler) => {\n    const score = getScore(request, handler);\n    return suggestions.concat([[score, handler]]);\n  }, []).sort((_ref4, _ref5) => {\n    let [leftScore] = _ref4;\n    let [rightScore] = _ref5;\n    return leftScore - rightScore;\n  }).filter(_ref6 => {\n    let [score] = _ref6;\n    return score <= MAX_MATCH_SCORE;\n  }).slice(0, MAX_SUGGESTION_COUNT).map(_ref7 => {\n    let [, handler] = _ref7;\n    return handler;\n  });\n  return suggestedHandlers;\n}\nfunction getSuggestedHandlersMessage(handlers) {\n  if (handlers.length > 1) {\n    return `Did you mean to request one of the following resources instead?\n\n${handlers.map(handler => `  \\u2022 ${handler.info.header}`).join(\"\\n\")}`;\n  }\n  return `Did you mean to request \"${handlers[0].info.header}\" instead?`;\n}\nfunction onUnhandledRequest(request, handlers) {\n  let strategy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"warn\";\n  const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request));\n  function generateHandlerSuggestion() {\n    const handlerGroups = groupHandlersByType(handlers);\n    const relevantHandlers = parsedGraphQLQuery ? handlerGroups.graphql : handlerGroups.rest;\n    const suggestedHandlers = getSuggestedHandler(request, relevantHandlers, parsedGraphQLQuery ? getGraphQLHandlerScore(parsedGraphQLQuery) : getRestHandlerScore());\n    return suggestedHandlers.length > 0 ? getSuggestedHandlersMessage(suggestedHandlers) : \"\";\n  }\n  function generateUnhandledRequestMessage() {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const requestHeader = parsedGraphQLQuery ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})` : `${request.method} ${publicUrl}`;\n    const handlerSuggestion = generateHandlerSuggestion();\n    const messageTemplate = [`captured a request without a matching request handler:`, `  \\u2022 ${requestHeader}`, handlerSuggestion, `If you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks`].filter(Boolean);\n    return messageTemplate.join(\"\\n\\n\");\n  }\n  function applyStrategy(strategy2) {\n    const message = generateUnhandledRequestMessage();\n    switch (strategy2) {\n      case \"error\":\n        {\n          devUtils.error(\"Error: %s\", message);\n          throw new Error(devUtils.formatMessage('Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.'));\n        }\n      case \"warn\":\n        {\n          devUtils.warn(\"Warning: %s\", message);\n          break;\n        }\n      case \"bypass\":\n        break;\n      default:\n        throw new Error(devUtils.formatMessage('Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.', strategy2));\n    }\n  }\n  if (typeof strategy === \"function\") {\n    strategy(request, {\n      warning: applyStrategy.bind(null, \"warn\"),\n      error: applyStrategy.bind(null, \"error\")\n    });\n    return;\n  }\n  applyStrategy(strategy);\n}\n\n// src/utils/request/readResponseCookies.ts\nvar import_cookies2 = require(\"@mswjs/cookies\");\nfunction readResponseCookies(request, response2) {\n  import_cookies2.store.add(__spreadProps(__spreadValues({}, request), {\n    url: request.url.toString()\n  }), response2);\n  import_cookies2.store.persist();\n}\n\n// src/utils/handleRequest.ts\nasync function handleRequest(request, handlers, options, emitter, handleRequestOptions) {\n  var _a, _b, _c, _d, _e, _f;\n  emitter.emit(\"request:start\", request);\n  if (request.headers.get(\"x-msw-bypass\") === \"true\") {\n    emitter.emit(\"request:end\", request);\n    (_a = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _a.call(handleRequestOptions, request);\n    return;\n  }\n  const [lookupError, lookupResult] = await (0, import_until2.until)(() => {\n    return getResponse(request, handlers, handleRequestOptions == null ? void 0 : handleRequestOptions.resolutionContext);\n  });\n  if (lookupError) {\n    emitter.emit(\"unhandledException\", lookupError, request);\n    throw lookupError;\n  }\n  const {\n    handler,\n    response: response2\n  } = lookupResult;\n  if (!handler) {\n    onUnhandledRequest(request, handlers, options.onUnhandledRequest);\n    emitter.emit(\"request:unhandled\", request);\n    emitter.emit(\"request:end\", request);\n    (_b = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _b.call(handleRequestOptions, request);\n    return;\n  }\n  if (!response2) {\n    devUtils.warn(`Expected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\n\n  \\u2022 %s\n    %s`, response2, handler.info.header, handler.info.callFrame);\n    emitter.emit(\"request:end\", request);\n    (_c = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _c.call(handleRequestOptions, request);\n    return;\n  }\n  if (response2.passthrough) {\n    emitter.emit(\"request:end\", request);\n    (_d = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _d.call(handleRequestOptions, request);\n    return;\n  }\n  readResponseCookies(request, response2);\n  emitter.emit(\"request:match\", request);\n  const requiredLookupResult = lookupResult;\n  const transformedResponse = ((_e = handleRequestOptions == null ? void 0 : handleRequestOptions.transformResponse) == null ? void 0 : _e.call(handleRequestOptions, response2)) || response2;\n  (_f = handleRequestOptions == null ? void 0 : handleRequestOptions.onMockedResponse) == null ? void 0 : _f.call(handleRequestOptions, transformedResponse, requiredLookupResult);\n  emitter.emit(\"request:end\", request);\n  return transformedResponse;\n}\n\n// src/utils/logging/serializeResponse.ts\nvar import_headers_polyfill9 = require(\"headers-polyfill\");\nfunction serializeResponse(source) {\n  return {\n    status: source.status,\n    statusText: source.statusText,\n    headers: (0, import_headers_polyfill9.flattenHeadersObject)((0, import_headers_polyfill9.headersToObject)(source.headers)),\n    body: source.body\n  };\n}\n\n// src/setupWorker/start/createRequestListener.ts\nvar createRequestListener = (context, options) => {\n  return async (event, message) => {\n    var _a;\n    const messageChannel = new WorkerChannel(event.ports[0]);\n    const request = parseWorkerRequest(message.payload);\n    try {\n      await handleRequest(request, context.requestHandlers, options, context.emitter, {\n        transformResponse,\n        onPassthroughResponse() {\n          messageChannel.postMessage(\"NOT_FOUND\");\n        },\n        async onMockedResponse(response2, _ref8) {\n          let {\n            handler,\n            publicRequest,\n            parsedRequest\n          } = _ref8;\n          if (response2.body instanceof ReadableStream) {\n            throw new Error(devUtils.formatMessage('Failed to construct a mocked response with a \"ReadableStream\" body: mocked streams are not supported. Follow https://github.com/mswjs/msw/issues/1336 for more details.'));\n          }\n          const responseInstance = new Response(response2.body, response2);\n          const responseBodyBuffer = await responseInstance.arrayBuffer();\n          const responseBody = response2.body == null ? null : responseBodyBuffer;\n          messageChannel.postMessage(\"MOCK_RESPONSE\", __spreadProps(__spreadValues({}, response2), {\n            body: responseBody\n          }), [responseBodyBuffer]);\n          if (!options.quiet) {\n            context.emitter.once(\"response:mocked\", response3 => {\n              handler.log(publicRequest, serializeResponse(response3), parsedRequest);\n            });\n          }\n        }\n      });\n    } catch (error2) {\n      if (error2 instanceof NetworkError) {\n        messageChannel.postMessage(\"NETWORK_ERROR\", {\n          name: error2.name,\n          message: error2.message\n        });\n        return;\n      }\n      if (error2 instanceof Error) {\n        devUtils.error(`Uncaught exception in the request handler for \"%s %s\":\n\n%s\n\nThis exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/recipes/mocking-error-responses`, request.method, request.url, (_a = error2.stack) != null ? _a : error2);\n        messageChannel.postMessage(\"MOCK_RESPONSE\", {\n          status: 500,\n          statusText: \"Request Handler Error\",\n          headers: {\n            \"Content-Type\": \"application/json\"\n          },\n          body: JSON.stringify({\n            name: error2.name,\n            message: error2.message,\n            stack: error2.stack\n          })\n        });\n      }\n    }\n  };\n};\nfunction transformResponse(response2) {\n  return {\n    status: response2.status,\n    statusText: response2.statusText,\n    headers: response2.headers.all(),\n    body: response2.body,\n    delay: response2.delay\n  };\n}\n\n// src/utils/internal/requestIntegrityCheck.ts\nasync function requestIntegrityCheck(context, serviceWorker) {\n  context.workerChannel.send(\"INTEGRITY_CHECK_REQUEST\");\n  const {\n    payload: actualChecksum\n  } = await context.events.once(\"INTEGRITY_CHECK_RESPONSE\");\n  if (actualChecksum !== \"3d6b9f06410d179a7f7404d4bf4c3c70\") {\n    throw new Error(`Currently active Service Worker (${actualChecksum}) is behind the latest published one (${\"3d6b9f06410d179a7f7404d4bf4c3c70\"}).`);\n  }\n  return serviceWorker;\n}\n\n// src/utils/deferNetworkRequestsUntil.ts\nvar import_until3 = require(\"@open-draft/until\");\nfunction deferNetworkRequestsUntil(predicatePromise) {\n  const originalXhrSend = window.XMLHttpRequest.prototype.send;\n  window.XMLHttpRequest.prototype.send = function () {\n    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n    (0, import_until3.until)(() => predicatePromise).then(() => {\n      window.XMLHttpRequest.prototype.send = originalXhrSend;\n      this.send(...args);\n    });\n  };\n  const originalFetch = window.fetch;\n  window.fetch = async function () {\n    await (0, import_until3.until)(() => predicatePromise);\n    window.fetch = originalFetch;\n    return window.fetch(...arguments);\n  };\n}\n\n// src/setupWorker/start/createResponseListener.ts\nfunction createResponseListener(context) {\n  return (_, message) => {\n    var _a;\n    const {\n      payload: responseJson\n    } = message;\n    if ((_a = responseJson.type) == null ? void 0 : _a.includes(\"opaque\")) {\n      return;\n    }\n    const response2 = new Response(responseJson.body || null, responseJson);\n    const isMockedResponse = response2.headers.get(\"x-powered-by\") === \"msw\";\n    if (isMockedResponse) {\n      context.emitter.emit(\"response:mocked\", response2, responseJson.requestId);\n    } else {\n      context.emitter.emit(\"response:bypass\", response2, responseJson.requestId);\n    }\n  };\n}\n\n// src/setupWorker/start/utils/validateWorkerScope.ts\nfunction validateWorkerScope(registration, options) {\n  if (!(options == null ? void 0 : options.quiet) && !location.href.startsWith(registration.scope)) {\n    devUtils.warn(`Cannot intercept requests on this page because it's outside of the worker's scope (\"${registration.scope}\"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level (\"/\") of your application.\n- Set the \"Service-Worker-Allowed\" response header to allow out-of-scope workers.`);\n  }\n}\n\n// src/setupWorker/start/createStartHandler.ts\nvar createStartHandler = context => {\n  return function start(options, customOptions) {\n    const startWorkerInstance = async () => {\n      context.events.removeAllListeners();\n      context.workerChannel.on(\"REQUEST\", createRequestListener(context, options));\n      context.workerChannel.on(\"RESPONSE\", createResponseListener(context));\n      const instance = await getWorkerInstance(options.serviceWorker.url, options.serviceWorker.options, options.findWorker);\n      const [worker, registration] = instance;\n      if (!worker) {\n        const missingWorkerMessage = (customOptions == null ? void 0 : customOptions.findWorker) ? devUtils.formatMessage(`Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"%s\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`, options.serviceWorker.url) : devUtils.formatMessage(`Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"%s\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`, options.serviceWorker.url, location.host);\n        throw new Error(missingWorkerMessage);\n      }\n      context.worker = worker;\n      context.registration = registration;\n      context.events.addListener(window, \"beforeunload\", () => {\n        if (worker.state !== \"redundant\") {\n          context.workerChannel.send(\"CLIENT_CLOSED\");\n        }\n        window.clearInterval(context.keepAliveInterval);\n      });\n      const [integrityError] = await (0, import_until4.until)(() => requestIntegrityCheck(context, worker));\n      if (integrityError) {\n        devUtils.error(`Detected outdated Service Worker: ${integrityError.message}\n\nThe mocking is still enabled, but it's highly recommended that you update your Service Worker by running:\n\n$ npx msw init <PUBLIC_DIR>\n\nThis is necessary to ensure that the Service Worker is in sync with the library to guarantee its stability.\nIf this message still persists after updating, please report an issue: https://github.com/open-draft/msw/issues      `);\n      }\n      context.keepAliveInterval = window.setInterval(() => context.workerChannel.send(\"KEEPALIVE_REQUEST\"), 5e3);\n      validateWorkerScope(registration, context.startOptions);\n      return registration;\n    };\n    const workerRegistration = startWorkerInstance().then(async registration => {\n      const pendingInstance = registration.installing || registration.waiting;\n      if (pendingInstance) {\n        await new Promise(resolve => {\n          pendingInstance.addEventListener(\"statechange\", () => {\n            if (pendingInstance.state === \"activated\") {\n              return resolve();\n            }\n          });\n        });\n      }\n      await enableMocking(context, options).catch(error2 => {\n        throw new Error(`Failed to enable mocking: ${error2 == null ? void 0 : error2.message}`);\n      });\n      return registration;\n    });\n    if (options.waitUntilReady) {\n      deferNetworkRequestsUntil(workerRegistration);\n    }\n    return workerRegistration;\n  };\n};\n\n// src/setupWorker/stop/utils/printStopMessage.ts\nfunction printStopMessage() {\n  let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  if (args.quiet) {\n    return;\n  }\n  console.log(`%c${devUtils.formatMessage(\"Mocking disabled.\")}`, \"color:orangered;font-weight:bold;\");\n}\n\n// src/setupWorker/stop/createStop.ts\nvar createStop = context => {\n  return function stop() {\n    var _a;\n    if (!context.isMockingEnabled) {\n      devUtils.warn('Found a redundant \"worker.stop()\" call. Note that stopping the worker while mocking already stopped has no effect. Consider removing this \"worker.stop()\" call.');\n      return;\n    }\n    context.workerChannel.send(\"MOCK_DEACTIVATE\");\n    context.isMockingEnabled = false;\n    window.clearInterval(context.keepAliveInterval);\n    printStopMessage({\n      quiet: (_a = context.startOptions) == null ? void 0 : _a.quiet\n    });\n  };\n};\n\n// src/setupWorker/start/utils/prepareStartHandler.ts\nvar DEFAULT_START_OPTIONS = {\n  serviceWorker: {\n    url: \"/mockServiceWorker.js\",\n    options: null\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: \"warn\",\n  findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl;\n  }\n};\n\n// src/setupWorker/start/createFallbackRequestListener.ts\nvar import_interceptors4 = require(\"@mswjs/interceptors\");\nvar import_fetch3 = require(\"@mswjs/interceptors/lib/interceptors/fetch\");\nvar import_XMLHttpRequest = require(\"@mswjs/interceptors/lib/interceptors/XMLHttpRequest\");\n\n// src/utils/request/createResponseFromIsomorphicResponse.ts\nvar import_interceptors3 = require(\"@mswjs/interceptors\");\nvar noop = () => {\n  throw new Error(\"Not implemented\");\n};\nfunction createResponseFromIsomorphicResponse(response2) {\n  return __spreadProps(__spreadValues({}, response2), {\n    ok: response2.status >= 200 && response2.status < 300,\n    url: \"\",\n    type: \"default\",\n    status: response2.status,\n    statusText: response2.statusText,\n    headers: response2.headers,\n    body: new ReadableStream(),\n    redirected: response2.headers.get(\"Location\") != null,\n    async text() {\n      return response2.body || \"\";\n    },\n    async json() {\n      return JSON.parse(response2.body || \"\");\n    },\n    async arrayBuffer() {\n      return (0, import_interceptors3.encodeBuffer)(response2.body || \"\");\n    },\n    bodyUsed: false,\n    formData: noop,\n    blob: noop,\n    clone: noop\n  });\n}\n\n// src/setupWorker/start/createFallbackRequestListener.ts\nfunction createFallbackRequestListener(context, options) {\n  const interceptor = new import_interceptors4.BatchInterceptor({\n    name: \"fallback\",\n    interceptors: [new import_fetch3.FetchInterceptor(), new import_XMLHttpRequest.XMLHttpRequestInterceptor()]\n  });\n  interceptor.on(\"request\", async request => {\n    const mockedRequest = new MockedRequest(request.url, __spreadProps(__spreadValues({}, request), {\n      body: await request.arrayBuffer()\n    }));\n    const response2 = await handleRequest(mockedRequest, context.requestHandlers, options, context.emitter, {\n      transformResponse(response3) {\n        return {\n          status: response3.status,\n          statusText: response3.statusText,\n          headers: response3.headers.all(),\n          body: response3.body,\n          delay: response3.delay\n        };\n      },\n      onMockedResponse(_, _ref9) {\n        let {\n          handler,\n          publicRequest,\n          parsedRequest\n        } = _ref9;\n        if (!options.quiet) {\n          context.emitter.once(\"response:mocked\", response3 => {\n            handler.log(publicRequest, serializeResponse(response3), parsedRequest);\n          });\n        }\n      }\n    });\n    if (response2) {\n      request.respondWith(response2);\n    }\n  });\n  interceptor.on(\"response\", (request, response2) => {\n    if (!request.id) {\n      return;\n    }\n    const browserResponse = createResponseFromIsomorphicResponse(response2);\n    if (response2.headers.get(\"x-powered-by\") === \"msw\") {\n      context.emitter.emit(\"response:mocked\", browserResponse, request.id);\n    } else {\n      context.emitter.emit(\"response:bypass\", browserResponse, request.id);\n    }\n  });\n  interceptor.apply();\n  return interceptor;\n}\n\n// src/setupWorker/start/createFallbackStart.ts\nfunction createFallbackStart(context) {\n  return async function start(options) {\n    context.fallbackInterceptor = createFallbackRequestListener(context, options);\n    printStartMessage({\n      message: \"Mocking enabled (fallback mode).\",\n      quiet: options.quiet\n    });\n    return void 0;\n  };\n}\n\n// src/setupWorker/stop/createFallbackStop.ts\nfunction createFallbackStop(context) {\n  return function stop() {\n    var _a, _b;\n    (_a = context.fallbackInterceptor) == null ? void 0 : _a.dispose();\n    printStopMessage({\n      quiet: (_b = context.startOptions) == null ? void 0 : _b.quiet\n    });\n  };\n}\n\n// src/SetupApi.ts\nvar import_outvariant4 = require(\"outvariant\");\nvar import_strict_event_emitter = require(\"strict-event-emitter\");\n\n// src/utils/internal/pipeEvents.ts\nfunction pipeEvents(source, destination) {\n  const rawEmit = source.emit;\n  if (rawEmit._isPiped) {\n    return;\n  }\n  source.emit = function (event) {\n    for (var _len9 = arguments.length, data2 = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n      data2[_key9 - 1] = arguments[_key9];\n    }\n    destination.emit(event, ...data2);\n    return rawEmit.call(this, event, ...data2);\n  };\n  source.emit._isPiped = true;\n}\n\n// src/utils/internal/toReadonlyArray.ts\nfunction toReadonlyArray(source) {\n  const clone = [...source];\n  Object.freeze(clone);\n  return clone;\n}\n\n// src/SetupApi.ts\nvar SetupApi = class {\n  constructor() {\n    for (var _len10 = arguments.length, initialHandlers = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n      initialHandlers[_key10] = arguments[_key10];\n    }\n    this.validateHandlers(...initialHandlers);\n    this.initialHandlers = toReadonlyArray(initialHandlers);\n    this.currentHandlers = [...initialHandlers];\n    this.emitter = new import_strict_event_emitter.Emitter();\n    this.publicEmitter = new import_strict_event_emitter.Emitter();\n    pipeEvents(this.emitter, this.publicEmitter);\n    this.events = this.createLifeCycleEvents();\n  }\n  validateHandlers() {\n    for (var _len11 = arguments.length, handlers = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n      handlers[_key11] = arguments[_key11];\n    }\n    for (const handler of handlers) {\n      (0, import_outvariant4.invariant)(!Array.isArray(handler), devUtils.formatMessage('Failed to construct \"%s\" given an Array of request handlers. Make sure you spread the request handlers when calling the respective setup function.'), this.constructor.name);\n    }\n  }\n  dispose() {\n    this.emitter.removeAllListeners();\n    this.publicEmitter.removeAllListeners();\n  }\n  use() {\n    this.currentHandlers.unshift(...arguments);\n  }\n  restoreHandlers() {\n    this.currentHandlers.forEach(handler => {\n      handler.markAsSkipped(false);\n    });\n  }\n  resetHandlers() {\n    for (var _len12 = arguments.length, nextHandlers = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n      nextHandlers[_key12] = arguments[_key12];\n    }\n    this.currentHandlers = nextHandlers.length > 0 ? [...nextHandlers] : [...this.initialHandlers];\n  }\n  listHandlers() {\n    return toReadonlyArray(this.currentHandlers);\n  }\n  createLifeCycleEvents() {\n    var _this = this;\n    return {\n      on: function () {\n        return _this.publicEmitter.on(...arguments);\n      },\n      removeListener: function () {\n        return _this.publicEmitter.removeListener(...arguments);\n      },\n      removeAllListeners: function () {\n        return _this.publicEmitter.removeAllListeners(...arguments);\n      }\n    };\n  }\n};\n\n// src/setupWorker/setupWorker.ts\nvar SetupWorkerApi = class extends SetupApi {\n  constructor() {\n    super(...arguments);\n    this.startHandler = null;\n    this.stopHandler = null;\n    (0, import_outvariant5.invariant)(!(0, import_is_node_process3.isNodeProcess)(), devUtils.formatMessage(\"Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.\"));\n    this.listeners = [];\n    this.context = this.createWorkerContext();\n  }\n  createWorkerContext() {\n    const context = {\n      isMockingEnabled: false,\n      startOptions: null,\n      worker: null,\n      registration: null,\n      requestHandlers: this.currentHandlers,\n      emitter: this.emitter,\n      workerChannel: {\n        on: (eventType, callback) => {\n          this.context.events.addListener(navigator.serviceWorker, \"message\", event => {\n            if (event.source !== this.context.worker) {\n              return;\n            }\n            const message = event.data;\n            if (!message) {\n              return;\n            }\n            if (message.type === eventType) {\n              callback(event, message);\n            }\n          });\n        },\n        send: type => {\n          var _a;\n          (_a = this.context.worker) == null ? void 0 : _a.postMessage(type);\n        }\n      },\n      events: {\n        addListener: (target, eventType, callback) => {\n          target.addEventListener(eventType, callback);\n          this.listeners.push({\n            eventType,\n            target,\n            callback\n          });\n          return () => {\n            target.removeEventListener(eventType, callback);\n          };\n        },\n        removeAllListeners: () => {\n          for (const {\n            target,\n            eventType,\n            callback\n          } of this.listeners) {\n            target.removeEventListener(eventType, callback);\n          }\n          this.listeners = [];\n        },\n        once: eventType => {\n          const bindings = [];\n          return new Promise((resolve, reject) => {\n            const handleIncomingMessage = event => {\n              try {\n                const message = event.data;\n                if (message.type === eventType) {\n                  resolve(message);\n                }\n              } catch (error2) {\n                reject(error2);\n              }\n            };\n            bindings.push(this.context.events.addListener(navigator.serviceWorker, \"message\", handleIncomingMessage), this.context.events.addListener(navigator.serviceWorker, \"messageerror\", reject));\n          }).finally(() => {\n            bindings.forEach(unbind => unbind());\n          });\n        }\n      },\n      useFallbackMode: !(\"serviceWorker\" in navigator) || location.protocol === \"file:\"\n    };\n    Object.defineProperties(context, {\n      requestHandlers: {\n        get: () => this.currentHandlers\n      }\n    });\n    this.startHandler = context.useFallbackMode ? createFallbackStart(context) : createStartHandler(context);\n    this.stopHandler = context.useFallbackMode ? createFallbackStop(context) : createStop(context);\n    return context;\n  }\n  async start() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.context.startOptions = mergeRight(DEFAULT_START_OPTIONS, options);\n    return await this.startHandler(this.context.startOptions, options);\n  }\n  printHandlers() {\n    const handlers = this.listHandlers();\n    handlers.forEach(handler => {\n      const {\n        header,\n        callFrame\n      } = handler.info;\n      const pragma = handler.info.hasOwnProperty(\"operationType\") ? \"[graphql]\" : \"[rest]\";\n      console.groupCollapsed(`${pragma} ${header}`);\n      if (callFrame) {\n        console.log(`Declaration: ${callFrame}`);\n      }\n      console.log(\"Handler:\", handler);\n      console.groupEnd();\n    });\n  }\n  stop() {\n    super.dispose();\n    this.context.events.removeAllListeners();\n    this.context.emitter.removeAllListeners();\n    this.stopHandler();\n  }\n};\nfunction setupWorker() {\n  for (var _len13 = arguments.length, handlers = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n    handlers[_key13] = arguments[_key13];\n  }\n  return new SetupWorkerApi(...handlers);\n}\n\n// src/rest.ts\nfunction createRestHandler(method) {\n  return (path, resolver) => {\n    return new RestHandler(method, path, resolver);\n  };\n}\nvar rest = {\n  all: createRestHandler(/.+/),\n  head: createRestHandler(\"HEAD\" /* HEAD */),\n  get: createRestHandler(\"GET\" /* GET */),\n  post: createRestHandler(\"POST\" /* POST */),\n  put: createRestHandler(\"PUT\" /* PUT */),\n  delete: createRestHandler(\"DELETE\" /* DELETE */),\n  patch: createRestHandler(\"PATCH\" /* PATCH */),\n  options: createRestHandler(\"OPTIONS\" /* OPTIONS */)\n};\n\n// src/graphql.ts\nfunction createScopedGraphQLHandler(operationType, url) {\n  return (operationName, resolver) => {\n    return new GraphQLHandler(operationType, operationName, url, resolver);\n  };\n}\nfunction createGraphQLOperationHandler(url) {\n  return resolver => {\n    return new GraphQLHandler(\"all\", new RegExp(\".*\"), url, resolver);\n  };\n}\nvar standardGraphQLHandlers = {\n  operation: createGraphQLOperationHandler(\"*\"),\n  query: createScopedGraphQLHandler(\"query\", \"*\"),\n  mutation: createScopedGraphQLHandler(\"mutation\", \"*\")\n};\nfunction createGraphQLLink(url) {\n  return {\n    operation: createGraphQLOperationHandler(url),\n    query: createScopedGraphQLHandler(\"query\", url),\n    mutation: createScopedGraphQLHandler(\"mutation\", url)\n  };\n}\nvar graphql = __spreadProps(__spreadValues({}, standardGraphQLHandlers), {\n  link: createGraphQLLink\n});\n\n// src/index.ts\ncheckGlobals();\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  GraphQLHandler,\n  MockedRequest,\n  RESTMethods,\n  RequestHandler,\n  RestHandler,\n  SetupApi,\n  SetupWorkerApi,\n  cleanUrl,\n  compose,\n  context,\n  createResponseComposition,\n  defaultContext,\n  defaultResponse,\n  graphql,\n  graphqlContext,\n  handleRequest,\n  matchRequestUrl,\n  response,\n  rest,\n  restContext,\n  setupWorker\n});","map":{"version":3,"mappings":"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","names":["__export","GraphQLHandler","MockedRequest","RESTMethods","RequestHandler","RestHandler","SetupApi","SetupWorkerApi","cleanUrl","compose","context","createResponseComposition","defaultContext","defaultResponse","graphql","graphqlContext","handleRequest","matchRequestUrl","response","rest","restContext","setupWorker","module","body","cookie","data","delay","errors","extensions","fetch","json","set","status","text","xml","statusCode","statusText","res","codes_default","String","require","args","name","value","headers","append","forEach","value2","name2","__toESM","options","serializedCookie","cookieUtils","document","JSON","parse","error2","Array","isArray","left","right","Object","entries","reduce","result","key","rightValue","leftValue","concat","isObject","mergeRight","assign","body2","stringify","payload","prevBody","jsonParse","nextBody","SET_TIMEOUT_MAX_ALLOWED_INT","MIN_SERVER_RESPONSE_TIME","MAX_SERVER_RESPONSE_TIME","NODE_SERVER_RESPONSE_TIME","getRandomServerResponseTime","Math","floor","random","durationOrMode","delayTime","Error","errorsList","useFetch","input","init","Promise","then","default","nodeFetch","globalThis","augmentRequestInit","requestInit","import_headers_polyfill2","__spreadProps","all","createFetchRequestParameters","method","requestParameters","includes","derivedRequestInit","url","href","LIBRARY_PREFIX","message","positionals","interpolatedMessage","console","warn","formatMessage","error","devUtils","URL","getWorkerByRegistration","registration","absoluteWorkerUrl","findWorker","allStates","active","installing","waiting","existingStates","filter","Boolean","mockWorker","find","worker","scriptURL","workerUrl","location","getWorkerInstance","getAbsoluteWorkerUrl","mockRegistrations","navigator","serviceWorker","getRegistrations","registrations","controller","length","reload","existingRegistration","update","instance","register","isWorkerMissing","scopeUrl","scope","quiet","groupCollapsed","log","workerScope","groupEnd","workerChannel","send","events","once","isMockingEnabled","printStartMessage","constructor","port","postMessage","event","rest2","data2","transfer","type","cookieUtils2","request","credentials","origin","getAllCookies","headersString","contentType","get","disposition","directives","split","acc","chunk","trim","join","slice","filename","boundary","d","startsWith","map","s","replace","boundaryRegExp","RegExp","fields","endsWith","trimStart","parsedBody","field2","contentHeaders","contentBody","parseContentHeaders","File","contentType2","parsedValue","toLowerCase","hasMultipartContent","parseMultipartData","toString","hasJsonContent","actual","expected","import_interceptors","id","cache","destination","integrity","keepalive","mode","priority","redirect","referrer","referrerPolicy","cookies","getCookies","text2","parseBody","isStringEqual","passthrough","import_headers_polyfill4","requestCookiesString","ownCookies","cookieUtils3","import_cookies","hydrate","cookiesFromStore","from","cookiesFromDocument","getRequestCookies","forwardedCookies","__spreadValues","rawRequest","import_headers_polyfill5","getResponse","handlers","resolutionContext","relevantHandlers","handler","test","executionResult","previousResults","result2","run","shouldSkip","parsedResult","markAsSkipped","resolve","publicRequest","parsedRequest","getPublicUrlFromRequest","pathname","protocol","host","node","operationDef","definitions","def","kind","operationType","operation","operationName","query","ast","parseDocumentNode","variables","files","operations","pathArray","dotPath","lastPath","reversedPaths","reverse","paths","target","path","searchParams","_c","parsedOperations","parsedMap","extractMultipartVariables","getGraphQLInput","parseQuery","requestPublicUrl","status2","now","Date","getHours","getMinutes","getSeconds","padStart","responseHeaders","REDUNDANT_CHARACTERS_EXP","baseUrl","isAbsoluteUrl","baseURI","decodeURI","encodeURI","maybeAbsoluteUrl","getAbsoluteUrl","_","parameterName","wildcard","expression","normalizedPath","normalizePath","cleanPath","coercePath","cleanUrl2","decode","decodeURIComponent","params","matches","fns","reduceRight","leftFn","rightFn","defaultResponseTransformers","responseOverrides","defaultTransformers","initialResponse","import_headers_polyfill7","transformers","resolvedTransformers","resolvedResponse","networkError","NetworkError","SOURCE_FRAME","BUILD_FRAME","stack","frames","declarationFrame","frame","declarationPath","fn","Symbol","iterator","ctx","resolver","callFrame","getCallFrame","info","_request","_resolutionContext","predicate","getPublicRequest","_parsedResult","shouldIntercept","executeResolver","wrapResolver","mockedResponse","createExecutionResult","req","resolverGenerator","isIterable","done","next","nextResponse","resolverGeneratorResult","response2","RESTMethods2","header","checkRedundantQueryParameters","getSearchParams","queryParams","paramName","push","RestRequest","matchesMethod","publicUrl","loggedRequest","prepareRequest","loggedResponse","prepareResponse","statusColor","getStatusCodeColor","getTimestamp","field","fieldName","fieldValue","validateFieldName","onException","endpoint","resolvedOperationName","isDocumentNode","parsedNode","tryCatch","parseGraphQLRequest","GraphQLRequest","hasMatchingUrl","hasMatchingOperationType","hasMatchingOperationName","requestInfo","MAX_MATCH_SCORE","MAX_SUGGESTION_COUNT","TYPE_MATCH_DELTA","groups","Infinity","hasSameMethod","methodScoreDelta","score","parsedQuery","hasSameOperationType","operationTypeScoreDelta","getScore","suggestedHandlers","suggestions","sort","leftScore","rightScore","strategy","parsedGraphQLQuery","handlerGroups","groupHandlersByType","getSuggestedHandler","getGraphQLHandlerScore","getRestHandlerScore","getSuggestedHandlersMessage","requestHeader","handlerSuggestion","generateHandlerSuggestion","messageTemplate","strategy2","generateUnhandledRequestMessage","warning","applyStrategy","bind","import_cookies2","add","persist","emitter","handleRequestOptions","emit","onPassthroughResponse","lookupError","lookupResult","onUnhandledRequest","readResponseCookies","requiredLookupResult","transformedResponse","transformResponse","onMockedResponse","source","createRequestListener","messageChannel","WorkerChannel","ports","parseWorkerRequest","requestHandlers","ReadableStream","responseInstance","Response","responseBodyBuffer","arrayBuffer","responseBody","response3","serializeResponse","actualChecksum","predicatePromise","originalXhrSend","window","XMLHttpRequest","prototype","originalFetch","responseJson","isMockedResponse","requestId","createStartHandler","customOptions","startWorkerInstance","removeAllListeners","on","createResponseListener","missingWorkerMessage","addListener","state","clearInterval","keepAliveInterval","integrityError","requestIntegrityCheck","setInterval","validateWorkerScope","startOptions","workerRegistration","pendingInstance","addEventListener","enableMocking","catch","waitUntilReady","deferNetworkRequestsUntil","createStop","printStopMessage","DEFAULT_START_OPTIONS","mockServiceWorkerUrl","noop","ok","redirected","bodyUsed","formData","blob","clone","interceptor","import_interceptors4","interceptors","import_fetch3","import_XMLHttpRequest","mockedRequest","respondWith","browserResponse","createResponseFromIsomorphicResponse","apply","fallbackInterceptor","createFallbackRequestListener","dispose","rawEmit","_isPiped","call","freeze","initialHandlers","validateHandlers","toReadonlyArray","currentHandlers","import_strict_event_emitter","publicEmitter","pipeEvents","createLifeCycleEvents","use","unshift","restoreHandlers","resetHandlers","nextHandlers","listHandlers","removeListener","listeners","createWorkerContext","eventType","callback","removeEventListener","bindings","reject","handleIncomingMessage","finally","unbind","useFallbackMode","defineProperties","startHandler","createFallbackStart","stopHandler","createFallbackStop","start","printHandlers","pragma","hasOwnProperty","stop","createRestHandler","head","post","put","delete","patch","standardGraphQLHandlers","createGraphQLOperationHandler","createScopedGraphQLHandler","mutation","link","createGraphQLLink","checkGlobals"],"sources":["/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/index.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/context/index.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/context/status.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/context/set.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/context/cookie.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/context/body.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/internal/jsonParse.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/internal/isObject.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/internal/mergeRight.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/context/json.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/context/data.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/context/extensions.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/context/delay.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/context/errors.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/context/fetch.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/context/text.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/context/xml.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/internal/checkGlobals.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/internal/devUtils.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/setupWorker/setupWorker.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/setupWorker/start/createStartHandler.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/setupWorker/start/utils/getWorkerInstance.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/setupWorker/start/utils/getWorkerByRegistration.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/url/getAbsoluteWorkerUrl.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/setupWorker/start/utils/printStartMessage.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/setupWorker/start/utils/enableMocking.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/setupWorker/start/utils/createMessageChannel.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/NetworkError.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/request/parseWorkerRequest.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/request/MockedRequest.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/request/getRequestCookies.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/internal/parseMultipartData.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/request/parseBody.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/internal/isStringEqual.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/handleRequest.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/getResponse.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/request/onUnhandledRequest.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/internal/parseGraphQLRequest.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/request/getPublicUrlFromRequest.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/logging/getStatusCodeColor.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/logging/getTimestamp.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/logging/prepareRequest.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/logging/prepareResponse.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/matching/matchRequestUrl.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/url/cleanUrl.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/url/isAbsoluteUrl.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/url/getAbsoluteUrl.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/matching/normalizePath.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/handlers/RequestHandler.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/response.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/internal/compose.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/internal/getCallFrame.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/internal/isIterable.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/handlers/RestHandler.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/context/field.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/internal/tryCatch.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/handlers/GraphQLHandler.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/request/readResponseCookies.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/logging/serializeResponse.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/setupWorker/start/createRequestListener.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/internal/requestIntegrityCheck.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/deferNetworkRequestsUntil.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/setupWorker/start/createResponseListener.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/setupWorker/start/utils/validateWorkerScope.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/setupWorker/stop/utils/printStopMessage.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/setupWorker/stop/createStop.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/setupWorker/start/utils/prepareStartHandler.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/setupWorker/start/createFallbackRequestListener.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/request/createResponseFromIsomorphicResponse.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/setupWorker/start/createFallbackStart.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/setupWorker/stop/createFallbackStop.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/SetupApi.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/internal/pipeEvents.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/utils/internal/toReadonlyArray.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/rest.ts","/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/msw/src/graphql.ts"],"sourcesContent":["import * as context from './context'\nimport { checkGlobals } from './utils/internal/checkGlobals'\nexport { context }\n\nexport { setupWorker } from './setupWorker/setupWorker'\n\nexport { SetupApi } from './SetupApi'\n\nexport {\n  response,\n  defaultResponse,\n  createResponseComposition,\n} from './response'\n\n/* Request handlers */\nexport { RequestHandler, defaultContext } from './handlers/RequestHandler'\nexport { rest } from './rest'\nexport { RestHandler, RESTMethods, restContext } from './handlers/RestHandler'\nexport { graphql } from './graphql'\nexport { GraphQLHandler, graphqlContext } from './handlers/GraphQLHandler'\n\n/* Utils */\nexport { matchRequestUrl } from './utils/matching/matchRequestUrl'\nexport { compose } from './utils/internal/compose'\nexport * from './utils/handleRequest'\nexport { cleanUrl } from './utils/url/cleanUrl'\n\n/**\n * Type definitions.\n */\nexport type { SetupWorker, StartOptions } from './setupWorker/glossary'\nexport { SetupWorkerApi } from './setupWorker/setupWorker'\nexport type { SharedOptions } from './sharedOptions'\n\nexport * from './utils/request/MockedRequest'\nexport type {\n  ResponseResolver,\n  ResponseResolverReturnType,\n  AsyncResponseResolverReturnType,\n  DefaultBodyType,\n  DefaultRequestMultipartBody,\n} from './handlers/RequestHandler'\n\nexport type {\n  MockedResponse,\n  ResponseTransformer,\n  ResponseComposition,\n  ResponseCompositionOptions,\n  ResponseFunction,\n} from './response'\n\nexport type {\n  RestRequest,\n  RestContext,\n  RequestQuery,\n  ParsedRestRequest,\n} from './handlers/RestHandler'\n\nexport type {\n  GraphQLContext,\n  GraphQLVariables,\n  GraphQLRequest,\n  GraphQLRequestBody,\n  GraphQLJsonRequestBody,\n} from './handlers/GraphQLHandler'\n\nexport type { Path, PathParams, Match } from './utils/matching/matchRequestUrl'\nexport type { DelayMode } from './context/delay'\nexport { ParsedGraphQLRequest } from './utils/internal/parseGraphQLRequest'\n\n// Validate environmental globals before executing any code.\n// This ensures that the library gives user-friendly errors\n// when ran in the environments that require additional polyfills\n// from the end user.\ncheckGlobals()\n","export { status } from './status'\nexport { set } from './set'\nexport { cookie } from './cookie'\nexport { body } from './body'\nexport { data } from './data'\nexport { extensions } from './extensions'\nexport { delay } from './delay'\nexport { errors } from './errors'\nexport { fetch } from './fetch'\nexport { json } from './json'\nexport { text } from './text'\nexport { xml } from './xml'\n","import statuses from 'statuses/codes.json'\nimport { ResponseTransformer } from '../response'\n\n/**\n * Sets a response status code and text.\n * @example\n * res(ctx.status(301))\n * res(ctx.status(400, 'Custom status text'))\n * @see {@link https://mswjs.io/docs/api/context/status `ctx.status()`}\n */\nexport const status = (\n  statusCode: number,\n  statusText?: string,\n): ResponseTransformer => {\n  return (res) => {\n    res.status = statusCode\n    res.statusText =\n      statusText || statuses[String(statusCode) as keyof typeof statuses]\n\n    return res\n  }\n}\n","import { objectToHeaders } from 'headers-polyfill'\nimport { ResponseTransformer } from '../response'\n\nexport type HeadersObject<KeyType extends string = string> = Record<\n  KeyType,\n  string | string[]\n>\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\n */\nexport type ForbiddenHeaderNames =\n  | 'cookie'\n  | 'cookie2'\n  | 'set-cookie'\n  | 'set-cookie2'\n\nexport type ForbiddenHeaderError<HeaderName extends string> =\n  `SafeResponseHeader: the '${HeaderName}' header cannot be set on the response. Please use the 'ctx.cookie()' function instead.`\n\n/**\n * Sets one or multiple response headers.\n * @example\n * ctx.set('Content-Type', 'text/plain')\n * ctx.set({\n *   'Accept': 'application/javascript',\n *   'Content-Type': \"text/plain\"\n * })\n * @see {@link https://mswjs.io/docs/api/context/set `ctx.set()`}\n */\nexport function set<N extends string | HeadersObject>(\n  ...args: N extends string\n    ? Lowercase<N> extends ForbiddenHeaderNames\n      ? [ForbiddenHeaderError<N>]\n      : [N, string]\n    : N extends HeadersObject<infer CookieName>\n    ? Lowercase<CookieName> extends ForbiddenHeaderNames\n      ? [ForbiddenHeaderError<CookieName>]\n      : [N]\n    : [N]\n): ResponseTransformer {\n  return (res) => {\n    const [name, value] = args\n\n    if (typeof name === 'string') {\n      res.headers.append(name, value as string)\n    } else {\n      const headers = objectToHeaders(name)\n      headers.forEach((value, name) => {\n        res.headers.append(name, value)\n      })\n    }\n\n    return res\n  }\n}\n","import * as cookieUtils from 'cookie'\nimport { ResponseTransformer } from '../response'\n\n/**\n * Sets a given cookie on the mocked response.\n * @example res(ctx.cookie('name', 'value'))\n */\nexport const cookie = (\n  name: string,\n  value: string,\n  options?: cookieUtils.CookieSerializeOptions,\n): ResponseTransformer => {\n  return (res) => {\n    const serializedCookie = cookieUtils.serialize(name, value, options)\n    res.headers.append('Set-Cookie', serializedCookie)\n\n    if (typeof document !== 'undefined') {\n      document.cookie = serializedCookie\n    }\n\n    return res\n  }\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets a raw response body. Does not append any `Content-Type` headers.\n * @example\n * res(ctx.body('Successful response'))\n * res(ctx.body(JSON.stringify({ key: 'value' })))\n * @see {@link https://mswjs.io/docs/api/context/body `ctx.body()`}\n */\nexport const body = <\n  BodyType extends string | Blob | BufferSource | ReadableStream | FormData,\n>(\n  value: BodyType,\n): ResponseTransformer<BodyType> => {\n  return (res) => {\n    res.body = value\n    return res\n  }\n}\n","/**\n * Parses a given value into a JSON.\n * Does not throw an exception on an invalid JSON string.\n */\nexport function jsonParse<ValueType extends Record<string, any>>(\n  value: any,\n): ValueType | undefined {\n  try {\n    return JSON.parse(value)\n  } catch (error) {\n    return undefined\n  }\n}\n","/**\n * Determines if the given value is an object.\n */\nexport function isObject(value: any): boolean {\n  return value != null && typeof value === 'object' && !Array.isArray(value)\n}\n","import { isObject } from './isObject'\n\n/**\n * Deeply merges two given objects with the right one\n * having a priority during property assignment.\n */\nexport function mergeRight(\n  left: Record<string, any>,\n  right: Record<string, any>,\n) {\n  return Object.entries(right).reduce((result, [key, rightValue]) => {\n    const leftValue = result[key]\n\n    if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n      result[key] = leftValue.concat(rightValue)\n      return result\n    }\n\n    if (isObject(leftValue) && isObject(rightValue)) {\n      result[key] = mergeRight(leftValue, rightValue)\n      return result\n    }\n\n    result[key] = rightValue\n    return result\n  }, Object.assign({}, left))\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets the given value as the JSON body of the response.\n * Appends a `Content-Type: application/json` header on the\n * mocked response.\n * @example\n * res(ctx.json('Some string'))\n * res(ctx.json({ key: 'value' }))\n * res(ctx.json([1, '2', false, { ok: true }]))\n * @see {@link https://mswjs.io/docs/api/context/json `ctx.json()`}\n */\nexport const json = <BodyTypeJSON>(\n  body: BodyTypeJSON,\n): ResponseTransformer<BodyTypeJSON> => {\n  return (res) => {\n    res.headers.set('Content-Type', 'application/json')\n    res.body = JSON.stringify(body) as any\n\n    return res\n  }\n}\n","import { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\nimport { GraphQLPayloadContext } from '../typeUtils'\n\n/**\n * Sets a given payload as a GraphQL response body.\n * @example\n * res(ctx.data({ user: { firstName: 'John' }}))\n * @see {@link https://mswjs.io/docs/api/context/data `ctx.data()`}\n */\nexport const data: GraphQLPayloadContext<Record<string, unknown>> = (\n  payload,\n) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { data: payload })\n\n    return json(nextBody)(res)\n  }\n}\n","import { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\nimport { GraphQLPayloadContext } from '../typeUtils'\n\n/**\n * Sets the GraphQL extensions on a given response.\n * @example\n * res(ctx.extensions({ tracing: { version: 1 }}))\n * @see {@link https://mswjs.io/docs/api/context/extensions `ctx.extensions()`}\n */\nexport const extensions: GraphQLPayloadContext<Record<string, unknown>> = (\n  payload,\n) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { extensions: payload })\n    return json(nextBody)(res)\n  }\n}\n","import { isNodeProcess } from 'is-node-process'\nimport { ResponseTransformer } from '../response'\n\nexport const SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647\nexport const MIN_SERVER_RESPONSE_TIME = 100\nexport const MAX_SERVER_RESPONSE_TIME = 400\nexport const NODE_SERVER_RESPONSE_TIME = 5\n\nconst getRandomServerResponseTime = () => {\n  if (isNodeProcess()) {\n    return NODE_SERVER_RESPONSE_TIME\n  }\n\n  return Math.floor(\n    Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) +\n      MIN_SERVER_RESPONSE_TIME,\n  )\n}\n\nexport type DelayMode = 'real' | 'infinite'\n\n/**\n * Delays the response by the given duration (ms).\n * @example\n * res(ctx.delay(1200)) // delay response by 1200ms\n * res(ctx.delay()) // emulate realistic server response time\n * res(ctx.delay('infinite')) // delay response infinitely\n * @see {@link https://mswjs.io/docs/api/context/delay `ctx.delay()`}\n */\nexport const delay = (\n  durationOrMode?: DelayMode | number,\n): ResponseTransformer => {\n  return (res) => {\n    let delayTime: number\n\n    if (typeof durationOrMode === 'string') {\n      switch (durationOrMode) {\n        case 'infinite': {\n          // Using `Infinity` as a delay value executes the response timeout immediately.\n          // Instead, use the maximum allowed integer for `setTimeout`.\n          delayTime = SET_TIMEOUT_MAX_ALLOWED_INT\n          break\n        }\n        case 'real': {\n          delayTime = getRandomServerResponseTime()\n          break\n        }\n        default: {\n          throw new Error(\n            `Failed to delay a response: unknown delay mode \"${durationOrMode}\". Please make sure you provide one of the supported modes (\"real\", \"infinite\") or a number to \"ctx.delay\".`,\n          )\n        }\n      }\n    } else if (typeof durationOrMode === 'undefined') {\n      // Use random realistic server response time when no explicit delay duration was provided.\n      delayTime = getRandomServerResponseTime()\n    } else {\n      // Guard against passing values like `Infinity` or `Number.MAX_VALUE`\n      // as the response delay duration. They don't produce the result you may expect.\n      if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {\n        throw new Error(\n          `Failed to delay a response: provided delay duration (${durationOrMode}) exceeds the maximum allowed duration for \"setTimeout\" (${SET_TIMEOUT_MAX_ALLOWED_INT}). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the \"infinite\" delay mode to delay the response indefinitely.`,\n        )\n      }\n\n      delayTime = durationOrMode\n    }\n\n    res.delay = delayTime\n    return res\n  }\n}\n","import type { GraphQLError } from 'graphql'\nimport { ResponseTransformer } from '../response'\nimport { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\n\n/**\n * Sets a given list of GraphQL errors on the mocked response.\n * @example res(ctx.errors([{ message: 'Unauthorized' }]))\n * @see {@link https://mswjs.io/docs/api/context/errors}\n */\nexport const errors = <\n  ErrorsType extends readonly Partial<GraphQLError>[] | null | undefined,\n>(\n  errorsList: ErrorsType,\n): ResponseTransformer<string> => {\n  return (res) => {\n    if (errorsList == null) {\n      return res\n    }\n\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { errors: errorsList })\n\n    return json(nextBody)(res as any) as any\n  }\n}\n","import { isNodeProcess } from 'is-node-process'\nimport { Headers } from 'headers-polyfill'\nimport { MockedRequest } from '../utils/request/MockedRequest'\n\nconst useFetch: (input: RequestInfo, init?: RequestInit) => Promise<Response> =\n  isNodeProcess()\n    ? (input, init) =>\n        import('node-fetch').then(({ default: nodeFetch }) =>\n          (nodeFetch as unknown as typeof window.fetch)(input, init),\n        )\n    : globalThis.fetch\n\nexport const augmentRequestInit = (requestInit: RequestInit): RequestInit => {\n  const headers = new Headers(requestInit.headers)\n  headers.set('x-msw-bypass', 'true')\n\n  return {\n    ...requestInit,\n    headers: headers.all(),\n  }\n}\n\nconst createFetchRequestParameters = (input: MockedRequest): RequestInit => {\n  const { body, method } = input\n  const requestParameters: RequestInit = {\n    ...input,\n    body: undefined,\n  }\n\n  if (['GET', 'HEAD'].includes(method)) {\n    return requestParameters\n  }\n\n  if (\n    typeof body === 'object' ||\n    typeof body === 'number' ||\n    typeof body === 'boolean'\n  ) {\n    requestParameters.body = JSON.stringify(body)\n  } else {\n    requestParameters.body = body\n  }\n\n  return requestParameters\n}\n\n/**\n * Performs a bypassed request inside a request handler.\n * @example\n * const originalResponse = await ctx.fetch(req)\n * @see {@link https://mswjs.io/docs/api/context/fetch `ctx.fetch()`}\n */\nexport const fetch = (\n  input: string | MockedRequest,\n  requestInit: RequestInit = {},\n): Promise<Response> => {\n  if (typeof input === 'string') {\n    return useFetch(input, augmentRequestInit(requestInit))\n  }\n\n  const requestParameters = createFetchRequestParameters(input)\n  const derivedRequestInit = augmentRequestInit(requestParameters)\n\n  return useFetch(input.url.href, derivedRequestInit)\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets a textual response body. Appends a `Content-Type: text/plain`\n * header on the mocked response.\n * @example res(ctx.text('Successful response'))\n * @see {@link https://mswjs.io/docs/api/context/text `ctx.text()`}\n */\nexport const text = <BodyType extends string>(\n  body: BodyType,\n): ResponseTransformer<BodyType> => {\n  return (res) => {\n    res.headers.set('Content-Type', 'text/plain')\n    res.body = body\n    return res\n  }\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets an XML response body. Appends a `Content-Type: text/xml` header\n * on the mocked response.\n * @example\n * res(ctx.xml('<node key=\"value\">Content</node>'))\n * @see {@link https://mswjs.io/docs/api/context/xml `ctx.xml()`}\n */\nexport const xml = <BodyType extends string>(\n  body: BodyType,\n): ResponseTransformer<BodyType> => {\n  return (res) => {\n    res.headers.set('Content-Type', 'text/xml')\n    res.body = body\n    return res\n  }\n}\n","import { invariant } from 'outvariant'\nimport { devUtils } from './devUtils'\n\nexport function checkGlobals() {\n  /**\n   * MSW expects the \"URL\" constructor to be defined.\n   * It's not present in React Native so suggest a polyfill\n   * instead of failing silently.\n   * @see https://github.com/mswjs/msw/issues/1408\n   */\n  invariant(\n    typeof URL !== 'undefined',\n    devUtils.formatMessage(\n      `Global \"URL\" class is not defined. This likely means that you're running MSW in an environment that doesn't support all Node.js standard API (e.g. React Native). If that's the case, please use an appropriate polyfill for the \"URL\" class, like \"react-native-url-polyfill\".`,\n    ),\n  )\n}\n","import { format } from 'outvariant'\n\nconst LIBRARY_PREFIX = '[MSW]'\n\n/**\n * Formats a given message by appending the library's prefix string.\n */\nfunction formatMessage(message: string, ...positionals: any[]): string {\n  const interpolatedMessage = format(message, ...positionals)\n  return `${LIBRARY_PREFIX} ${interpolatedMessage}`\n}\n\n/**\n * Prints a library-specific warning.\n */\nfunction warn(message: string, ...positionals: any[]): void {\n  console.warn(formatMessage(message, ...positionals))\n}\n\n/**\n * Prints a library-specific error.\n */\nfunction error(message: string, ...positionals: any[]): void {\n  console.error(formatMessage(message, ...positionals))\n}\n\nexport const devUtils = {\n  formatMessage,\n  warn,\n  error,\n}\n","import { invariant } from 'outvariant'\nimport { isNodeProcess } from 'is-node-process'\nimport {\n  SetupWorkerInternalContext,\n  ServiceWorkerIncomingEventsMap,\n  WorkerLifecycleEventsMap,\n  StartReturnType,\n  StopHandler,\n  StartHandler,\n  StartOptions,\n} from './glossary'\nimport { createStartHandler } from './start/createStartHandler'\nimport { createStop } from './stop/createStop'\nimport { ServiceWorkerMessage } from './start/utils/createMessageChannel'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { DEFAULT_START_OPTIONS } from './start/utils/prepareStartHandler'\nimport { createFallbackStart } from './start/createFallbackStart'\nimport { createFallbackStop } from './stop/createFallbackStop'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { SetupApi } from '../SetupApi'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { SetupWorker } from './glossary'\n\ninterface Listener {\n  target: EventTarget\n  eventType: string\n  callback: EventListener\n}\n\nexport class SetupWorkerApi\n  extends SetupApi<WorkerLifecycleEventsMap>\n  implements SetupWorker\n{\n  private context: SetupWorkerInternalContext\n  private startHandler: StartHandler = null as any\n  private stopHandler: StopHandler = null as any\n  private listeners: Array<Listener>\n\n  constructor(...handlers: Array<RequestHandler>) {\n    super(...handlers)\n\n    invariant(\n      !isNodeProcess(),\n      devUtils.formatMessage(\n        'Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.',\n      ),\n    )\n\n    this.listeners = []\n    this.context = this.createWorkerContext()\n  }\n\n  private createWorkerContext(): SetupWorkerInternalContext {\n    const context = {\n      // Mocking is not considered enabled until the worker\n      // signals back the successful activation event.\n      isMockingEnabled: false,\n      startOptions: null as any,\n      worker: null,\n      registration: null,\n      requestHandlers: this.currentHandlers,\n      emitter: this.emitter,\n      workerChannel: {\n        on: <EventType extends keyof ServiceWorkerIncomingEventsMap>(\n          eventType: EventType,\n          callback: (\n            event: MessageEvent,\n            message: ServiceWorkerMessage<\n              EventType,\n              ServiceWorkerIncomingEventsMap[EventType]\n            >,\n          ) => void,\n        ) => {\n          this.context.events.addListener(\n            navigator.serviceWorker,\n            'message',\n            (event: MessageEvent) => {\n              // Avoid messages broadcasted from unrelated workers.\n              if (event.source !== this.context.worker) {\n                return\n              }\n\n              const message = event.data as ServiceWorkerMessage<\n                typeof eventType,\n                any\n              >\n\n              if (!message) {\n                return\n              }\n\n              if (message.type === eventType) {\n                callback(event, message)\n              }\n            },\n          )\n        },\n        send: (type: any) => {\n          this.context.worker?.postMessage(type)\n        },\n      },\n      events: {\n        addListener: (\n          target: EventTarget,\n          eventType: string,\n          callback: EventListener,\n        ) => {\n          target.addEventListener(eventType, callback)\n          this.listeners.push({ eventType, target, callback })\n\n          return () => {\n            target.removeEventListener(eventType, callback)\n          }\n        },\n        removeAllListeners: () => {\n          for (const { target, eventType, callback } of this.listeners) {\n            target.removeEventListener(eventType, callback)\n          }\n          this.listeners = []\n        },\n        once: <EventType extends keyof ServiceWorkerIncomingEventsMap>(\n          eventType: EventType,\n        ) => {\n          const bindings: Array<() => void> = []\n\n          return new Promise<\n            ServiceWorkerMessage<\n              typeof eventType,\n              ServiceWorkerIncomingEventsMap[typeof eventType]\n            >\n          >((resolve, reject) => {\n            const handleIncomingMessage = (event: MessageEvent) => {\n              try {\n                const message = event.data\n\n                if (message.type === eventType) {\n                  resolve(message)\n                }\n              } catch (error) {\n                reject(error)\n              }\n            }\n\n            bindings.push(\n              this.context.events.addListener(\n                navigator.serviceWorker,\n                'message',\n                handleIncomingMessage,\n              ),\n              this.context.events.addListener(\n                navigator.serviceWorker,\n                'messageerror',\n                reject,\n              ),\n            )\n          }).finally(() => {\n            bindings.forEach((unbind) => unbind())\n          })\n        },\n      },\n      useFallbackMode:\n        !('serviceWorker' in navigator) || location.protocol === 'file:',\n    }\n\n    /**\n     * @todo Not sure I like this but \"this.currentHandlers\"\n     * updates never bubble to \"this.context.requestHandlers\".\n     */\n    Object.defineProperties(context, {\n      requestHandlers: {\n        get: () => this.currentHandlers,\n      },\n    })\n\n    this.startHandler = context.useFallbackMode\n      ? createFallbackStart(context)\n      : createStartHandler(context)\n\n    this.stopHandler = context.useFallbackMode\n      ? createFallbackStop(context)\n      : createStop(context)\n\n    return context\n  }\n\n  public async start(options: StartOptions = {}): StartReturnType {\n    this.context.startOptions = mergeRight(\n      DEFAULT_START_OPTIONS,\n      options,\n    ) as SetupWorkerInternalContext['startOptions']\n\n    return await this.startHandler(this.context.startOptions, options)\n  }\n\n  public printHandlers(): void {\n    const handlers = this.listHandlers()\n\n    handlers.forEach((handler) => {\n      const { header, callFrame } = handler.info\n      const pragma = handler.info.hasOwnProperty('operationType')\n        ? '[graphql]'\n        : '[rest]'\n\n      console.groupCollapsed(`${pragma} ${header}`)\n\n      if (callFrame) {\n        console.log(`Declaration: ${callFrame}`)\n      }\n\n      console.log('Handler:', handler)\n      console.groupEnd()\n    })\n  }\n\n  public stop(): void {\n    super.dispose()\n    this.context.events.removeAllListeners()\n    this.context.emitter.removeAllListeners()\n    this.stopHandler()\n  }\n}\n\n/**\n * Sets up a requests interception in the browser with the given request handlers.\n * @param {RequestHandler[]} handlers List of request handlers.\n * @see {@link https://mswjs.io/docs/api/setup-worker `setupWorker`}\n */\nexport function setupWorker(\n  ...handlers: Array<RequestHandler>\n): SetupWorkerApi {\n  return new SetupWorkerApi(...handlers)\n}\n","import { until } from '@open-draft/until'\nimport { getWorkerInstance } from './utils/getWorkerInstance'\nimport { enableMocking } from './utils/enableMocking'\nimport { SetupWorkerInternalContext, StartHandler } from '../glossary'\nimport { createRequestListener } from './createRequestListener'\nimport { requestIntegrityCheck } from '../../utils/internal/requestIntegrityCheck'\nimport { deferNetworkRequestsUntil } from '../../utils/deferNetworkRequestsUntil'\nimport { createResponseListener } from './createResponseListener'\nimport { validateWorkerScope } from './utils/validateWorkerScope'\nimport { devUtils } from '../../utils/internal/devUtils'\n\nexport const createStartHandler = (\n  context: SetupWorkerInternalContext,\n): StartHandler => {\n  return function start(options, customOptions) {\n    const startWorkerInstance = async () => {\n      // Remove all previously existing event listeners.\n      // This way none of the listeners persists between Fast refresh\n      // of the application's code.\n      context.events.removeAllListeners()\n\n      // Handle requests signaled by the worker.\n      context.workerChannel.on(\n        'REQUEST',\n        createRequestListener(context, options),\n      )\n\n      // Handle responses signaled by the worker.\n      context.workerChannel.on('RESPONSE', createResponseListener(context))\n\n      const instance = await getWorkerInstance(\n        options.serviceWorker.url,\n        options.serviceWorker.options,\n        options.findWorker,\n      )\n\n      const [worker, registration] = instance\n\n      if (!worker) {\n        const missingWorkerMessage = customOptions?.findWorker\n          ? devUtils.formatMessage(\n              `Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"%s\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`,\n              options.serviceWorker.url,\n            )\n          : devUtils.formatMessage(\n              `Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"%s\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`,\n              options.serviceWorker.url,\n              location.host,\n            )\n\n        throw new Error(missingWorkerMessage)\n      }\n\n      context.worker = worker\n      context.registration = registration\n\n      context.events.addListener(window, 'beforeunload', () => {\n        if (worker.state !== 'redundant') {\n          // Notify the Service Worker that this client has closed.\n          // Internally, it's similar to disabling the mocking, only\n          // client close event has a handler that self-terminates\n          // the Service Worker when there are no open clients.\n          context.workerChannel.send('CLIENT_CLOSED')\n        }\n        // Make sure we're always clearing the interval - there are reports that not doing this can\n        // cause memory leaks in headless browser environments.\n        window.clearInterval(context.keepAliveInterval)\n      })\n\n      // Check if the active Service Worker is the latest published one\n      const [integrityError] = await until(() =>\n        requestIntegrityCheck(context, worker),\n      )\n\n      if (integrityError) {\n        devUtils.error(`\\\nDetected outdated Service Worker: ${integrityError.message}\n\nThe mocking is still enabled, but it's highly recommended that you update your Service Worker by running:\n\n$ npx msw init <PUBLIC_DIR>\n\nThis is necessary to ensure that the Service Worker is in sync with the library to guarantee its stability.\nIf this message still persists after updating, please report an issue: https://github.com/open-draft/msw/issues\\\n      `)\n      }\n\n      context.keepAliveInterval = window.setInterval(\n        () => context.workerChannel.send('KEEPALIVE_REQUEST'),\n        5000,\n      )\n\n      // Warn the user when loading the page that lies outside\n      // of the worker's scope.\n      validateWorkerScope(registration, context.startOptions)\n\n      return registration\n    }\n\n    const workerRegistration = startWorkerInstance().then(\n      async (registration) => {\n        const pendingInstance = registration.installing || registration.waiting\n\n        // Wait until the worker is activated.\n        // Assume the worker is already activated if there's no pending registration\n        // (i.e. when reloading the page after a successful activation).\n        if (pendingInstance) {\n          await new Promise<void>((resolve) => {\n            pendingInstance.addEventListener('statechange', () => {\n              if (pendingInstance.state === 'activated') {\n                return resolve()\n              }\n            })\n          })\n        }\n\n        // Print the activation message only after the worker has been activated.\n        await enableMocking(context, options).catch((error) => {\n          throw new Error(`Failed to enable mocking: ${error?.message}`)\n        })\n\n        return registration\n      },\n    )\n\n    // Defer any network requests until the Service Worker instance is ready.\n    // This prevents a race condition between the Service Worker registration\n    // and application's runtime requests (i.e. requests on mount).\n    if (options.waitUntilReady) {\n      deferNetworkRequestsUntil(workerRegistration)\n    }\n\n    return workerRegistration\n  }\n}\n","import { until } from '@open-draft/until'\nimport { getWorkerByRegistration } from './getWorkerByRegistration'\nimport { ServiceWorkerInstanceTuple, FindWorker } from '../../glossary'\nimport { getAbsoluteWorkerUrl } from '../../../utils/url/getAbsoluteWorkerUrl'\nimport { devUtils } from '../../../utils/internal/devUtils'\n\n/**\n * Returns an active Service Worker instance.\n * When not found, registers a new Service Worker.\n */\nexport const getWorkerInstance = async (\n  url: string,\n  options: RegistrationOptions = {},\n  findWorker: FindWorker,\n): Promise<ServiceWorkerInstanceTuple> => {\n  // Resolve the absolute Service Worker URL.\n  const absoluteWorkerUrl = getAbsoluteWorkerUrl(url)\n\n  const mockRegistrations = await navigator.serviceWorker\n    .getRegistrations()\n    .then((registrations) =>\n      registrations.filter((registration) =>\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n      ),\n    )\n  if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n    // Reload the page when it has associated workers, but no active controller.\n    // The absence of a controller can mean either:\n    // - page has no Service Worker associated with it\n    // - page has been hard-reloaded and its workers won't be used until the next reload.\n    // Since we've checked that there are registrations associated with this page,\n    // at this point we are sure it's hard reload that falls into this clause.\n    location.reload()\n  }\n\n  const [existingRegistration] = mockRegistrations\n\n  if (existingRegistration) {\n    // When the Service Worker is registered, update it and return the reference.\n    return existingRegistration.update().then(() => {\n      return [\n        getWorkerByRegistration(\n          existingRegistration,\n          absoluteWorkerUrl,\n          findWorker,\n        ),\n        existingRegistration,\n      ]\n    })\n  }\n\n  // When the Service Worker wasn't found, register it anew and return the reference.\n  const [error, instance] = await until<ServiceWorkerInstanceTuple>(\n    async () => {\n      const registration = await navigator.serviceWorker.register(url, options)\n      return [\n        // Compare existing worker registration by its worker URL,\n        // to prevent irrelevant workers to resolve here (such as Codesandbox worker).\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n        registration,\n      ]\n    },\n  )\n\n  // Handle Service Worker registration errors.\n  if (error) {\n    const isWorkerMissing = error.message.includes('(404)')\n\n    // Produce a custom error message when given a non-existing Service Worker url.\n    // Suggest developers to check their setup.\n    if (isWorkerMissing) {\n      const scopeUrl = new URL(options?.scope || '/', location.href)\n\n      throw new Error(\n        devUtils.formatMessage(`\\\nFailed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`),\n      )\n    }\n\n    // Fallback error message for any other registration errors.\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to register the Service Worker:\\n\\n%s',\n        error.message,\n      ),\n    )\n  }\n\n  return instance\n}\n","import { FindWorker } from '../../glossary'\n\n/**\n * Attempts to resolve a Service Worker instance from a given registration,\n * regardless of its state (active, installing, waiting).\n */\nexport const getWorkerByRegistration = (\n  registration: ServiceWorkerRegistration,\n  absoluteWorkerUrl: string,\n  findWorker: FindWorker,\n): ServiceWorker | null => {\n  const allStates = [\n    registration.active,\n    registration.installing,\n    registration.waiting,\n  ]\n  const existingStates = allStates.filter(Boolean) as ServiceWorker[]\n  const mockWorker = existingStates.find((worker) => {\n    return findWorker(worker.scriptURL, absoluteWorkerUrl)\n  })\n\n  return mockWorker || null\n}\n","/**\n * Returns an absolute Service Worker URL based on the given\n * relative URL (known during the registration).\n */\nexport function getAbsoluteWorkerUrl(workerUrl: string): string {\n  return new URL(workerUrl, location.href).href\n}\n","import { devUtils } from '../../../utils/internal/devUtils'\n\nexport interface PrintStartMessageArgs {\n  quiet?: boolean\n  message?: string\n  workerUrl?: string\n  workerScope?: string\n}\n\n/**\n * Prints a worker activation message in the browser's console.\n */\nexport function printStartMessage(args: PrintStartMessageArgs = {}) {\n  if (args.quiet) {\n    return\n  }\n\n  const message = args.message || 'Mocking enabled.'\n\n  console.groupCollapsed(\n    `%c${devUtils.formatMessage(message)}`,\n    'color:orangered;font-weight:bold;',\n  )\n  console.log(\n    '%cDocumentation: %chttps://mswjs.io/docs',\n    'font-weight:bold',\n    'font-weight:normal',\n  )\n  console.log('Found an issue? https://github.com/mswjs/msw/issues')\n\n  if (args.workerUrl) {\n    console.log('Worker script URL:', args.workerUrl)\n  }\n\n  if (args.workerScope) {\n    console.log('Worker scope:', args.workerScope)\n  }\n\n  console.groupEnd()\n}\n","import { devUtils } from '../../../utils/internal/devUtils'\nimport { StartOptions, SetupWorkerInternalContext } from '../../glossary'\nimport { printStartMessage } from './printStartMessage'\n\n/**\n * Signals the worker to enable the interception of requests.\n */\nexport async function enableMocking(\n  context: SetupWorkerInternalContext,\n  options: StartOptions,\n) {\n  context.workerChannel.send('MOCK_ACTIVATE')\n  await context.events.once('MOCKING_ENABLED')\n\n  // Warn the developer on multiple \"worker.start()\" calls.\n  // While this will not affect the worker in any way,\n  // it likely indicates an issue with the developer's code.\n  if (context.isMockingEnabled) {\n    devUtils.warn(\n      `Found a redundant \"worker.start()\" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this \"worker.start()\" call.`,\n    )\n    return\n  }\n\n  context.isMockingEnabled = true\n\n  printStartMessage({\n    quiet: options.quiet,\n    workerScope: context.registration?.scope,\n    workerUrl: context.worker?.scriptURL,\n  })\n}\n","import {\n  SerializedResponse,\n  ServiceWorkerIncomingEventsMap,\n} from '../../glossary'\n\nexport interface ServiceWorkerMessage<\n  EventType extends keyof ServiceWorkerIncomingEventsMap,\n  EventPayload,\n> {\n  type: EventType\n  payload: EventPayload\n}\n\ninterface WorkerChannelEventsMap {\n  MOCK_RESPONSE: [data: SerializedResponse<any>, body?: [ArrayBuffer]]\n  NOT_FOUND: []\n  NETWORK_ERROR: [data: { name: string; message: string }]\n}\n\nexport class WorkerChannel {\n  constructor(private readonly port: MessagePort) {}\n\n  public postMessage<Event extends keyof WorkerChannelEventsMap>(\n    event: Event,\n    ...rest: WorkerChannelEventsMap[Event]\n  ): void {\n    const [data, transfer] = rest\n    this.port.postMessage({ type: event, data }, { transfer })\n  }\n}\n","export class NetworkError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = 'NetworkError'\n  }\n}\n","import { encodeBuffer } from '@mswjs/interceptors'\nimport { Headers } from 'headers-polyfill'\nimport { ServiceWorkerIncomingRequest } from '../../setupWorker/glossary'\nimport { MockedRequest } from './MockedRequest'\n\n/**\n * Converts a given request received from the Service Worker\n * into a `MockedRequest` instance.\n */\nexport function parseWorkerRequest(\n  rawRequest: ServiceWorkerIncomingRequest,\n): MockedRequest {\n  const url = new URL(rawRequest.url)\n  const headers = new Headers(rawRequest.headers)\n\n  return new MockedRequest(url, {\n    ...rawRequest,\n    body: encodeBuffer(rawRequest.body || ''),\n    headers,\n  })\n}\n","import * as cookieUtils from 'cookie'\nimport { store } from '@mswjs/cookies'\nimport { IsomorphicRequest, RequestInit } from '@mswjs/interceptors'\nimport { decodeBuffer } from '@mswjs/interceptors/lib/utils/bufferUtils.js'\nimport { Headers } from 'headers-polyfill'\nimport { DefaultBodyType } from '../../handlers/RequestHandler'\nimport { MockedResponse } from '../../response'\nimport { getRequestCookies } from './getRequestCookies'\nimport { parseBody } from './parseBody'\nimport { isStringEqual } from '../internal/isStringEqual'\n\nexport type RequestCache =\n  | 'default'\n  | 'no-store'\n  | 'reload'\n  | 'no-cache'\n  | 'force-cache'\n  | 'only-if-cached'\n\nexport type RequestMode = 'navigate' | 'same-origin' | 'no-cors' | 'cors'\n\nexport type RequestRedirect = 'follow' | 'error' | 'manual'\n\nexport type RequestDestination =\n  | ''\n  | 'audio'\n  | 'audioworklet'\n  | 'document'\n  | 'embed'\n  | 'font'\n  | 'frame'\n  | 'iframe'\n  | 'image'\n  | 'manifest'\n  | 'object'\n  | 'paintworklet'\n  | 'report'\n  | 'script'\n  | 'sharedworker'\n  | 'style'\n  | 'track'\n  | 'video'\n  | 'xslt'\n  | 'worker'\n\nexport type RequestPriority = 'high' | 'low' | 'auto'\n\nexport type RequestReferrerPolicy =\n  | ''\n  | 'no-referrer'\n  | 'no-referrer-when-downgrade'\n  | 'origin'\n  | 'origin-when-cross-origin'\n  | 'same-origin'\n  | 'strict-origin'\n  | 'strict-origin-when-cross-origin'\n  | 'unsafe-url'\n\nexport interface MockedRequestInit extends RequestInit {\n  id?: string\n  cache?: RequestCache\n  redirect?: RequestRedirect\n  integrity?: string\n  keepalive?: boolean\n  mode?: RequestMode\n  priority?: RequestPriority\n  destination?: RequestDestination\n  referrer?: string\n  referrerPolicy?: RequestReferrerPolicy\n  cookies?: Record<string, string>\n}\n\nexport class MockedRequest<\n  RequestBody extends DefaultBodyType = DefaultBodyType,\n> extends IsomorphicRequest {\n  public readonly cache: RequestCache\n  public readonly cookies: Record<string, string>\n  public readonly destination: RequestDestination\n  public readonly integrity: string\n  public readonly keepalive: boolean\n  public readonly mode: RequestMode\n  public readonly priority: RequestPriority\n  public readonly redirect: RequestRedirect\n  public readonly referrer: string\n  public readonly referrerPolicy: RequestReferrerPolicy\n\n  constructor(url: URL, init: MockedRequestInit = {}) {\n    super(url, init)\n    if (init.id) {\n      this.id = init.id\n    }\n    this.cache = init.cache || 'default'\n    this.destination = init.destination || ''\n    this.integrity = init.integrity || ''\n    this.keepalive = init.keepalive || false\n    this.mode = init.mode || 'cors'\n    this.priority = init.priority || 'auto'\n    this.redirect = init.redirect || 'follow'\n    this.referrer = init.referrer || ''\n    this.referrerPolicy = init.referrerPolicy || 'no-referrer'\n    this.cookies = init.cookies || this.getCookies()\n  }\n\n  /**\n   * Get parsed request body. The type is inferred from the content type.\n   *\n   * @deprecated - Use `req.text()`, `req.json()` or `req.arrayBuffer()`\n   * to read the request body as a plain text, JSON, or ArrayBuffer.\n   */\n  public get body(): RequestBody {\n    const text = decodeBuffer(this['_body'])\n\n    /**\n     * @deprecated https://github.com/mswjs/msw/issues/1318\n     * @fixme Remove this assumption and let the users read\n     * request body explicitly using \".json()\"/\".text()\"/\".arrayBuffer()\".\n     */\n    // Parse the request's body based on the \"Content-Type\" header.\n    const body = parseBody(text, this.headers)\n\n    if (isStringEqual(this.method, 'GET') && body === '') {\n      return undefined as RequestBody\n    }\n\n    return body as RequestBody\n  }\n\n  /**\n   * Bypass the intercepted request.\n   * This will make a call to the actual endpoint requested.\n   */\n  public passthrough(): MockedResponse<null> {\n    return {\n      // Constructing a dummy \"101 Continue\" mocked response\n      // to keep the return type of the resolver consistent.\n      status: 101,\n      statusText: 'Continue',\n      headers: new Headers(),\n      body: null,\n      // Setting \"passthrough\" to true will signal the response pipeline\n      // to perform this intercepted request as-is.\n      passthrough: true,\n      once: false,\n    }\n  }\n\n  private getCookies(): Record<string, string> {\n    // Parse the cookies passed in the original request \"cookie\" header.\n    const requestCookiesString = this.headers.get('cookie')\n    const ownCookies = requestCookiesString\n      ? cookieUtils.parse(requestCookiesString)\n      : {}\n\n    store.hydrate()\n\n    const cookiesFromStore = Array.from(\n      store.get({ ...this, url: this.url.href })?.entries(),\n    ).reduce((cookies, [name, { value }]) => {\n      return Object.assign(cookies, { [name.trim()]: value })\n    }, {})\n\n    // Get existing document cookies that are applicable\n    // to this request based on its \"credentials\" policy.\n    const cookiesFromDocument = getRequestCookies(this)\n\n    const forwardedCookies = {\n      ...cookiesFromDocument,\n      ...cookiesFromStore,\n    }\n\n    for (const [name, value] of Object.entries(forwardedCookies)) {\n      this.headers.append('cookie', `${name}=${value}`)\n    }\n\n    return {\n      ...forwardedCookies,\n      ...ownCookies,\n    }\n  }\n}\n","import * as cookieUtils from 'cookie'\nimport { MockedRequest } from './MockedRequest'\n\nfunction getAllCookies() {\n  return cookieUtils.parse(document.cookie)\n}\n\n/**\n * Returns relevant document cookies based on the request `credentials` option.\n */\nexport function getRequestCookies(request: MockedRequest) {\n  /**\n   * @note No cookies persist on the document in Node.js: no document.\n   */\n  if (typeof document === 'undefined' || typeof location === 'undefined') {\n    return {}\n  }\n\n  switch (request.credentials) {\n    case 'same-origin': {\n      // Return document cookies only when requested a resource\n      // from the same origin as the current document.\n      return location.origin === request.url.origin ? getAllCookies() : {}\n    }\n\n    case 'include': {\n      // Return all document cookies.\n      return getAllCookies()\n    }\n\n    default: {\n      return {}\n    }\n  }\n}\n","import { stringToHeaders } from 'headers-polyfill'\nimport { DefaultRequestMultipartBody } from '../../handlers/RequestHandler'\n\ninterface ParsedContentHeaders {\n  name: string\n  filename?: string\n  contentType: string\n}\n\ninterface ContentDispositionDirective {\n  [key: string]: string | undefined\n  name: string\n  filename?: string\n  'form-data': string\n}\n\nfunction parseContentHeaders(headersString: string): ParsedContentHeaders {\n  const headers = stringToHeaders(headersString)\n  const contentType = headers.get('content-type') || 'text/plain'\n  const disposition = headers.get('content-disposition')\n\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.')\n  }\n\n  const directives = disposition.split(';').reduce((acc, chunk) => {\n    const [name, ...rest] = chunk.trim().split('=')\n    acc[name] = rest.join('=')\n    return acc\n  }, {} as ContentDispositionDirective)\n\n  const name = directives.name?.slice(1, -1)\n  const filename = directives.filename?.slice(1, -1)\n\n  return {\n    name,\n    filename,\n    contentType,\n  }\n}\n\n/**\n * Parses a given string as a multipart/form-data.\n * Does not throw an exception on an invalid multipart string.\n */\nexport function parseMultipartData<T extends DefaultRequestMultipartBody>(\n  data: string,\n  headers?: Headers,\n): T | undefined {\n  const contentType = headers?.get('content-type')\n\n  if (!contentType) {\n    return undefined\n  }\n\n  const [, ...directives] = contentType.split(/; */)\n  const boundary = directives\n    .filter((d) => d.startsWith('boundary='))\n    .map((s) => s.replace(/^boundary=/, ''))[0]\n\n  if (!boundary) {\n    return undefined\n  }\n\n  const boundaryRegExp = new RegExp(`--+${boundary}`)\n  const fields = data\n    .split(boundaryRegExp)\n    .filter((chunk) => chunk.startsWith('\\r\\n') && chunk.endsWith('\\r\\n'))\n    .map((chunk) => chunk.trimStart().replace(/\\r\\n$/, ''))\n\n  if (!fields.length) {\n    return undefined\n  }\n\n  const parsedBody: DefaultRequestMultipartBody = {}\n\n  try {\n    for (const field of fields) {\n      const [contentHeaders, ...rest] = field.split('\\r\\n\\r\\n')\n      const contentBody = rest.join('\\r\\n\\r\\n')\n      const { contentType, filename, name } =\n        parseContentHeaders(contentHeaders)\n\n      const value =\n        filename === undefined\n          ? contentBody\n          : new File([contentBody], filename, { type: contentType })\n\n      const parsedValue = parsedBody[name]\n\n      if (parsedValue === undefined) {\n        parsedBody[name] = value\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value]\n      } else {\n        parsedBody[name] = [parsedValue, value]\n      }\n    }\n\n    return parsedBody as T\n  } catch (error) {\n    return undefined\n  }\n}\n","import { jsonParse } from '../internal/jsonParse'\nimport { parseMultipartData } from '../internal/parseMultipartData'\nimport { MockedRequest } from './MockedRequest'\n\n/**\n * Parses a given request/response body based on the \"Content-Type\" header.\n */\nexport function parseBody(body?: MockedRequest['body'], headers?: Headers) {\n  // Return whatever falsey body value is given.\n  if (!body) {\n    return body\n  }\n\n  const contentType = headers?.get('content-type')?.toLowerCase() || ''\n\n  // If the body has a Multipart Content-Type\n  // parse it into an object.\n  const hasMultipartContent = contentType.startsWith('multipart/form-data')\n  if (hasMultipartContent && typeof body !== 'object') {\n    return parseMultipartData(body.toString(), headers) || body\n  }\n\n  // If the intercepted request's body has a JSON Content-Type\n  // parse it into an object.\n  const hasJsonContent = contentType.includes('json')\n\n  if (hasJsonContent && typeof body !== 'object') {\n    return jsonParse(body.toString()) || body\n  }\n\n  // Otherwise leave as-is.\n  return body\n}\n","/**\n * Performs a case-insensitive comparison of two given strings.\n */\nexport function isStringEqual(actual: string, expected: string): boolean {\n  return actual.toLowerCase() === expected.toLowerCase()\n}\n","import { until } from '@open-draft/until'\nimport { Emitter } from 'strict-event-emitter'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { ServerLifecycleEventsMap } from '../node/glossary'\nimport { MockedResponse } from '../response'\nimport { SharedOptions } from '../sharedOptions'\nimport { RequiredDeep } from '../typeUtils'\nimport { ResponseLookupResult, getResponse } from './getResponse'\nimport { devUtils } from './internal/devUtils'\nimport { MockedRequest } from './request/MockedRequest'\nimport { onUnhandledRequest } from './request/onUnhandledRequest'\nimport { readResponseCookies } from './request/readResponseCookies'\n\nexport interface HandleRequestOptions<ResponseType> {\n  /**\n   * Options for the response resolution process.\n   */\n  resolutionContext?: {\n    baseUrl?: string\n  }\n\n  /**\n   * Transforms a `MockedResponse` instance returned from a handler\n   * to a response instance supported by the lower tooling (i.e. interceptors).\n   */\n  transformResponse?(response: MockedResponse<string>): ResponseType\n\n  /**\n   * Invoked whenever a request is performed as-is.\n   */\n  onPassthroughResponse?(request: MockedRequest): void\n\n  /**\n   * Invoked when the mocked response is ready to be sent.\n   */\n  onMockedResponse?(\n    response: ResponseType,\n    handler: RequiredDeep<ResponseLookupResult>,\n  ): void\n}\n\nexport async function handleRequest<\n  ResponseType extends Record<string, any> = MockedResponse<string>,\n>(\n  request: MockedRequest,\n  handlers: RequestHandler[],\n  options: RequiredDeep<SharedOptions>,\n  emitter: Emitter<ServerLifecycleEventsMap>,\n  handleRequestOptions?: HandleRequestOptions<ResponseType>,\n): Promise<ResponseType | undefined> {\n  emitter.emit('request:start', request)\n\n  // Perform bypassed requests (i.e. issued via \"ctx.fetch\") as-is.\n  if (request.headers.get('x-msw-bypass') === 'true') {\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Resolve a mocked response from the list of request handlers.\n  const [lookupError, lookupResult] = await until(() => {\n    return getResponse(\n      request,\n      handlers,\n      handleRequestOptions?.resolutionContext,\n    )\n  })\n\n  if (lookupError) {\n    // Allow developers to react to unhandled exceptions in request handlers.\n    emitter.emit('unhandledException', lookupError, request)\n    throw lookupError\n  }\n\n  const { handler, response } = lookupResult\n\n  // When there's no handler for the request, consider it unhandled.\n  // Allow the developer to react to such cases.\n  if (!handler) {\n    onUnhandledRequest(request, handlers, options.onUnhandledRequest)\n    emitter.emit('request:unhandled', request)\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // When the handled request returned no mocked response, warn the developer,\n  // as it may be an oversight on their part. Perform the request as-is.\n  if (!response) {\n    devUtils.warn(\n      `\\\nExpected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\\\n\\n\n  \\u2022 %s\n    %s\\\n`,\n      response,\n      handler.info.header,\n      handler.info.callFrame,\n    )\n\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // When the developer explicitly returned \"req.passthrough()\" do not warn them.\n  // Perform the request as-is.\n  if (response.passthrough) {\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Store all the received response cookies in the virtual cookie store.\n  readResponseCookies(request, response)\n\n  emitter.emit('request:match', request)\n\n  const requiredLookupResult =\n    lookupResult as RequiredDeep<ResponseLookupResult>\n\n  const transformedResponse =\n    handleRequestOptions?.transformResponse?.(response) ||\n    (response as any as ResponseType)\n\n  handleRequestOptions?.onMockedResponse?.(\n    transformedResponse,\n    requiredLookupResult,\n  )\n\n  emitter.emit('request:end', request)\n\n  return transformedResponse\n}\n","import { MockedResponse } from '../response'\nimport {\n  RequestHandler,\n  RequestHandlerExecutionResult,\n} from '../handlers/RequestHandler'\nimport { MockedRequest } from './request/MockedRequest'\n\nexport interface ResponseLookupResult {\n  handler?: RequestHandler\n  publicRequest?: any\n  parsedRequest?: any\n  response?: MockedResponse\n}\n\nexport interface ResponseResolutionContext {\n  baseUrl?: string\n}\n\n/**\n * Returns a mocked response for a given request using following request handlers.\n */\nexport const getResponse = async <\n  Request extends MockedRequest,\n  Handler extends RequestHandler[],\n>(\n  request: Request,\n  handlers: Handler,\n  resolutionContext?: ResponseResolutionContext,\n): Promise<ResponseLookupResult> => {\n  const relevantHandlers = handlers.filter((handler) => {\n    return handler.test(request, resolutionContext)\n  })\n\n  if (relevantHandlers.length === 0) {\n    return {\n      handler: undefined,\n      response: undefined,\n    }\n  }\n\n  const result = await relevantHandlers.reduce<\n    Promise<RequestHandlerExecutionResult<any> | null>\n  >(async (executionResult, handler) => {\n    const previousResults = await executionResult\n\n    if (!!previousResults?.response) {\n      return executionResult\n    }\n\n    const result = await handler.run(request, resolutionContext)\n\n    if (result === null || result.handler.shouldSkip) {\n      return null\n    }\n\n    if (!result.response) {\n      return {\n        request: result.request,\n        handler: result.handler,\n        response: undefined,\n        parsedResult: result.parsedResult,\n      }\n    }\n\n    if (result.response.once) {\n      handler.markAsSkipped(true)\n    }\n\n    return result\n  }, Promise.resolve(null))\n\n  // Although reducing a list of relevant request handlers, it's possible\n  // that in the end there will be no handler associted with the request\n  // (i.e. if relevant handlers are fall-through).\n  if (!result) {\n    return {\n      handler: undefined,\n      response: undefined,\n    }\n  }\n\n  return {\n    handler: result.handler,\n    publicRequest: result.request,\n    parsedRequest: result.parsedResult,\n    response: result.response,\n  }\n}\n","import getStringMatchScore from 'js-levenshtein'\nimport {\n  ParsedGraphQLQuery,\n  parseGraphQLRequest,\n} from '../internal/parseGraphQLRequest'\nimport { getPublicUrlFromRequest } from './getPublicUrlFromRequest'\nimport { isStringEqual } from '../internal/isStringEqual'\nimport { RestHandler } from '../../handlers/RestHandler'\nimport { GraphQLHandler } from '../../handlers/GraphQLHandler'\nimport { RequestHandler } from '../../handlers/RequestHandler'\nimport { tryCatch } from '../internal/tryCatch'\nimport { devUtils } from '../internal/devUtils'\nimport { MockedRequest } from './MockedRequest'\n\nconst MAX_MATCH_SCORE = 3\nconst MAX_SUGGESTION_COUNT = 4\nconst TYPE_MATCH_DELTA = 0.5\n\nexport interface UnhandledRequestPrint {\n  warning(): void\n  error(): void\n}\n\nexport type UnhandledRequestCallback = (\n  request: MockedRequest,\n  print: UnhandledRequestPrint,\n) => void\n\nexport type UnhandledRequestStrategy =\n  | 'bypass'\n  | 'warn'\n  | 'error'\n  | UnhandledRequestCallback\n\ninterface RequestHandlerGroups {\n  rest: RestHandler[]\n  graphql: GraphQLHandler[]\n}\n\nfunction groupHandlersByType(handlers: RequestHandler[]): RequestHandlerGroups {\n  return handlers.reduce<RequestHandlerGroups>(\n    (groups, handler) => {\n      if (handler instanceof RestHandler) {\n        groups.rest.push(handler)\n      }\n\n      if (handler instanceof GraphQLHandler) {\n        groups.graphql.push(handler)\n      }\n\n      return groups\n    },\n    {\n      rest: [],\n      graphql: [],\n    },\n  )\n}\n\ntype RequestHandlerSuggestion = [number, RequestHandler]\n\ntype ScoreGetterFn<RequestHandlerType extends RequestHandler> = (\n  request: MockedRequest,\n  handler: RequestHandlerType,\n) => number\n\nfunction getRestHandlerScore(): ScoreGetterFn<RestHandler> {\n  return (request, handler) => {\n    const { path, method } = handler.info\n\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity\n    }\n\n    const hasSameMethod = isStringEqual(request.method, method)\n\n    // Always treat a handler with the same method as a more similar one.\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0\n    const requestPublicUrl = getPublicUrlFromRequest(request)\n    const score = getStringMatchScore(requestPublicUrl, path)\n\n    return score - methodScoreDelta\n  }\n}\n\nfunction getGraphQLHandlerScore(\n  parsedQuery: ParsedGraphQLQuery,\n): ScoreGetterFn<GraphQLHandler> {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === 'undefined') {\n      return Infinity\n    }\n\n    const { operationType, operationName } = handler.info\n\n    if (typeof operationName !== 'string') {\n      return Infinity\n    }\n\n    const hasSameOperationType = parsedQuery.operationType === operationType\n    // Always treat a handler with the same operation type as a more similar one.\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0\n    const score = getStringMatchScore(parsedQuery.operationName, operationName)\n\n    return score - operationTypeScoreDelta\n  }\n}\n\nfunction getSuggestedHandler(\n  request: MockedRequest,\n  handlers: RestHandler[] | GraphQLHandler[],\n  getScore: ScoreGetterFn<RestHandler> | ScoreGetterFn<GraphQLHandler>,\n): RequestHandler[] {\n  const suggestedHandlers = (handlers as RequestHandler[])\n    .reduce<RequestHandlerSuggestion[]>((suggestions, handler) => {\n      const score = getScore(request, handler as any)\n      return suggestions.concat([[score, handler]])\n    }, [])\n    .sort(([leftScore], [rightScore]) => leftScore - rightScore)\n    .filter(([score]) => score <= MAX_MATCH_SCORE)\n    .slice(0, MAX_SUGGESTION_COUNT)\n    .map(([, handler]) => handler)\n\n  return suggestedHandlers\n}\n\nfunction getSuggestedHandlersMessage(handlers: RequestHandler[]) {\n  if (handlers.length > 1) {\n    return `\\\nDid you mean to request one of the following resources instead?\n\n${handlers.map((handler) => `  • ${handler.info.header}`).join('\\n')}`\n  }\n\n  return `Did you mean to request \"${handlers[0].info.header}\" instead?`\n}\n\nexport function onUnhandledRequest(\n  request: MockedRequest,\n  handlers: RequestHandler[],\n  strategy: UnhandledRequestStrategy = 'warn',\n): void {\n  const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request))\n\n  function generateHandlerSuggestion(): string {\n    /**\n     * @note Ignore exceptions during GraphQL request parsing because at this point\n     * we cannot assume the unhandled request is a valid GraphQL request.\n     * If the GraphQL parsing fails, just don't treat it as a GraphQL request.\n     */\n    const handlerGroups = groupHandlersByType(handlers)\n    const relevantHandlers = parsedGraphQLQuery\n      ? handlerGroups.graphql\n      : handlerGroups.rest\n\n    const suggestedHandlers = getSuggestedHandler(\n      request,\n      relevantHandlers,\n      parsedGraphQLQuery\n        ? getGraphQLHandlerScore(parsedGraphQLQuery)\n        : getRestHandlerScore(),\n    )\n\n    return suggestedHandlers.length > 0\n      ? getSuggestedHandlersMessage(suggestedHandlers)\n      : ''\n  }\n\n  function generateUnhandledRequestMessage(): string {\n    const publicUrl = getPublicUrlFromRequest(request)\n    const requestHeader = parsedGraphQLQuery\n      ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})`\n      : `${request.method} ${publicUrl}`\n    const handlerSuggestion = generateHandlerSuggestion()\n\n    const messageTemplate = [\n      `captured a request without a matching request handler:`,\n      `  \\u2022 ${requestHeader}`,\n      handlerSuggestion,\n      `\\\nIf you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks\\\n`,\n    ].filter(Boolean)\n    return messageTemplate.join('\\n\\n')\n  }\n\n  function applyStrategy(strategy: UnhandledRequestStrategy) {\n    // Generate handler suggestions only when applying the strategy.\n    // This saves bandwidth for scenarios when developers opt-out\n    // from the default unhandled request handling strategy.\n    const message = generateUnhandledRequestMessage()\n\n    switch (strategy) {\n      case 'error': {\n        // Print a developer-friendly error.\n        devUtils.error('Error: %s', message)\n\n        // Throw an exception to halt request processing and not perform the original request.\n        throw new Error(\n          devUtils.formatMessage(\n            'Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.',\n          ),\n        )\n      }\n\n      case 'warn': {\n        devUtils.warn('Warning: %s', message)\n        break\n      }\n\n      case 'bypass':\n        break\n\n      default:\n        throw new Error(\n          devUtils.formatMessage(\n            'Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.',\n            strategy,\n          ),\n        )\n    }\n  }\n\n  if (typeof strategy === 'function') {\n    strategy(request, {\n      warning: applyStrategy.bind(null, 'warn'),\n      error: applyStrategy.bind(null, 'error'),\n    })\n    return\n  }\n\n  applyStrategy(strategy)\n}\n","import type {\n  DocumentNode,\n  OperationDefinitionNode,\n  OperationTypeNode,\n} from 'graphql'\nimport { parse } from 'graphql'\nimport { GraphQLVariables } from '../../handlers/GraphQLHandler'\nimport { getPublicUrlFromRequest } from '../request/getPublicUrlFromRequest'\nimport { MockedRequest } from '../request/MockedRequest'\nimport { devUtils } from './devUtils'\nimport { jsonParse } from './jsonParse'\n\ninterface GraphQLInput {\n  query: string | null\n  variables?: GraphQLVariables\n}\n\nexport interface ParsedGraphQLQuery {\n  operationType: OperationTypeNode\n  operationName?: string\n}\n\nexport type ParsedGraphQLRequest<\n  VariablesType extends GraphQLVariables = GraphQLVariables,\n> =\n  | (ParsedGraphQLQuery & {\n      variables?: VariablesType\n    })\n  | undefined\n\nexport function parseDocumentNode(node: DocumentNode): ParsedGraphQLQuery {\n  const operationDef = node.definitions.find((def) => {\n    return def.kind === 'OperationDefinition'\n  }) as OperationDefinitionNode\n\n  return {\n    operationType: operationDef?.operation,\n    operationName: operationDef?.name?.value,\n  }\n}\n\nfunction parseQuery(query: string): ParsedGraphQLQuery | Error {\n  try {\n    const ast = parse(query)\n    return parseDocumentNode(ast)\n  } catch (error) {\n    return error as Error\n  }\n}\n\nexport type GraphQLParsedOperationsMap = Record<string, string[]>\nexport type GraphQLMultipartRequestBody = {\n  operations: string\n  map?: string\n} & {\n  [fileName: string]: File\n}\n\nfunction extractMultipartVariables<VariablesType extends GraphQLVariables>(\n  variables: VariablesType,\n  map: GraphQLParsedOperationsMap,\n  files: Record<string, File>,\n) {\n  const operations = { variables }\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(`Given files do not have a key '${key}' .`)\n    }\n\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split('.').reverse()\n      const paths = reversedPaths.reverse()\n      let target: Record<string, any> = operations\n\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(`Property '${paths}' is not in operations.`)\n        }\n\n        target = target[path]\n      }\n\n      target[lastPath] = files[key]\n    }\n  }\n  return operations.variables\n}\n\nfunction getGraphQLInput(request: MockedRequest<any>): GraphQLInput | null {\n  switch (request.method) {\n    case 'GET': {\n      const query = request.url.searchParams.get('query')\n      const variables = request.url.searchParams.get('variables') || ''\n\n      return {\n        query,\n        variables: jsonParse(variables),\n      }\n    }\n\n    case 'POST': {\n      if (request.body?.query) {\n        const { query, variables } = request.body\n\n        return {\n          query,\n          variables,\n        }\n      }\n\n      // Handle multipart body operations.\n      if (request.body?.operations) {\n        const { operations, map, ...files } =\n          request.body as GraphQLMultipartRequestBody\n        const parsedOperations =\n          jsonParse<{ query?: string; variables?: GraphQLVariables }>(\n            operations,\n          ) || {}\n\n        if (!parsedOperations.query) {\n          return null\n        }\n\n        const parsedMap = jsonParse<GraphQLParsedOperationsMap>(map || '') || {}\n        const variables = parsedOperations.variables\n          ? extractMultipartVariables(\n              parsedOperations.variables,\n              parsedMap,\n              files,\n            )\n          : {}\n\n        return {\n          query: parsedOperations.query,\n          variables,\n        }\n      }\n    }\n\n    default:\n      return null\n  }\n}\n\n/**\n * Determines if a given request can be considered a GraphQL request.\n * Does not parse the query and does not guarantee its validity.\n */\nexport function parseGraphQLRequest(\n  request: MockedRequest<any>,\n): ParsedGraphQLRequest {\n  const input = getGraphQLInput(request)\n\n  if (!input || !input.query) {\n    return undefined\n  }\n\n  const { query, variables } = input\n  const parsedResult = parseQuery(query)\n\n  if (parsedResult instanceof Error) {\n    const requestPublicUrl = getPublicUrlFromRequest(request)\n\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to intercept a GraphQL request to \"%s %s\": cannot parse query. See the error message from the parser below.\\n\\n%s',\n        request.method,\n        requestPublicUrl,\n        parsedResult.message,\n      ),\n    )\n  }\n\n  return {\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables,\n  }\n}\n","import { MockedRequest } from './MockedRequest'\n\n/**\n * Returns a relative URL if the given request URL is relative to the current origin.\n * Otherwise returns an absolute URL.\n */\nexport const getPublicUrlFromRequest = (request: MockedRequest) => {\n  return request.referrer.startsWith(request.url.origin)\n    ? request.url.pathname\n    : new URL(\n        request.url.pathname,\n        `${request.url.protocol}//${request.url.host}`,\n      ).href\n}\n","export enum StatusCodeColor {\n  Success = '#69AB32',\n  Warning = '#F0BB4B',\n  Danger = '#E95F5D',\n}\n\n/**\n * Returns a HEX color for a given response status code number.\n */\nexport function getStatusCodeColor(status: number): StatusCodeColor {\n  if (status < 300) {\n    return StatusCodeColor.Success\n  }\n\n  if (status < 400) {\n    return StatusCodeColor.Warning\n  }\n\n  return StatusCodeColor.Danger\n}\n","/**\n * Returns a timestamp string in a \"HH:MM:SS\" format.\n */\nexport function getTimestamp(): string {\n  const now = new Date()\n\n  return [now.getHours(), now.getMinutes(), now.getSeconds()]\n    .map(String)\n    .map((chunk) => chunk.slice(0, 2))\n    .map((chunk) => chunk.padStart(2, '0'))\n    .join(':')\n}\n","import type { DefaultBodyType } from '../../handlers/RequestHandler.js'\nimport type { MockedRequest } from '../request/MockedRequest.js'\n\nexport interface LoggedRequest {\n  id: string\n  url: URL\n  method: string\n  headers: Record<string, string>\n  cookies: Record<string, string>\n  body: DefaultBodyType\n}\n\n/**\n * Formats a mocked request for introspection in browser's console.\n */\nexport function prepareRequest(request: MockedRequest): LoggedRequest {\n  return {\n    ...request,\n    body: request.body,\n    headers: request.headers.all(),\n  }\n}\n","import { objectToHeaders } from 'headers-polyfill'\nimport { SerializedResponse } from '../../setupWorker/glossary'\nimport { parseBody } from '../request/parseBody'\n\n/**\n * Formats a mocked response for introspection in the browser's console.\n */\nexport function prepareResponse(res: SerializedResponse<any>) {\n  const responseHeaders = objectToHeaders(res.headers)\n\n  return {\n    ...res,\n    // Parse a response JSON body for preview in the logs\n    body: parseBody(res.body, responseHeaders),\n  }\n}\n","import { match } from 'path-to-regexp'\nimport { getCleanUrl } from '@mswjs/interceptors/lib/utils/getCleanUrl.js'\nimport { normalizePath } from './normalizePath'\n\nexport type Path = string | RegExp\nexport type PathParams<KeyType extends keyof any = string> = {\n  [ParamName in KeyType]: string | ReadonlyArray<string>\n}\n\nexport interface Match {\n  matches: boolean\n  params?: PathParams\n}\n\n/**\n * Coerce a path supported by MSW into a path\n * supported by \"path-to-regexp\".\n */\nexport function coercePath(path: string): string {\n  return (\n    path\n      /**\n       * Replace wildcards (\"*\") with unnamed capturing groups\n       * because \"path-to-regexp\" doesn't support wildcards.\n       * Ignore path parameter' modifiers (i.e. \":name*\").\n       */\n      .replace(\n        /([:a-zA-Z_-]*)(\\*{1,2})+/g,\n        (_, parameterName: string | undefined, wildcard: string) => {\n          const expression = '(.*)'\n\n          if (!parameterName) {\n            return expression\n          }\n\n          return parameterName.startsWith(':')\n            ? `${parameterName}${wildcard}`\n            : `${parameterName}${expression}`\n        },\n      )\n      /**\n       * Escape the port so that \"path-to-regexp\" can match\n       * absolute URLs including port numbers.\n       */\n      .replace(/([^\\/])(:)(?=\\d+)/, '$1\\\\$2')\n      /**\n       * Escape the protocol so that \"path-to-regexp\" could match\n       * absolute URL.\n       * @see https://github.com/pillarjs/path-to-regexp/issues/259\n       */\n      .replace(/^([^\\/]+)(:)(?=\\/\\/)/, '$1\\\\$2')\n  )\n}\n\n/**\n * Returns the result of matching given request URL against a mask.\n */\nexport function matchRequestUrl(url: URL, path: Path, baseUrl?: string): Match {\n  const normalizedPath = normalizePath(path, baseUrl)\n  const cleanPath =\n    typeof normalizedPath === 'string'\n      ? coercePath(normalizedPath)\n      : normalizedPath\n\n  const cleanUrl = getCleanUrl(url)\n  const result = match(cleanPath, { decode: decodeURIComponent })(cleanUrl)\n  const params = (result && (result.params as PathParams)) || {}\n\n  return {\n    matches: result !== false,\n    params,\n  }\n}\n","const REDUNDANT_CHARACTERS_EXP = /[\\?|#].*$/g\n\nexport function getSearchParams(path: string) {\n  return new URL(`/${path}`, 'http://localhost').searchParams\n}\n\n/**\n * Removes query parameters and hashes from a given URL string.\n */\nexport function cleanUrl(path: string): string {\n  return path.replace(REDUNDANT_CHARACTERS_EXP, '')\n}\n","/**\n * Determines if the given URL string is an absolute URL.\n */\nexport function isAbsoluteUrl(url: string): boolean {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url)\n}\n","import { isAbsoluteUrl } from './isAbsoluteUrl'\n\n/**\n * Returns an absolute URL based on the given path.\n */\nexport function getAbsoluteUrl(path: string, baseUrl?: string): string {\n  // already absolute URL\n  if (isAbsoluteUrl(path)) {\n    return path\n  }\n\n  // Ignore path with pattern start with *\n  if (path.startsWith('*')) {\n    return path\n  }\n\n  // Resolve a relative request URL against a given custom \"baseUrl\"\n  // or the document baseURI (in the case of browser/browser-like environments).\n  const origin =\n    baseUrl || (typeof document !== 'undefined' && document.baseURI)\n\n  return origin\n    ? // Encode and decode the path to preserve escaped characters.\n      decodeURI(new URL(encodeURI(path), origin).href)\n    : path\n}\n","import type { Path } from './matchRequestUrl'\nimport { cleanUrl } from '../url/cleanUrl'\nimport { getAbsoluteUrl } from '../url/getAbsoluteUrl'\n\n/**\n * Normalizes a given request handler path:\n * - Preserves RegExp.\n * - Removes query parameters and hashes.\n * - Rebases relative URLs against the \"baseUrl\" or the current location.\n * - Preserves relative URLs in Node.js, unless specified otherwise.\n */\nexport function normalizePath(path: Path, baseUrl?: string): Path {\n  // RegExp paths do not need normalization.\n  if (path instanceof RegExp) {\n    return path\n  }\n\n  const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl)\n\n  return cleanUrl(maybeAbsoluteUrl)\n}\n","import { Headers } from 'headers-polyfill'\nimport {\n  MaybePromise,\n  MockedResponse,\n  response,\n  ResponseComposition,\n} from '../response'\nimport { getCallFrame } from '../utils/internal/getCallFrame'\nimport { isIterable } from '../utils/internal/isIterable'\nimport { status } from '../context/status'\nimport { set } from '../context/set'\nimport { delay } from '../context/delay'\nimport { fetch } from '../context/fetch'\nimport { ResponseResolutionContext } from '../utils/getResponse'\nimport { SerializedResponse } from '../setupWorker/glossary'\nimport { MockedRequest } from '../utils/request/MockedRequest'\n\nexport type DefaultContext = {\n  status: typeof status\n  set: typeof set\n  delay: typeof delay\n  fetch: typeof fetch\n}\n\nexport const defaultContext: DefaultContext = {\n  status,\n  set,\n  delay,\n  fetch,\n}\n\nexport type DefaultRequestMultipartBody = Record<\n  string,\n  string | File | (string | File)[]\n>\n\nexport type DefaultBodyType =\n  | Record<string, any>\n  | DefaultRequestMultipartBody\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n\nexport interface RequestHandlerDefaultInfo {\n  header: string\n}\n\nexport interface RequestHandlerInternalInfo {\n  callFrame?: string\n}\n\ntype ContextMap = Record<string, (...args: any[]) => any>\n\nexport type ResponseResolverReturnType<ReturnType> =\n  | ReturnType\n  | undefined\n  | void\n\nexport type MaybeAsyncResponseResolverReturnType<ReturnType> = MaybePromise<\n  ResponseResolverReturnType<ReturnType>\n>\n\nexport type AsyncResponseResolverReturnType<ReturnType> =\n  | MaybeAsyncResponseResolverReturnType<ReturnType>\n  | Generator<\n      MaybeAsyncResponseResolverReturnType<ReturnType>,\n      MaybeAsyncResponseResolverReturnType<ReturnType>,\n      MaybeAsyncResponseResolverReturnType<ReturnType>\n    >\n\nexport type ResponseResolver<\n  RequestType = MockedRequest,\n  ContextType = typeof defaultContext,\n  BodyType extends DefaultBodyType = any,\n> = (\n  req: RequestType,\n  res: ResponseComposition<BodyType>,\n  context: ContextType,\n) => AsyncResponseResolverReturnType<MockedResponse<BodyType>>\n\nexport interface RequestHandlerOptions<HandlerInfo> {\n  info: HandlerInfo\n  resolver: ResponseResolver<any, any>\n  ctx?: ContextMap\n}\n\nexport interface RequestHandlerExecutionResult<PublicRequestType> {\n  handler: RequestHandler\n  parsedResult: any\n  request: PublicRequestType\n  response?: MockedResponse\n}\n\nexport abstract class RequestHandler<\n  HandlerInfo extends RequestHandlerDefaultInfo = RequestHandlerDefaultInfo,\n  Request extends MockedRequest = MockedRequest,\n  ParsedResult = any,\n  PublicRequest extends MockedRequest = Request,\n> {\n  public info: HandlerInfo & RequestHandlerInternalInfo\n  public shouldSkip: boolean\n\n  private ctx: ContextMap\n  private resolverGenerator?: Generator<\n    MaybeAsyncResponseResolverReturnType<any>,\n    MaybeAsyncResponseResolverReturnType<any>,\n    MaybeAsyncResponseResolverReturnType<any>\n  >\n  private resolverGeneratorResult?: MaybeAsyncResponseResolverReturnType<any>\n\n  protected resolver: ResponseResolver<any, any>\n\n  constructor(options: RequestHandlerOptions<HandlerInfo>) {\n    this.shouldSkip = false\n    this.ctx = options.ctx || defaultContext\n    this.resolver = options.resolver\n\n    const callFrame = getCallFrame(new Error())\n\n    this.info = {\n      ...options.info,\n      callFrame,\n    }\n  }\n\n  /**\n   * Determine if the captured request should be mocked.\n   */\n  abstract predicate(\n    request: MockedRequest,\n    parsedResult: ParsedResult,\n    resolutionContext?: ResponseResolutionContext,\n  ): boolean\n\n  /**\n   * Print out the successfully handled request.\n   */\n  abstract log(\n    request: Request,\n    response: SerializedResponse<any>,\n    parsedResult: ParsedResult,\n  ): void\n\n  /**\n   * Parse the captured request to extract additional information from it.\n   * Parsed result is then exposed to other methods of this request handler.\n   */\n  parse(\n    _request: MockedRequest,\n    _resolutionContext?: ResponseResolutionContext,\n  ): ParsedResult {\n    return null as any\n  }\n\n  /**\n   * Test if this handler matches the given request.\n   */\n  public test(\n    request: MockedRequest,\n    resolutionContext?: ResponseResolutionContext,\n  ): boolean {\n    return this.predicate(\n      request,\n      this.parse(request, resolutionContext),\n      resolutionContext,\n    )\n  }\n\n  /**\n   * Derive the publicly exposed request (`req`) instance of the response resolver\n   * from the captured request and its parsed result.\n   */\n  protected getPublicRequest(\n    request: MockedRequest,\n    _parsedResult: ParsedResult,\n  ) {\n    return request as PublicRequest\n  }\n\n  public markAsSkipped(shouldSkip = true) {\n    this.shouldSkip = shouldSkip\n  }\n\n  /**\n   * Execute this request handler and produce a mocked response\n   * using the given resolver function.\n   */\n  public async run(\n    request: MockedRequest,\n    resolutionContext?: ResponseResolutionContext,\n  ): Promise<RequestHandlerExecutionResult<PublicRequest> | null> {\n    if (this.shouldSkip) {\n      return null\n    }\n\n    const parsedResult = this.parse(request, resolutionContext)\n    const shouldIntercept = this.predicate(\n      request,\n      parsedResult,\n      resolutionContext,\n    )\n\n    if (!shouldIntercept) {\n      return null\n    }\n\n    const publicRequest = this.getPublicRequest(request, parsedResult)\n\n    // Create a response extraction wrapper around the resolver\n    // since it can be both an async function and a generator.\n    const executeResolver = this.wrapResolver(this.resolver)\n    const mockedResponse = await executeResolver(\n      publicRequest,\n      response,\n      this.ctx,\n    )\n\n    return this.createExecutionResult(\n      parsedResult,\n      publicRequest,\n      mockedResponse,\n    )\n  }\n\n  private wrapResolver(\n    resolver: ResponseResolver<any, any>,\n  ): ResponseResolver<AsyncResponseResolverReturnType<any>, any> {\n    return async (req, res, ctx) => {\n      const result = this.resolverGenerator || (await resolver(req, res, ctx))\n\n      if (isIterable<AsyncResponseResolverReturnType<any>>(result)) {\n        const { value, done } = result[Symbol.iterator]().next()\n        const nextResponse = await value\n\n        // If the generator is done and there is no next value,\n        // return the previous generator's value.\n        if (!nextResponse && done) {\n          return this.resolverGeneratorResult\n        }\n\n        if (!this.resolverGenerator) {\n          this.resolverGenerator = result\n        }\n\n        this.resolverGeneratorResult = nextResponse\n        return nextResponse\n      }\n\n      return result\n    }\n  }\n\n  private createExecutionResult(\n    parsedResult: ParsedResult,\n    request: PublicRequest,\n    response: any,\n  ): RequestHandlerExecutionResult<PublicRequest> {\n    return {\n      handler: this,\n      parsedResult: parsedResult || null,\n      request,\n      response: response || null,\n    }\n  }\n}\n\n/**\n * Bypass this intercepted request.\n * This will make a call to the actual endpoint requested.\n */\nexport function passthrough(): MockedResponse<null> {\n  // Constructing a dummy \"101 Continue\" mocked response\n  // to keep the return type of the resolver consistent.\n  return {\n    status: 101,\n    statusText: 'Continue',\n    headers: new Headers(),\n    body: null,\n    // Setting \"passthrough\" to true will signal the response pipeline\n    // to perform this intercepted request as-is.\n    passthrough: true,\n    once: false,\n  }\n}\n","import { Headers } from 'headers-polyfill'\nimport { DefaultBodyType } from './handlers/RequestHandler'\nimport { compose } from './utils/internal/compose'\nimport { NetworkError } from './utils/NetworkError'\n\nexport type MaybePromise<ValueType = any> = ValueType | Promise<ValueType>\n\n/**\n * Internal representation of a mocked response instance.\n */\nexport interface MockedResponse<BodyType extends DefaultBodyType = any> {\n  body: BodyType\n  status: number\n  statusText: string\n  headers: Headers\n  once: boolean\n  passthrough: boolean\n  delay?: number\n}\n\nexport type ResponseTransformer<\n  BodyType extends TransformerBodyType = any,\n  TransformerBodyType extends DefaultBodyType = any,\n> = (\n  res: MockedResponse<TransformerBodyType>,\n) => MaybePromise<MockedResponse<BodyType>>\n\nexport type ResponseFunction<BodyType extends DefaultBodyType = any> = (\n  ...transformers: ResponseTransformer<BodyType>[]\n) => MaybePromise<MockedResponse<BodyType>>\n\nexport type ResponseComposition<BodyType extends DefaultBodyType = any> =\n  ResponseFunction<BodyType> & {\n    /**\n     * Respond using a given mocked response to the first captured request.\n     * Does not affect any subsequent captured requests.\n     */\n    once: ResponseFunction<BodyType>\n    networkError: (message: string) => void\n  }\n\nexport const defaultResponse: Omit<MockedResponse, 'headers'> = {\n  status: 200,\n  statusText: 'OK',\n  body: null,\n  delay: 0,\n  once: false,\n  passthrough: false,\n}\n\nexport type ResponseCompositionOptions<BodyType> = {\n  defaultTransformers?: ResponseTransformer<BodyType>[]\n  mockedResponseOverrides?: Partial<MockedResponse>\n}\n\nexport const defaultResponseTransformers: ResponseTransformer<any>[] = []\n\nexport function createResponseComposition<BodyType extends DefaultBodyType>(\n  responseOverrides?: Partial<MockedResponse<BodyType>>,\n  defaultTransformers: ResponseTransformer<BodyType>[] = defaultResponseTransformers,\n): ResponseFunction {\n  return async (...transformers) => {\n    const initialResponse: MockedResponse = Object.assign(\n      {},\n      defaultResponse,\n      {\n        headers: new Headers({\n          'x-powered-by': 'msw',\n        }),\n      },\n      responseOverrides,\n    )\n\n    const resolvedTransformers = [\n      ...defaultTransformers,\n      ...transformers,\n    ].filter(Boolean)\n\n    const resolvedResponse =\n      resolvedTransformers.length > 0\n        ? compose(...resolvedTransformers)(initialResponse)\n        : initialResponse\n\n    return resolvedResponse\n  }\n}\n\nexport const response = Object.assign(createResponseComposition(), {\n  once: createResponseComposition({ once: true }),\n  networkError(message: string) {\n    throw new NetworkError(message)\n  },\n})\n","type ArityOneFunction = (arg: any) => any\n\ntype LengthOfTuple<Tuple extends any[]> = Tuple extends { length: infer L }\n  ? L\n  : never\n\ntype DropFirstInTuple<Tuple extends any[]> = ((...args: Tuple) => any) extends (\n  arg: any,\n  ...rest: infer LastArg\n) => any\n  ? LastArg\n  : Tuple\n\ntype LastInTuple<Tuple extends any[]> = Tuple[LengthOfTuple<\n  DropFirstInTuple<Tuple>\n>]\n\ntype FirstFnParameterType<Functions extends ArityOneFunction[]> = Parameters<\n  LastInTuple<Functions>\n>[any]\n\ntype LastFnParameterType<Functions extends ArityOneFunction[]> = ReturnType<\n  Functions[0]\n>\n\n/**\n * Composes a given list of functions into a new function that\n * executes from right to left.\n */\nexport function compose<\n  Functions extends ArityOneFunction[],\n  LeftReturnType extends FirstFnParameterType<Functions>,\n  RightReturnType extends LastFnParameterType<Functions>,\n>(\n  ...fns: Functions\n): (\n  ...args: [LeftReturnType] extends [never] ? never[] : [LeftReturnType]\n) => RightReturnType {\n  return (...args) => {\n    return fns.reduceRight((leftFn: any, rightFn) => {\n      return leftFn instanceof Promise\n        ? Promise.resolve(leftFn).then(rightFn)\n        : rightFn(leftFn)\n    }, args[0])\n  }\n}\n","// Ignore the source files traces for local testing.\nconst SOURCE_FRAME = /[\\/\\\\]msw[\\/\\\\]src[\\/\\\\](.+)/\n\nconst BUILD_FRAME =\n  /(node_modules)?[\\/\\\\]lib[\\/\\\\](umd|esm|iief|cjs)[\\/\\\\]|^[^\\/\\\\]*$/\n\n/**\n * Return the stack trace frame of a function's invocation.\n */\nexport function getCallFrame(error: Error) {\n  // In <IE11, new Error may return an undefined stack\n  const stack = error.stack\n\n  if (!stack) {\n    return\n  }\n\n  const frames: string[] = stack.split('\\n').slice(1)\n\n  // Get the first frame that doesn't reference the library's internal trace.\n  // Assume that frame is the invocation frame.\n  const declarationFrame = frames.find((frame) => {\n    return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame))\n  })\n\n  if (!declarationFrame) {\n    return\n  }\n\n  // Extract file reference from the stack frame.\n  const declarationPath = declarationFrame\n    .replace(/\\s*at [^()]*\\(([^)]+)\\)/, '$1')\n    .replace(/^@/, '')\n  return declarationPath\n}\n","/**\n * Determines if the given function is an iterator.\n */\nexport function isIterable<IteratorType>(\n  fn: any,\n): fn is Generator<IteratorType, IteratorType, IteratorType> {\n  if (!fn) {\n    return false\n  }\n\n  return typeof (fn as Generator<unknown>)[Symbol.iterator] == 'function'\n}\n","import { body, cookie, json, text, xml } from '../context'\nimport type { SerializedResponse } from '../setupWorker/glossary'\nimport { ResponseResolutionContext } from '../utils/getResponse'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { isStringEqual } from '../utils/internal/isStringEqual'\nimport { getStatusCodeColor } from '../utils/logging/getStatusCodeColor'\nimport { getTimestamp } from '../utils/logging/getTimestamp'\nimport { prepareRequest } from '../utils/logging/prepareRequest'\nimport { prepareResponse } from '../utils/logging/prepareResponse'\nimport {\n  Match,\n  matchRequestUrl,\n  Path,\n  PathParams,\n} from '../utils/matching/matchRequestUrl'\nimport { getPublicUrlFromRequest } from '../utils/request/getPublicUrlFromRequest'\nimport { MockedRequest } from '../utils/request/MockedRequest'\nimport { cleanUrl, getSearchParams } from '../utils/url/cleanUrl'\nimport {\n  DefaultBodyType,\n  defaultContext,\n  DefaultContext,\n  RequestHandler,\n  RequestHandlerDefaultInfo,\n  ResponseResolver,\n} from './RequestHandler'\n\ntype RestHandlerMethod = string | RegExp\n\nexport interface RestHandlerInfo extends RequestHandlerDefaultInfo {\n  method: RestHandlerMethod\n  path: Path\n}\n\nexport enum RESTMethods {\n  HEAD = 'HEAD',\n  GET = 'GET',\n  POST = 'POST',\n  PUT = 'PUT',\n  PATCH = 'PATCH',\n  OPTIONS = 'OPTIONS',\n  DELETE = 'DELETE',\n}\n\n// Declaring a context interface infers\n// JSDoc description of the referenced utils.\nexport type RestContext = DefaultContext & {\n  cookie: typeof cookie\n  text: typeof text\n  body: typeof body\n  json: typeof json\n  xml: typeof xml\n}\n\nexport const restContext: RestContext = {\n  ...defaultContext,\n  cookie,\n  body,\n  text,\n  json,\n  xml,\n}\n\nexport type RequestQuery = {\n  [queryName: string]: string\n}\n\nexport type ParsedRestRequest = Match\n\nexport class RestRequest<\n  RequestBody extends DefaultBodyType = DefaultBodyType,\n  RequestParams extends PathParams = PathParams,\n> extends MockedRequest<RequestBody> {\n  constructor(\n    request: MockedRequest<RequestBody>,\n    public readonly params: RequestParams,\n  ) {\n    super(request.url, {\n      ...request,\n      /**\n       * @deprecated https://github.com/mswjs/msw/issues/1318\n       * @note Use internal request body buffer as the body init\n       * because \"request.body\" is a getter that will trigger\n       * request body parsing at this step.\n       */\n      body: request['_body'],\n    })\n    this.id = request.id\n  }\n}\n\n/**\n * Request handler for REST API requests.\n * Provides request matching based on method and URL.\n */\nexport class RestHandler<\n  RequestType extends MockedRequest<DefaultBodyType> = MockedRequest<DefaultBodyType>,\n> extends RequestHandler<\n  RestHandlerInfo,\n  RequestType,\n  ParsedRestRequest,\n  RestRequest<\n    RequestType extends MockedRequest<infer RequestBodyType>\n      ? RequestBodyType\n      : any,\n    PathParams\n  >\n> {\n  constructor(\n    method: RestHandlerMethod,\n    path: Path,\n    resolver: ResponseResolver<any, any>,\n  ) {\n    super({\n      info: {\n        header: `${method} ${path}`,\n        path,\n        method,\n      },\n      ctx: restContext,\n      resolver,\n    })\n\n    this.checkRedundantQueryParameters()\n  }\n\n  private checkRedundantQueryParameters() {\n    const { method, path } = this.info\n\n    if (path instanceof RegExp) {\n      return\n    }\n\n    const url = cleanUrl(path)\n\n    // Bypass request handler URLs that have no redundant characters.\n    if (url === path) {\n      return\n    }\n\n    const searchParams = getSearchParams(path)\n    const queryParams: string[] = []\n\n    searchParams.forEach((_, paramName) => {\n      queryParams.push(paramName)\n    })\n\n    devUtils.warn(\n      `Found a redundant usage of query parameters in the request handler URL for \"${method} ${path}\". Please match against a path instead and access query parameters in the response resolver function using \"req.url.searchParams\".`,\n    )\n  }\n\n  parse(request: RequestType, resolutionContext?: ResponseResolutionContext) {\n    return matchRequestUrl(\n      request.url,\n      this.info.path,\n      resolutionContext?.baseUrl,\n    )\n  }\n\n  protected getPublicRequest(\n    request: RequestType,\n    parsedResult: ParsedRestRequest,\n  ): RestRequest<any, PathParams> {\n    return new RestRequest(request, parsedResult.params || {})\n  }\n\n  predicate(request: RequestType, parsedResult: ParsedRestRequest) {\n    const matchesMethod =\n      this.info.method instanceof RegExp\n        ? this.info.method.test(request.method)\n        : isStringEqual(this.info.method, request.method)\n\n    return matchesMethod && parsedResult.matches\n  }\n\n  log(request: RequestType, response: SerializedResponse<any>) {\n    const publicUrl = getPublicUrlFromRequest(request)\n    const loggedRequest = prepareRequest(request)\n    const loggedResponse = prepareResponse(response)\n    const statusColor = getStatusCodeColor(response.status)\n\n    console.groupCollapsed(\n      devUtils.formatMessage('%s %s %s (%c%s%c)'),\n      getTimestamp(),\n      request.method,\n      publicUrl,\n      `color:${statusColor}`,\n      `${response.status} ${response.statusText}`,\n      'color:inherit',\n    )\n    console.log('Request', loggedRequest)\n    console.log('Handler:', this)\n    console.log('Response', loggedResponse)\n    console.groupEnd()\n  }\n}\n","import { invariant } from 'outvariant'\nimport { ResponseTransformer } from '../response'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\n\ntype ForbiddenFieldNames = '' | 'data' | 'errors' | 'extensions'\n\n/**\n * Set a custom field on the GraphQL mocked response.\n * @example res(ctx.fields('customField', value))\n * @see {@link https://mswjs.io/docs/api/context/field}\n */\nexport const field = <FieldNameType extends string, FieldValueType>(\n  fieldName: FieldNameType extends ForbiddenFieldNames ? never : FieldNameType,\n  fieldValue: FieldValueType,\n): ResponseTransformer<string> => {\n  return (res) => {\n    validateFieldName(fieldName)\n\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { [fieldName]: fieldValue })\n\n    return json(nextBody)(res as any) as any\n  }\n}\n\nfunction validateFieldName(fieldName: string) {\n  invariant(\n    fieldName.trim() !== '',\n    devUtils.formatMessage(\n      'Failed to set a custom field on a GraphQL response: field name cannot be empty.',\n    ),\n  )\n\n  invariant(\n    fieldName !== 'data',\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.data()\" instead?',\n      fieldName,\n    ),\n  )\n\n  invariant(\n    fieldName !== 'errors',\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.errors()\" instead?',\n      fieldName,\n    ),\n  )\n\n  invariant(\n    fieldName !== 'extensions',\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.extensions()\" instead?',\n      fieldName,\n    ),\n  )\n}\n","export function tryCatch<Fn extends (...args: any[]) => any>(\n  fn: Fn,\n  onException?: (error: Error) => void,\n): ReturnType<Fn> | undefined {\n  try {\n    const result = fn()\n    return result\n  } catch (error) {\n    onException?.(error as Error)\n  }\n}\n","import type { DocumentNode, OperationTypeNode } from 'graphql'\nimport { SerializedResponse } from '../setupWorker/glossary'\nimport { data } from '../context/data'\nimport { extensions } from '../context/extensions'\nimport { errors } from '../context/errors'\nimport { field } from '../context/field'\nimport { GraphQLPayloadContext } from '../typeUtils'\nimport { cookie } from '../context/cookie'\nimport {\n  defaultContext,\n  DefaultContext,\n  RequestHandler,\n  RequestHandlerDefaultInfo,\n  ResponseResolver,\n} from './RequestHandler'\nimport { getTimestamp } from '../utils/logging/getTimestamp'\nimport { getStatusCodeColor } from '../utils/logging/getStatusCodeColor'\nimport { prepareRequest } from '../utils/logging/prepareRequest'\nimport { prepareResponse } from '../utils/logging/prepareResponse'\nimport { matchRequestUrl, Path } from '../utils/matching/matchRequestUrl'\nimport {\n  ParsedGraphQLRequest,\n  GraphQLMultipartRequestBody,\n  parseGraphQLRequest,\n  parseDocumentNode,\n} from '../utils/internal/parseGraphQLRequest'\nimport { getPublicUrlFromRequest } from '../utils/request/getPublicUrlFromRequest'\nimport { tryCatch } from '../utils/internal/tryCatch'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { MockedRequest } from '../utils/request/MockedRequest'\n\nexport type ExpectedOperationTypeNode = OperationTypeNode | 'all'\nexport type GraphQLHandlerNameSelector = DocumentNode | RegExp | string\n\n// GraphQL related context should contain utility functions\n// useful for GraphQL. Functions like `xml()` bear no value\n// in the GraphQL universe.\nexport type GraphQLContext<QueryType extends Record<string, unknown>> =\n  DefaultContext & {\n    data: GraphQLPayloadContext<QueryType>\n    extensions: GraphQLPayloadContext<QueryType>\n    errors: typeof errors\n    cookie: typeof cookie\n    field: typeof field\n  }\n\nexport const graphqlContext: GraphQLContext<any> = {\n  ...defaultContext,\n  data,\n  extensions,\n  errors,\n  cookie,\n  field,\n}\n\nexport type GraphQLVariables = Record<string, any>\n\nexport interface GraphQLHandlerInfo extends RequestHandlerDefaultInfo {\n  operationType: ExpectedOperationTypeNode\n  operationName: GraphQLHandlerNameSelector\n}\n\nexport type GraphQLRequestBody<VariablesType extends GraphQLVariables> =\n  | GraphQLJsonRequestBody<VariablesType>\n  | GraphQLMultipartRequestBody\n  | Record<string, any>\n  | undefined\n\nexport interface GraphQLJsonRequestBody<Variables extends GraphQLVariables> {\n  query: string\n  variables?: Variables\n}\n\nexport function isDocumentNode(\n  value: DocumentNode | any,\n): value is DocumentNode {\n  if (value == null) {\n    return false\n  }\n\n  return typeof value === 'object' && 'kind' in value && 'definitions' in value\n}\n\nexport class GraphQLRequest<\n  Variables extends GraphQLVariables,\n> extends MockedRequest<GraphQLRequestBody<Variables>> {\n  constructor(request: MockedRequest, public readonly variables: Variables) {\n    super(request.url, {\n      ...request,\n      /**\n       * TODO(https://github.com/mswjs/msw/issues/1318): Cleanup\n       */\n      body: request['_body'],\n    })\n  }\n}\n\nexport class GraphQLHandler<\n  Request extends GraphQLRequest<any> = GraphQLRequest<any>,\n> extends RequestHandler<\n  GraphQLHandlerInfo,\n  Request,\n  ParsedGraphQLRequest | null,\n  GraphQLRequest<any>\n> {\n  private endpoint: Path\n\n  constructor(\n    operationType: ExpectedOperationTypeNode,\n    operationName: GraphQLHandlerNameSelector,\n    endpoint: Path,\n    resolver: ResponseResolver<any, any>,\n  ) {\n    let resolvedOperationName = operationName\n\n    if (isDocumentNode(operationName)) {\n      const parsedNode = parseDocumentNode(operationName)\n\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected \"${operationType}\", but got \"${parsedNode.operationType}\").`,\n        )\n      }\n\n      if (!parsedNode.operationName) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`,\n        )\n      }\n\n      resolvedOperationName = parsedNode.operationName\n    }\n\n    const header =\n      operationType === 'all'\n        ? `${operationType} (origin: ${endpoint.toString()})`\n        : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`\n\n    super({\n      info: {\n        header,\n        operationType,\n        operationName: resolvedOperationName,\n      },\n      ctx: graphqlContext,\n      resolver,\n    })\n\n    this.endpoint = endpoint\n  }\n\n  parse(request: MockedRequest) {\n    return tryCatch(\n      () => parseGraphQLRequest(request),\n      (error) => console.error(error.message),\n    )\n  }\n\n  protected getPublicRequest(\n    request: Request,\n    parsedResult: ParsedGraphQLRequest,\n  ): GraphQLRequest<any> {\n    return new GraphQLRequest(request, parsedResult?.variables || {})\n  }\n\n  predicate(request: MockedRequest, parsedResult: ParsedGraphQLRequest) {\n    if (!parsedResult) {\n      return false\n    }\n\n    if (!parsedResult.operationName && this.info.operationType !== 'all') {\n      const publicUrl = getPublicUrlFromRequest(request)\n      devUtils.warn(`\\\nFailed to intercept a GraphQL request at \"${request.method} ${publicUrl}\": anonymous GraphQL operations are not supported.\n\nConsider naming this operation or using \"graphql.operation\" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/operation\\\n      `)\n      return false\n    }\n\n    const hasMatchingUrl = matchRequestUrl(request.url, this.endpoint)\n    const hasMatchingOperationType =\n      this.info.operationType === 'all' ||\n      parsedResult.operationType === this.info.operationType\n\n    const hasMatchingOperationName =\n      this.info.operationName instanceof RegExp\n        ? this.info.operationName.test(parsedResult.operationName || '')\n        : parsedResult.operationName === this.info.operationName\n\n    return (\n      hasMatchingUrl.matches &&\n      hasMatchingOperationType &&\n      hasMatchingOperationName\n    )\n  }\n\n  log(\n    request: Request,\n    response: SerializedResponse<any>,\n    parsedRequest: ParsedGraphQLRequest,\n  ) {\n    const loggedRequest = prepareRequest(request)\n    const loggedResponse = prepareResponse(response)\n    const statusColor = getStatusCodeColor(response.status)\n    const requestInfo = parsedRequest?.operationName\n      ? `${parsedRequest?.operationType} ${parsedRequest?.operationName}`\n      : `anonymous ${parsedRequest?.operationType}`\n\n    console.groupCollapsed(\n      devUtils.formatMessage('%s %s (%c%s%c)'),\n      getTimestamp(),\n      `${requestInfo}`,\n      `color:${statusColor}`,\n      `${response.status} ${response.statusText}`,\n      'color:inherit',\n    )\n    console.log('Request:', loggedRequest)\n    console.log('Handler:', this)\n    console.log('Response:', loggedResponse)\n    console.groupEnd()\n  }\n}\n","import { store } from '@mswjs/cookies'\nimport { MockedResponse } from '../../response'\nimport { MockedRequest } from './MockedRequest'\n\nexport function readResponseCookies(\n  request: MockedRequest,\n  response: MockedResponse,\n) {\n  store.add({ ...request, url: request.url.toString() }, response)\n  store.persist()\n}\n","import { flattenHeadersObject, headersToObject } from 'headers-polyfill'\nimport type { SerializedResponse } from '../../setupWorker/glossary'\n\nexport function serializeResponse(source: Response): SerializedResponse<any> {\n  return {\n    status: source.status,\n    statusText: source.statusText,\n    headers: flattenHeadersObject(headersToObject(source.headers)),\n    body: source.body,\n  }\n}\n","import {\n  StartOptions,\n  SerializedResponse,\n  SetupWorkerInternalContext,\n  ServiceWorkerIncomingEventsMap,\n} from '../glossary'\nimport {\n  ServiceWorkerMessage,\n  WorkerChannel,\n} from './utils/createMessageChannel'\nimport { NetworkError } from '../../utils/NetworkError'\nimport { parseWorkerRequest } from '../../utils/request/parseWorkerRequest'\nimport { handleRequest } from '../../utils/handleRequest'\nimport { RequiredDeep } from '../../typeUtils'\nimport { MockedResponse } from '../../response'\nimport { devUtils } from '../../utils/internal/devUtils'\nimport { serializeResponse } from '../../utils/logging/serializeResponse'\n\nexport const createRequestListener = (\n  context: SetupWorkerInternalContext,\n  options: RequiredDeep<StartOptions>,\n) => {\n  return async (\n    event: MessageEvent,\n    message: ServiceWorkerMessage<\n      'REQUEST',\n      ServiceWorkerIncomingEventsMap['REQUEST']\n    >,\n  ) => {\n    const messageChannel = new WorkerChannel(event.ports[0])\n    const request = parseWorkerRequest(message.payload)\n\n    try {\n      await handleRequest<SerializedResponse>(\n        request,\n        context.requestHandlers,\n        options,\n        context.emitter,\n        {\n          transformResponse,\n          onPassthroughResponse() {\n            messageChannel.postMessage('NOT_FOUND')\n          },\n          async onMockedResponse(\n            response,\n            { handler, publicRequest, parsedRequest },\n          ) {\n            if (response.body instanceof ReadableStream) {\n              throw new Error(\n                devUtils.formatMessage(\n                  'Failed to construct a mocked response with a \"ReadableStream\" body: mocked streams are not supported. Follow https://github.com/mswjs/msw/issues/1336 for more details.',\n                ),\n              )\n            }\n\n            const responseInstance = new Response(response.body, response)\n            const responseBodyBuffer = await responseInstance.arrayBuffer()\n\n            // If the mocked response has no body, keep it that way.\n            // Sending an empty \"ArrayBuffer\" to the worker will cause\n            // the worker constructing \"new Response(new ArrayBuffer(0))\"\n            // which will throw on responses that must have no body (i.e. 204).\n            const responseBody =\n              response.body == null ? null : responseBodyBuffer\n\n            messageChannel.postMessage(\n              'MOCK_RESPONSE',\n              {\n                ...response,\n                body: responseBody,\n              },\n              [responseBodyBuffer],\n            )\n\n            if (!options.quiet) {\n              context.emitter.once('response:mocked', (response) => {\n                handler.log(\n                  publicRequest,\n                  serializeResponse(response),\n                  parsedRequest,\n                )\n              })\n            }\n          },\n        },\n      )\n    } catch (error) {\n      if (error instanceof NetworkError) {\n        // Treat emulated network error differently,\n        // as it is an intended exception in a request handler.\n        messageChannel.postMessage('NETWORK_ERROR', {\n          name: error.name,\n          message: error.message,\n        })\n\n        return\n      }\n\n      if (error instanceof Error) {\n        devUtils.error(\n          `Uncaught exception in the request handler for \"%s %s\":\n\n%s\n\nThis exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/recipes/mocking-error-responses`,\n          request.method,\n          request.url,\n          error.stack ?? error,\n        )\n\n        // Treat all other exceptions in a request handler as unintended,\n        // alerting that there is a problem that needs fixing.\n        messageChannel.postMessage('MOCK_RESPONSE', {\n          status: 500,\n          statusText: 'Request Handler Error',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify({\n            name: error.name,\n            message: error.message,\n            stack: error.stack,\n          }),\n        })\n      }\n    }\n  }\n}\n\nfunction transformResponse(\n  response: MockedResponse<string>,\n): SerializedResponse<string> {\n  return {\n    status: response.status,\n    statusText: response.statusText,\n    headers: response.headers.all(),\n    body: response.body,\n    delay: response.delay,\n  }\n}\n","import { SetupWorkerInternalContext } from '../../setupWorker/glossary'\n\nexport async function requestIntegrityCheck(\n  context: SetupWorkerInternalContext,\n  serviceWorker: ServiceWorker,\n): Promise<ServiceWorker> {\n  // Signal Service Worker to report back its integrity\n  context.workerChannel.send('INTEGRITY_CHECK_REQUEST')\n\n  const { payload: actualChecksum } = await context.events.once(\n    'INTEGRITY_CHECK_RESPONSE',\n  )\n\n  // Compare the response from the Service Worker and the\n  // global variable set during the build.\n  if (actualChecksum !== SERVICE_WORKER_CHECKSUM) {\n    throw new Error(\n      `Currently active Service Worker (${actualChecksum}) is behind the latest published one (${SERVICE_WORKER_CHECKSUM}).`,\n    )\n  }\n\n  return serviceWorker\n}\n","import { until } from '@open-draft/until'\n\n/**\n * Intercepts and defers any requests on the page\n * until the Service Worker instance is ready.\n * Must only be used in a browser.\n */\nexport function deferNetworkRequestsUntil(predicatePromise: Promise<any>) {\n  // Defer any `XMLHttpRequest` requests until the Service Worker is ready.\n  const originalXhrSend = window.XMLHttpRequest.prototype.send\n  window.XMLHttpRequest.prototype.send = function (\n    ...args: Parameters<XMLHttpRequest['send']>\n  ) {\n    // Keep this function synchronous to comply with `XMLHttpRequest.prototype.send`,\n    // because that method is always synchronous.\n    until(() => predicatePromise).then(() => {\n      window.XMLHttpRequest.prototype.send = originalXhrSend\n      this.send(...args)\n    })\n  }\n\n  // Defer any `fetch` requests until the Service Worker is ready.\n  const originalFetch = window.fetch\n  window.fetch = async (...args) => {\n    await until(() => predicatePromise)\n    window.fetch = originalFetch\n    return window.fetch(...args)\n  }\n}\n","import {\n  ServiceWorkerIncomingEventsMap,\n  SetupWorkerInternalContext,\n} from '../../setupWorker/glossary'\nimport { ServiceWorkerMessage } from './utils/createMessageChannel'\n\nexport function createResponseListener(context: SetupWorkerInternalContext) {\n  return (\n    _: MessageEvent,\n    message: ServiceWorkerMessage<\n      'RESPONSE',\n      ServiceWorkerIncomingEventsMap['RESPONSE']\n    >,\n  ) => {\n    const { payload: responseJson } = message\n\n    /**\n     * CORS requests with `mode: \"no-cors\"` result in \"opaque\" responses.\n     * That kind of responses cannot be manipulated in JavaScript due\n     * to the security considerations.\n     * @see https://fetch.spec.whatwg.org/#concept-filtered-response-opaque\n     * @see https://github.com/mswjs/msw/issues/529\n     */\n    if (responseJson.type?.includes('opaque')) {\n      return\n    }\n\n    const response = new Response(responseJson.body || null, responseJson)\n    const isMockedResponse = response.headers.get('x-powered-by') === 'msw'\n\n    if (isMockedResponse) {\n      context.emitter.emit('response:mocked', response, responseJson.requestId)\n    } else {\n      context.emitter.emit('response:bypass', response, responseJson.requestId)\n    }\n  }\n}\n","import { devUtils } from '../../../utils/internal/devUtils'\nimport { StartOptions } from '../../glossary'\n\nexport function validateWorkerScope(\n  registration: ServiceWorkerRegistration,\n  options?: StartOptions,\n): void {\n  if (!options?.quiet && !location.href.startsWith(registration.scope)) {\n    devUtils.warn(\n      `\\\nCannot intercept requests on this page because it's outside of the worker's scope (\"${registration.scope}\"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level (\"/\") of your application.\n- Set the \"Service-Worker-Allowed\" response header to allow out-of-scope workers.\\\n`,\n    )\n  }\n}\n","import { devUtils } from '../../../utils/internal/devUtils'\n\nexport function printStopMessage(args: { quiet?: boolean } = {}): void {\n  if (args.quiet) {\n    return\n  }\n\n  console.log(\n    `%c${devUtils.formatMessage('Mocking disabled.')}`,\n    'color:orangered;font-weight:bold;',\n  )\n}\n","import { devUtils } from '../../utils/internal/devUtils'\nimport { SetupWorkerInternalContext, StopHandler } from '../glossary'\nimport { printStopMessage } from './utils/printStopMessage'\n\nexport const createStop = (\n  context: SetupWorkerInternalContext,\n): StopHandler => {\n  return function stop() {\n    // Warn developers calling \"worker.stop()\" more times than necessary.\n    // This likely indicates a mistake in their code.\n    if (!context.isMockingEnabled) {\n      devUtils.warn(\n        'Found a redundant \"worker.stop()\" call. Note that stopping the worker while mocking already stopped has no effect. Consider removing this \"worker.stop()\" call.',\n      )\n      return\n    }\n\n    /**\n     * Signal the Service Worker to disable mocking for this client.\n     * Use this an an explicit way to stop the mocking, while preserving\n     * the worker-client relation. Does not affect the worker's lifecycle.\n     */\n    context.workerChannel.send('MOCK_DEACTIVATE')\n    context.isMockingEnabled = false\n    window.clearInterval(context.keepAliveInterval)\n\n    printStopMessage({ quiet: context.startOptions?.quiet })\n  }\n}\n","import { RequiredDeep } from '../../../typeUtils'\nimport { mergeRight } from '../../../utils/internal/mergeRight'\nimport {\n  SetupWorker,\n  SetupWorkerInternalContext,\n  StartHandler,\n  StartOptions,\n} from '../../glossary'\n\nexport const DEFAULT_START_OPTIONS: RequiredDeep<StartOptions> = {\n  serviceWorker: {\n    url: '/mockServiceWorker.js',\n    options: null as any,\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: 'warn',\n  findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl\n  },\n}\n\n/**\n * Returns resolved worker start options, merging the default options\n * with the given custom options.\n */\nexport function resolveStartOptions(\n  initialOptions?: StartOptions,\n): RequiredDeep<StartOptions> {\n  return mergeRight(\n    DEFAULT_START_OPTIONS,\n    initialOptions || {},\n  ) as RequiredDeep<StartOptions>\n}\n\nexport function prepareStartHandler(\n  handler: StartHandler,\n  context: SetupWorkerInternalContext,\n): SetupWorker['start'] {\n  return (initialOptions) => {\n    context.startOptions = resolveStartOptions(initialOptions)\n    return handler(context.startOptions, initialOptions || {})\n  }\n}\n","import {\n  Interceptor,\n  BatchInterceptor,\n  HttpRequestEventMap,\n} from '@mswjs/interceptors'\nimport { FetchInterceptor } from '@mswjs/interceptors/lib/interceptors/fetch'\nimport { XMLHttpRequestInterceptor } from '@mswjs/interceptors/lib/interceptors/XMLHttpRequest'\nimport {\n  SerializedResponse,\n  SetupWorkerInternalContext,\n  StartOptions,\n} from '../glossary'\nimport type { RequiredDeep } from '../../typeUtils'\nimport { handleRequest } from '../../utils/handleRequest'\nimport { MockedRequest } from '../../utils/request/MockedRequest'\nimport { serializeResponse } from '../../utils/logging/serializeResponse'\nimport { createResponseFromIsomorphicResponse } from '../../utils/request/createResponseFromIsomorphicResponse'\n\nexport function createFallbackRequestListener(\n  context: SetupWorkerInternalContext,\n  options: RequiredDeep<StartOptions>,\n): Interceptor<HttpRequestEventMap> {\n  const interceptor = new BatchInterceptor({\n    name: 'fallback',\n    interceptors: [new FetchInterceptor(), new XMLHttpRequestInterceptor()],\n  })\n\n  interceptor.on('request', async (request) => {\n    const mockedRequest = new MockedRequest(request.url, {\n      ...request,\n      body: await request.arrayBuffer(),\n    })\n\n    const response = await handleRequest<SerializedResponse>(\n      mockedRequest,\n      context.requestHandlers,\n      options,\n      context.emitter,\n      {\n        transformResponse(response) {\n          return {\n            status: response.status,\n            statusText: response.statusText,\n            headers: response.headers.all(),\n            body: response.body,\n            delay: response.delay,\n          }\n        },\n        onMockedResponse(_, { handler, publicRequest, parsedRequest }) {\n          if (!options.quiet) {\n            context.emitter.once('response:mocked', (response) => {\n              handler.log(\n                publicRequest,\n                serializeResponse(response),\n                parsedRequest,\n              )\n            })\n          }\n        },\n      },\n    )\n\n    if (response) {\n      request.respondWith(response)\n    }\n  })\n\n  interceptor.on('response', (request, response) => {\n    if (!request.id) {\n      return\n    }\n\n    const browserResponse = createResponseFromIsomorphicResponse(response)\n\n    if (response.headers.get('x-powered-by') === 'msw') {\n      context.emitter.emit('response:mocked', browserResponse, request.id)\n    } else {\n      context.emitter.emit('response:bypass', browserResponse, request.id)\n    }\n  })\n\n  interceptor.apply()\n\n  return interceptor\n}\n","import { encodeBuffer, IsomorphicResponse } from '@mswjs/interceptors'\n\nconst noop = () => {\n  throw new Error('Not implemented')\n}\n\nexport function createResponseFromIsomorphicResponse(\n  response: IsomorphicResponse,\n): Response {\n  return {\n    ...response,\n    ok: response.status >= 200 && response.status < 300,\n    url: '',\n    type: 'default',\n    status: response.status,\n    statusText: response.statusText,\n    headers: response.headers,\n    body: new ReadableStream(),\n    redirected: response.headers.get('Location') != null,\n    async text() {\n      return response.body || ''\n    },\n    async json() {\n      return JSON.parse(response.body || '')\n    },\n    async arrayBuffer() {\n      return encodeBuffer(response.body || '')\n    },\n    bodyUsed: false,\n    formData: noop,\n    blob: noop,\n    clone: noop,\n  }\n}\n","import { createFallbackRequestListener } from './createFallbackRequestListener'\nimport { SetupWorkerInternalContext, StartHandler } from '../glossary'\nimport { printStartMessage } from './utils/printStartMessage'\n\nexport function createFallbackStart(\n  context: SetupWorkerInternalContext,\n): StartHandler {\n  return async function start(options) {\n    context.fallbackInterceptor = createFallbackRequestListener(\n      context,\n      options,\n    )\n\n    printStartMessage({\n      message: 'Mocking enabled (fallback mode).',\n      quiet: options.quiet,\n    })\n\n    return undefined\n  }\n}\n","import { SetupWorkerInternalContext, StopHandler } from '../glossary'\nimport { printStopMessage } from './utils/printStopMessage'\n\nexport function createFallbackStop(\n  context: SetupWorkerInternalContext,\n): StopHandler {\n  return function stop() {\n    context.fallbackInterceptor?.dispose()\n    printStopMessage({ quiet: context.startOptions?.quiet })\n  }\n}\n","import { invariant } from 'outvariant'\nimport { EventMap, Emitter } from 'strict-event-emitter'\nimport {\n  DefaultBodyType,\n  RequestHandler,\n  RequestHandlerDefaultInfo,\n} from './handlers/RequestHandler'\nimport { LifeCycleEventEmitter } from './sharedOptions'\nimport { devUtils } from './utils/internal/devUtils'\nimport { pipeEvents } from './utils/internal/pipeEvents'\nimport { toReadonlyArray } from './utils/internal/toReadonlyArray'\nimport { MockedRequest } from './utils/request/MockedRequest'\n\n/**\n * Generic class for the mock API setup.\n */\nexport abstract class SetupApi<EventsMap extends EventMap> {\n  protected initialHandlers: ReadonlyArray<RequestHandler>\n  protected currentHandlers: Array<RequestHandler>\n  protected readonly emitter: Emitter<EventsMap>\n  protected readonly publicEmitter: Emitter<EventsMap>\n\n  public readonly events: LifeCycleEventEmitter<EventsMap>\n\n  constructor(...initialHandlers: Array<RequestHandler>) {\n    this.validateHandlers(...initialHandlers)\n\n    this.initialHandlers = toReadonlyArray(initialHandlers)\n    this.currentHandlers = [...initialHandlers]\n\n    this.emitter = new Emitter<EventsMap>()\n    this.publicEmitter = new Emitter<EventsMap>()\n    pipeEvents(this.emitter, this.publicEmitter)\n\n    this.events = this.createLifeCycleEvents()\n  }\n\n  private validateHandlers(...handlers: ReadonlyArray<RequestHandler>): void {\n    // Guard against incorrect call signature of the setup API.\n    for (const handler of handlers) {\n      invariant(\n        !Array.isArray(handler),\n        devUtils.formatMessage(\n          'Failed to construct \"%s\" given an Array of request handlers. Make sure you spread the request handlers when calling the respective setup function.',\n        ),\n        this.constructor.name,\n      )\n    }\n  }\n\n  protected dispose(): void {\n    this.emitter.removeAllListeners()\n    this.publicEmitter.removeAllListeners()\n  }\n\n  public use(...runtimeHandlers: Array<RequestHandler>): void {\n    this.currentHandlers.unshift(...runtimeHandlers)\n  }\n\n  public restoreHandlers(): void {\n    this.currentHandlers.forEach((handler) => {\n      handler.markAsSkipped(false)\n    })\n  }\n\n  public resetHandlers(...nextHandlers: Array<RequestHandler>): void {\n    this.currentHandlers =\n      nextHandlers.length > 0 ? [...nextHandlers] : [...this.initialHandlers]\n  }\n\n  public listHandlers(): ReadonlyArray<\n    RequestHandler<\n      RequestHandlerDefaultInfo,\n      MockedRequest<DefaultBodyType>,\n      any,\n      MockedRequest<DefaultBodyType>\n    >\n  > {\n    return toReadonlyArray(this.currentHandlers)\n  }\n\n  private createLifeCycleEvents(): LifeCycleEventEmitter<EventsMap> {\n    return {\n      on: (...args: any[]) => {\n        return (this.publicEmitter.on as any)(...args)\n      },\n      removeListener: (...args: any[]) => {\n        return (this.publicEmitter.removeListener as any)(...args)\n      },\n      removeAllListeners: (...args: any[]) => {\n        return this.publicEmitter.removeAllListeners(...args)\n      },\n    }\n  }\n\n  abstract printHandlers(): void\n}\n","import { Emitter, EventMap } from 'strict-event-emitter'\n\n/**\n * Pipes all emitted events from one emitter to another.\n */\nexport function pipeEvents<Events extends EventMap>(\n  source: Emitter<Events>,\n  destination: Emitter<Events>,\n): void {\n  const rawEmit = source.emit\n\n  // @ts-ignore\n  if (rawEmit._isPiped) {\n    return\n  }\n\n  source.emit = function (event, ...data) {\n    destination.emit(event, ...data)\n    return rawEmit.call(this, event, ...data)\n  }\n\n  // @ts-ignore\n  source.emit._isPiped = true\n}\n","/**\n * Creates an immutable copy of the given array.\n */\nexport function toReadonlyArray<T>(source: Array<T>): ReadonlyArray<T> {\n  const clone = [...source] as Array<T>\n  Object.freeze(clone)\n  return clone\n}\n","import { DefaultBodyType, ResponseResolver } from './handlers/RequestHandler'\nimport {\n  RESTMethods,\n  RestContext,\n  RestHandler,\n  RestRequest,\n} from './handlers/RestHandler'\nimport { Path, PathParams } from './utils/matching/matchRequestUrl'\n\nfunction createRestHandler<Method extends RESTMethods | RegExp>(\n  method: Method,\n) {\n  return <\n    RequestBodyType extends DefaultBodyType = DefaultBodyType,\n    Params extends PathParams<keyof Params> = PathParams,\n    ResponseBody extends DefaultBodyType = DefaultBodyType,\n  >(\n    path: Path,\n    resolver: ResponseResolver<\n      RestRequest<\n        Method extends RESTMethods.HEAD | RESTMethods.GET\n          ? never\n          : RequestBodyType,\n        Params\n      >,\n      RestContext,\n      ResponseBody\n    >,\n  ) => {\n    return new RestHandler(method, path, resolver)\n  }\n}\n\nexport const rest = {\n  all: createRestHandler(/.+/),\n  head: createRestHandler(RESTMethods.HEAD),\n  get: createRestHandler(RESTMethods.GET),\n  post: createRestHandler(RESTMethods.POST),\n  put: createRestHandler(RESTMethods.PUT),\n  delete: createRestHandler(RESTMethods.DELETE),\n  patch: createRestHandler(RESTMethods.PATCH),\n  options: createRestHandler(RESTMethods.OPTIONS),\n}\n","import type { DocumentNode, OperationTypeNode } from 'graphql'\nimport { ResponseResolver } from './handlers/RequestHandler'\nimport {\n  GraphQLHandler,\n  GraphQLContext,\n  GraphQLRequest,\n  GraphQLVariables,\n  ExpectedOperationTypeNode,\n  GraphQLHandlerNameSelector,\n} from './handlers/GraphQLHandler'\nimport { Path } from './utils/matching/matchRequestUrl'\n\nexport interface TypedDocumentNode<\n  Result = { [key: string]: any },\n  Variables = { [key: string]: any },\n> extends DocumentNode {\n  __apiType?: (variables: Variables) => Result\n  __resultType?: Result\n  __variablesType?: Variables\n}\n\nfunction createScopedGraphQLHandler(\n  operationType: ExpectedOperationTypeNode,\n  url: Path,\n) {\n  return <\n    Query extends Record<string, any>,\n    Variables extends GraphQLVariables = GraphQLVariables,\n  >(\n    operationName:\n      | GraphQLHandlerNameSelector\n      | DocumentNode\n      | TypedDocumentNode<Query, Variables>,\n    resolver: ResponseResolver<\n      GraphQLRequest<Variables>,\n      GraphQLContext<Query>\n    >,\n  ) => {\n    return new GraphQLHandler<GraphQLRequest<Variables>>(\n      operationType,\n      operationName,\n      url,\n      resolver,\n    )\n  }\n}\n\nfunction createGraphQLOperationHandler(url: Path) {\n  return <\n    Query extends Record<string, any>,\n    Variables extends GraphQLVariables = GraphQLVariables,\n  >(\n    resolver: ResponseResolver<\n      GraphQLRequest<Variables>,\n      GraphQLContext<Query>\n    >,\n  ) => {\n    return new GraphQLHandler<GraphQLRequest<Variables>>(\n      'all',\n      new RegExp('.*'),\n      url,\n      resolver,\n    )\n  }\n}\n\nconst standardGraphQLHandlers = {\n  /**\n   * Captures any GraphQL operation, regardless of its name, under the current scope.\n   * @example\n   * graphql.operation((req, res, ctx) => {\n   *   return res(ctx.data({ name: 'John' }))\n   * })\n   * @see {@link https://mswjs.io/docs/api/graphql/operation `graphql.operation()`}\n   */\n  operation: createGraphQLOperationHandler('*'),\n\n  /**\n   * Captures a GraphQL query by a given name.\n   * @example\n   * graphql.query('GetUser', (req, res, ctx) => {\n   *   return res(ctx.data({ user: { name: 'John' } }))\n   * })\n   * @see {@link https://mswjs.io/docs/api/graphql/query `graphql.query()`}\n   */\n  query: createScopedGraphQLHandler('query' as OperationTypeNode, '*'),\n\n  /**\n   * Captures a GraphQL mutation by a given name.\n   * @example\n   * graphql.mutation('SavePost', (req, res, ctx) => {\n   *   return res(ctx.data({ post: { id: 'abc-123' } }))\n   * })\n   * @see {@link https://mswjs.io/docs/api/graphql/mutation `graphql.mutation()`}\n   */\n  mutation: createScopedGraphQLHandler('mutation' as OperationTypeNode, '*'),\n}\n\nfunction createGraphQLLink(url: Path): typeof standardGraphQLHandlers {\n  return {\n    operation: createGraphQLOperationHandler(url),\n    query: createScopedGraphQLHandler('query' as OperationTypeNode, url),\n    mutation: createScopedGraphQLHandler('mutation' as OperationTypeNode, url),\n  }\n}\n\nexport const graphql = {\n  ...standardGraphQLHandlers,\n  link: createGraphQLLink,\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}