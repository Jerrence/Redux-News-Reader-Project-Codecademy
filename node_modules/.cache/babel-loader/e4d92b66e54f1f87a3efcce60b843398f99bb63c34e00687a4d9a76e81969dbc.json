{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.collectFields = collectFields;\nexports.collectSubfields = collectSubfields;\nvar _kinds = require('../language/kinds.js');\nvar _definition = require('../type/definition.js');\nvar _directives = require('../type/directives.js');\nvar _typeFromAST = require('../utilities/typeFromAST.js');\nvar _values = require('./values.js');\n\n/**\n * Given a selectionSet, collects all of the fields and returns them.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field that\n * returns an Interface or Union type, the \"runtime type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\nfunction collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {\n  const fields = new Map();\n  collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, new Set());\n  return fields;\n}\n/**\n * Given an array of field nodes, collects all of the subfields of the passed\n * in fields, and returns them at the end.\n *\n * CollectSubFields requires the \"return type\" of an object. For a field that\n * returns an Interface or Union type, the \"return type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\n\nfunction collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {\n  const subFieldNodes = new Map();\n  const visitedFragmentNames = new Set();\n  for (const node of fieldNodes) {\n    if (node.selectionSet) {\n      collectFieldsImpl(schema, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);\n    }\n  }\n  return subFieldNodes;\n}\nfunction collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case _kinds.Kind.FIELD:\n        {\n          if (!shouldIncludeNode(variableValues, selection)) {\n            continue;\n          }\n          const name = getFieldEntryKey(selection);\n          const fieldList = fields.get(name);\n          if (fieldList !== undefined) {\n            fieldList.push(selection);\n          } else {\n            fields.set(name, [selection]);\n          }\n          break;\n        }\n      case _kinds.Kind.INLINE_FRAGMENT:\n        {\n          if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {\n            continue;\n          }\n          collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\n          break;\n        }\n      case _kinds.Kind.FRAGMENT_SPREAD:\n        {\n          const fragName = selection.name.value;\n          if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {\n            continue;\n          }\n          visitedFragmentNames.add(fragName);\n          const fragment = fragments[fragName];\n          if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {\n            continue;\n          }\n          collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\n          break;\n        }\n    }\n  }\n}\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\n\nfunction shouldIncludeNode(variableValues, node) {\n  const skip = (0, _values.getDirectiveValues)(_directives.GraphQLSkipDirective, node, variableValues);\n  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {\n    return false;\n  }\n  const include = (0, _values.getDirectiveValues)(_directives.GraphQLIncludeDirective, node, variableValues);\n  if ((include === null || include === void 0 ? void 0 : include.if) === false) {\n    return false;\n  }\n  return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\n\nfunction doesFragmentConditionMatch(schema, fragment, type) {\n  const typeConditionNode = fragment.typeCondition;\n  if (!typeConditionNode) {\n    return true;\n  }\n  const conditionalType = (0, _typeFromAST.typeFromAST)(schema, typeConditionNode);\n  if (conditionalType === type) {\n    return true;\n  }\n  if ((0, _definition.isAbstractType)(conditionalType)) {\n    return schema.isSubType(conditionalType, type);\n  }\n  return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\n\nfunction getFieldEntryKey(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","collectFields","collectSubfields","_kinds","require","_definition","_directives","_typeFromAST","_values","schema","fragments","variableValues","runtimeType","selectionSet","fields","Map","collectFieldsImpl","Set","returnType","fieldNodes","subFieldNodes","visitedFragmentNames","node","selection","selections","kind","Kind","FIELD","shouldIncludeNode","name","getFieldEntryKey","fieldList","get","undefined","push","set","INLINE_FRAGMENT","doesFragmentConditionMatch","FRAGMENT_SPREAD","fragName","has","add","fragment","skip","getDirectiveValues","GraphQLSkipDirective","if","include","GraphQLIncludeDirective","type","typeConditionNode","typeCondition","conditionalType","typeFromAST","isAbstractType","isSubType","alias"],"sources":["/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/graphql/execution/collectFields.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.collectFields = collectFields;\nexports.collectSubfields = collectSubfields;\n\nvar _kinds = require('../language/kinds.js');\n\nvar _definition = require('../type/definition.js');\n\nvar _directives = require('../type/directives.js');\n\nvar _typeFromAST = require('../utilities/typeFromAST.js');\n\nvar _values = require('./values.js');\n\n/**\n * Given a selectionSet, collects all of the fields and returns them.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field that\n * returns an Interface or Union type, the \"runtime type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\nfunction collectFields(\n  schema,\n  fragments,\n  variableValues,\n  runtimeType,\n  selectionSet,\n) {\n  const fields = new Map();\n  collectFieldsImpl(\n    schema,\n    fragments,\n    variableValues,\n    runtimeType,\n    selectionSet,\n    fields,\n    new Set(),\n  );\n  return fields;\n}\n/**\n * Given an array of field nodes, collects all of the subfields of the passed\n * in fields, and returns them at the end.\n *\n * CollectSubFields requires the \"return type\" of an object. For a field that\n * returns an Interface or Union type, the \"return type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\n\nfunction collectSubfields(\n  schema,\n  fragments,\n  variableValues,\n  returnType,\n  fieldNodes,\n) {\n  const subFieldNodes = new Map();\n  const visitedFragmentNames = new Set();\n\n  for (const node of fieldNodes) {\n    if (node.selectionSet) {\n      collectFieldsImpl(\n        schema,\n        fragments,\n        variableValues,\n        returnType,\n        node.selectionSet,\n        subFieldNodes,\n        visitedFragmentNames,\n      );\n    }\n  }\n\n  return subFieldNodes;\n}\n\nfunction collectFieldsImpl(\n  schema,\n  fragments,\n  variableValues,\n  runtimeType,\n  selectionSet,\n  fields,\n  visitedFragmentNames,\n) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case _kinds.Kind.FIELD: {\n        if (!shouldIncludeNode(variableValues, selection)) {\n          continue;\n        }\n\n        const name = getFieldEntryKey(selection);\n        const fieldList = fields.get(name);\n\n        if (fieldList !== undefined) {\n          fieldList.push(selection);\n        } else {\n          fields.set(name, [selection]);\n        }\n\n        break;\n      }\n\n      case _kinds.Kind.INLINE_FRAGMENT: {\n        if (\n          !shouldIncludeNode(variableValues, selection) ||\n          !doesFragmentConditionMatch(schema, selection, runtimeType)\n        ) {\n          continue;\n        }\n\n        collectFieldsImpl(\n          schema,\n          fragments,\n          variableValues,\n          runtimeType,\n          selection.selectionSet,\n          fields,\n          visitedFragmentNames,\n        );\n        break;\n      }\n\n      case _kinds.Kind.FRAGMENT_SPREAD: {\n        const fragName = selection.name.value;\n\n        if (\n          visitedFragmentNames.has(fragName) ||\n          !shouldIncludeNode(variableValues, selection)\n        ) {\n          continue;\n        }\n\n        visitedFragmentNames.add(fragName);\n        const fragment = fragments[fragName];\n\n        if (\n          !fragment ||\n          !doesFragmentConditionMatch(schema, fragment, runtimeType)\n        ) {\n          continue;\n        }\n\n        collectFieldsImpl(\n          schema,\n          fragments,\n          variableValues,\n          runtimeType,\n          fragment.selectionSet,\n          fields,\n          visitedFragmentNames,\n        );\n        break;\n      }\n    }\n  }\n}\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\n\nfunction shouldIncludeNode(variableValues, node) {\n  const skip = (0, _values.getDirectiveValues)(\n    _directives.GraphQLSkipDirective,\n    node,\n    variableValues,\n  );\n\n  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {\n    return false;\n  }\n\n  const include = (0, _values.getDirectiveValues)(\n    _directives.GraphQLIncludeDirective,\n    node,\n    variableValues,\n  );\n\n  if (\n    (include === null || include === void 0 ? void 0 : include.if) === false\n  ) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\n\nfunction doesFragmentConditionMatch(schema, fragment, type) {\n  const typeConditionNode = fragment.typeCondition;\n\n  if (!typeConditionNode) {\n    return true;\n  }\n\n  const conditionalType = (0, _typeFromAST.typeFromAST)(\n    schema,\n    typeConditionNode,\n  );\n\n  if (conditionalType === type) {\n    return true;\n  }\n\n  if ((0, _definition.isAbstractType)(conditionalType)) {\n    return schema.isSubType(conditionalType, type);\n  }\n\n  return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\n\nfunction getFieldEntryKey(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}