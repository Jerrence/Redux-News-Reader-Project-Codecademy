{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.ValidationContext = exports.SDLValidationContext = exports.ASTValidationContext = void 0;\nvar _kinds = require('../language/kinds.js');\nvar _visitor = require('../language/visitor.js');\nvar _TypeInfo = require('../utilities/TypeInfo.js');\n\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\nclass ASTValidationContext {\n  constructor(ast, onError) {\n    this._ast = ast;\n    this._fragments = undefined;\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._onError = onError;\n  }\n  get [Symbol.toStringTag]() {\n    return 'ASTValidationContext';\n  }\n  reportError(error) {\n    this._onError(error);\n  }\n  getDocument() {\n    return this._ast;\n  }\n  getFragment(name) {\n    let fragments;\n    if (this._fragments) {\n      fragments = this._fragments;\n    } else {\n      fragments = Object.create(null);\n      for (const defNode of this.getDocument().definitions) {\n        if (defNode.kind === _kinds.Kind.FRAGMENT_DEFINITION) {\n          fragments[defNode.name.value] = defNode;\n        }\n      }\n      this._fragments = fragments;\n    }\n    return fragments[name];\n  }\n  getFragmentSpreads(node) {\n    let spreads = this._fragmentSpreads.get(node);\n    if (!spreads) {\n      spreads = [];\n      const setsToVisit = [node];\n      let set;\n      while (set = setsToVisit.pop()) {\n        for (const selection of set.selections) {\n          if (selection.kind === _kinds.Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n      this._fragmentSpreads.set(node, spreads);\n    }\n    return spreads;\n  }\n  getRecursivelyReferencedFragments(operation) {\n    let fragments = this._recursivelyReferencedFragments.get(operation);\n    if (!fragments) {\n      fragments = [];\n      const collectedNames = Object.create(null);\n      const nodesToVisit = [operation.selectionSet];\n      let node;\n      while (node = nodesToVisit.pop()) {\n        for (const spread of this.getFragmentSpreads(node)) {\n          const fragName = spread.name.value;\n          if (collectedNames[fragName] !== true) {\n            collectedNames[fragName] = true;\n            const fragment = this.getFragment(fragName);\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n    return fragments;\n  }\n}\nexports.ASTValidationContext = ASTValidationContext;\nclass SDLValidationContext extends ASTValidationContext {\n  constructor(ast, schema, onError) {\n    super(ast, onError);\n    this._schema = schema;\n  }\n  get [Symbol.toStringTag]() {\n    return 'SDLValidationContext';\n  }\n  getSchema() {\n    return this._schema;\n  }\n}\nexports.SDLValidationContext = SDLValidationContext;\nclass ValidationContext extends ASTValidationContext {\n  constructor(schema, ast, typeInfo, onError) {\n    super(ast, onError);\n    this._schema = schema;\n    this._typeInfo = typeInfo;\n    this._variableUsages = new Map();\n    this._recursiveVariableUsages = new Map();\n  }\n  get [Symbol.toStringTag]() {\n    return 'ValidationContext';\n  }\n  getSchema() {\n    return this._schema;\n  }\n  getVariableUsages(node) {\n    let usages = this._variableUsages.get(node);\n    if (!usages) {\n      const newUsages = [];\n      const typeInfo = new _TypeInfo.TypeInfo(this._schema);\n      (0, _visitor.visit)(node, (0, _TypeInfo.visitWithTypeInfo)(typeInfo, {\n        VariableDefinition: () => false,\n        Variable(variable) {\n          newUsages.push({\n            node: variable,\n            type: typeInfo.getInputType(),\n            defaultValue: typeInfo.getDefaultValue()\n          });\n        }\n      }));\n      usages = newUsages;\n      this._variableUsages.set(node, usages);\n    }\n    return usages;\n  }\n  getRecursiveVariableUsages(operation) {\n    let usages = this._recursiveVariableUsages.get(operation);\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n      for (const frag of this.getRecursivelyReferencedFragments(operation)) {\n        usages = usages.concat(this.getVariableUsages(frag));\n      }\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n    return usages;\n  }\n  getType() {\n    return this._typeInfo.getType();\n  }\n  getParentType() {\n    return this._typeInfo.getParentType();\n  }\n  getInputType() {\n    return this._typeInfo.getInputType();\n  }\n  getParentInputType() {\n    return this._typeInfo.getParentInputType();\n  }\n  getFieldDef() {\n    return this._typeInfo.getFieldDef();\n  }\n  getDirective() {\n    return this._typeInfo.getDirective();\n  }\n  getArgument() {\n    return this._typeInfo.getArgument();\n  }\n  getEnumValue() {\n    return this._typeInfo.getEnumValue();\n  }\n}\nexports.ValidationContext = ValidationContext;","map":{"version":3,"names":["Object","defineProperty","exports","value","ValidationContext","SDLValidationContext","ASTValidationContext","_kinds","require","_visitor","_TypeInfo","constructor","ast","onError","_ast","_fragments","undefined","_fragmentSpreads","Map","_recursivelyReferencedFragments","_onError","Symbol","toStringTag","reportError","error","getDocument","getFragment","name","fragments","create","defNode","definitions","kind","Kind","FRAGMENT_DEFINITION","getFragmentSpreads","node","spreads","get","setsToVisit","set","pop","selection","selections","FRAGMENT_SPREAD","push","selectionSet","getRecursivelyReferencedFragments","operation","collectedNames","nodesToVisit","spread","fragName","fragment","schema","_schema","getSchema","typeInfo","_typeInfo","_variableUsages","_recursiveVariableUsages","getVariableUsages","usages","newUsages","TypeInfo","visit","visitWithTypeInfo","VariableDefinition","Variable","variable","type","getInputType","defaultValue","getDefaultValue","getRecursiveVariableUsages","frag","concat","getType","getParentType","getParentInputType","getFieldDef","getDirective","getArgument","getEnumValue"],"sources":["/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/graphql/validation/ValidationContext.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.ValidationContext =\n  exports.SDLValidationContext =\n  exports.ASTValidationContext =\n    void 0;\n\nvar _kinds = require('../language/kinds.js');\n\nvar _visitor = require('../language/visitor.js');\n\nvar _TypeInfo = require('../utilities/TypeInfo.js');\n\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\nclass ASTValidationContext {\n  constructor(ast, onError) {\n    this._ast = ast;\n    this._fragments = undefined;\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._onError = onError;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ASTValidationContext';\n  }\n\n  reportError(error) {\n    this._onError(error);\n  }\n\n  getDocument() {\n    return this._ast;\n  }\n\n  getFragment(name) {\n    let fragments;\n\n    if (this._fragments) {\n      fragments = this._fragments;\n    } else {\n      fragments = Object.create(null);\n\n      for (const defNode of this.getDocument().definitions) {\n        if (defNode.kind === _kinds.Kind.FRAGMENT_DEFINITION) {\n          fragments[defNode.name.value] = defNode;\n        }\n      }\n\n      this._fragments = fragments;\n    }\n\n    return fragments[name];\n  }\n\n  getFragmentSpreads(node) {\n    let spreads = this._fragmentSpreads.get(node);\n\n    if (!spreads) {\n      spreads = [];\n      const setsToVisit = [node];\n      let set;\n\n      while ((set = setsToVisit.pop())) {\n        for (const selection of set.selections) {\n          if (selection.kind === _kinds.Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n\n      this._fragmentSpreads.set(node, spreads);\n    }\n\n    return spreads;\n  }\n\n  getRecursivelyReferencedFragments(operation) {\n    let fragments = this._recursivelyReferencedFragments.get(operation);\n\n    if (!fragments) {\n      fragments = [];\n      const collectedNames = Object.create(null);\n      const nodesToVisit = [operation.selectionSet];\n      let node;\n\n      while ((node = nodesToVisit.pop())) {\n        for (const spread of this.getFragmentSpreads(node)) {\n          const fragName = spread.name.value;\n\n          if (collectedNames[fragName] !== true) {\n            collectedNames[fragName] = true;\n            const fragment = this.getFragment(fragName);\n\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n\n    return fragments;\n  }\n}\n\nexports.ASTValidationContext = ASTValidationContext;\n\nclass SDLValidationContext extends ASTValidationContext {\n  constructor(ast, schema, onError) {\n    super(ast, onError);\n    this._schema = schema;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'SDLValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n}\n\nexports.SDLValidationContext = SDLValidationContext;\n\nclass ValidationContext extends ASTValidationContext {\n  constructor(schema, ast, typeInfo, onError) {\n    super(ast, onError);\n    this._schema = schema;\n    this._typeInfo = typeInfo;\n    this._variableUsages = new Map();\n    this._recursiveVariableUsages = new Map();\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n\n  getVariableUsages(node) {\n    let usages = this._variableUsages.get(node);\n\n    if (!usages) {\n      const newUsages = [];\n      const typeInfo = new _TypeInfo.TypeInfo(this._schema);\n      (0, _visitor.visit)(\n        node,\n        (0, _TypeInfo.visitWithTypeInfo)(typeInfo, {\n          VariableDefinition: () => false,\n\n          Variable(variable) {\n            newUsages.push({\n              node: variable,\n              type: typeInfo.getInputType(),\n              defaultValue: typeInfo.getDefaultValue(),\n            });\n          },\n        }),\n      );\n      usages = newUsages;\n\n      this._variableUsages.set(node, usages);\n    }\n\n    return usages;\n  }\n\n  getRecursiveVariableUsages(operation) {\n    let usages = this._recursiveVariableUsages.get(operation);\n\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n\n      for (const frag of this.getRecursivelyReferencedFragments(operation)) {\n        usages = usages.concat(this.getVariableUsages(frag));\n      }\n\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n\n    return usages;\n  }\n\n  getType() {\n    return this._typeInfo.getType();\n  }\n\n  getParentType() {\n    return this._typeInfo.getParentType();\n  }\n\n  getInputType() {\n    return this._typeInfo.getInputType();\n  }\n\n  getParentInputType() {\n    return this._typeInfo.getParentInputType();\n  }\n\n  getFieldDef() {\n    return this._typeInfo.getFieldDef();\n  }\n\n  getDirective() {\n    return this._typeInfo.getDirective();\n  }\n\n  getArgument() {\n    return this._typeInfo.getArgument();\n  }\n\n  getEnumValue() {\n    return this._typeInfo.getEnumValue();\n  }\n}\n\nexports.ValidationContext = ValidationContext;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}