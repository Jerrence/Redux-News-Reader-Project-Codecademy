{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BatchInterceptor = void 0;\nvar Interceptor_1 = require(\"./Interceptor\");\n/**\n * A batch interceptor that exposes a single interface\n * to apply and operate with multiple interceptors at once.\n */\nvar BatchInterceptor = /** @class */function (_super) {\n  __extends(BatchInterceptor, _super);\n  function BatchInterceptor(options) {\n    var _this = this;\n    BatchInterceptor.symbol = Symbol(options.name);\n    _this = _super.call(this, BatchInterceptor.symbol) || this;\n    _this.interceptors = options.interceptors;\n    return _this;\n  }\n  BatchInterceptor.prototype.setup = function () {\n    var e_1, _a;\n    var log = this.log.extend('setup');\n    log('applying all %d interceptors...', this.interceptors.length);\n    var _loop_1 = function (interceptor) {\n      log('applying \"%s\" interceptor...', interceptor.constructor.name);\n      interceptor.apply();\n      log('adding interceptor dispose subscription');\n      this_1.subscriptions.push(function () {\n        return interceptor.dispose();\n      });\n    };\n    var this_1 = this;\n    try {\n      for (var _b = __values(this.interceptors), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var interceptor = _c.value;\n        _loop_1(interceptor);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n  BatchInterceptor.prototype.on = function (event, listener) {\n    // Instead of adding a listener to the batch interceptor,\n    // propagate the listener to each of the individual interceptors.\n    this.interceptors.forEach(function (interceptor) {\n      interceptor.on(event, listener);\n    });\n  };\n  return BatchInterceptor;\n}(Interceptor_1.Interceptor);\nexports.BatchInterceptor = BatchInterceptor;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AAgBA;;;;AAIA;EAGUA;EAKR,0BAAYC,OAAiD;IAA7D;IACEC,gBAAgB,CAACC,MAAM,GAAGC,MAAM,CAACH,OAAO,CAACI,IAAI,CAAC;IAC9CC,0BAAMJ,gBAAgB,CAACC,MAAM,CAAC;IAC9BG,KAAI,CAACC,YAAY,GAAGN,OAAO,CAACM,YAAY;;EAC1C;EAEUL,gCAAK,GAAf;;IACE,IAAMM,GAAG,GAAG,IAAI,CAACA,GAAG,CAACC,MAAM,CAAC,OAAO,CAAC;IAEpCD,GAAG,CAAC,iCAAiC,EAAE,IAAI,CAACD,YAAY,CAACG,MAAM,CAAC;4BAErDC,WAAW;MACpBH,GAAG,CAAC,8BAA8B,EAAEG,WAAW,CAACC,WAAW,CAACP,IAAI,CAAC;MACjEM,WAAW,CAACE,KAAK,EAAE;MAEnBL,GAAG,CAAC,yCAAyC,CAAC;MAC9CM,OAAKC,aAAa,CAACC,IAAI,CAAC;QAAM,kBAAW,CAACC,OAAO,EAAE;MAArB,CAAqB,CAAC;;;;MALtD,KAA0B,sBAAI,CAACV,YAAY;QAAtC,IAAMI,WAAW;gBAAXA,WAAW;;;;;;;;;;;;;EAOxB,CAAC;EAEMT,6BAAE,GAAT,UACEgB,KAAY,EACZC,QAAyB;IAEzB;IACA;IACA,IAAI,CAACZ,YAAY,CAACa,OAAO,CAAC,UAACT,WAAW;MACpCA,WAAW,CAACU,EAAE,CAACH,KAAK,EAAEC,QAAQ,CAAC;IACjC,CAAC,CAAC;EACJ,CAAC;EACH,uBAAC;AAAD,CAAC,CAnCSG,yBAAW;AAHRC","names":["__extends","options","BatchInterceptor","symbol","Symbol","name","_this","interceptors","log","extend","length","interceptor","constructor","apply","this_1","subscriptions","push","dispose","event","listener","forEach","on","Interceptor_1","exports"],"sources":["/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/@mswjs/interceptors/src/BatchInterceptor.ts"],"sourcesContent":["import { EventMapType } from 'strict-event-emitter'\nimport { ExtractEventNames, Interceptor } from './Interceptor'\n\nexport interface BatchInterceptorOptions<\n  InterceptorList extends Interceptor<any>[]\n> {\n  name: string\n  interceptors: InterceptorList\n}\n\nexport type ExtractEventMapType<InterceptorList extends Interceptor<any>[]> =\n  InterceptorList extends Array<infer InterceptorType>\n    ? InterceptorType extends Interceptor<infer EventMap>\n      ? EventMap\n      : never\n    : never\n\n/**\n * A batch interceptor that exposes a single interface\n * to apply and operate with multiple interceptors at once.\n */\nexport class BatchInterceptor<\n  InterceptorList extends Interceptor<any>[],\n  EventMap extends EventMapType = ExtractEventMapType<InterceptorList>\n> extends Interceptor<EventMap> {\n  static symbol: Symbol\n\n  private interceptors: InterceptorList\n\n  constructor(options: BatchInterceptorOptions<InterceptorList>) {\n    BatchInterceptor.symbol = Symbol(options.name)\n    super(BatchInterceptor.symbol)\n    this.interceptors = options.interceptors\n  }\n\n  protected setup() {\n    const log = this.log.extend('setup')\n\n    log('applying all %d interceptors...', this.interceptors.length)\n\n    for (const interceptor of this.interceptors) {\n      log('applying \"%s\" interceptor...', interceptor.constructor.name)\n      interceptor.apply()\n\n      log('adding interceptor dispose subscription')\n      this.subscriptions.push(() => interceptor.dispose())\n    }\n  }\n\n  public on<Event extends ExtractEventNames<EventMap>>(\n    event: Event,\n    listener: EventMap[Event]\n  ) {\n    // Instead of adding a listener to the batch interceptor,\n    // propagate the listener to each of the individual interceptors.\n    this.interceptors.forEach((interceptor) => {\n      interceptor.on(event, listener)\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}