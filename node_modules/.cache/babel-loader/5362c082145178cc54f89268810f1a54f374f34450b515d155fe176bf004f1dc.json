{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Interceptor = exports.InterceptorReadyState = exports.deleteGlobalSymbol = exports.getGlobalSymbol = void 0;\nvar debug_1 = require(\"debug\");\nvar AsyncEventEmitter_1 = require(\"./utils/AsyncEventEmitter\");\nvar nextTick_1 = require(\"./utils/nextTick\");\nfunction getGlobalSymbol(symbol) {\n  return (\n    // @ts-ignore https://github.com/Microsoft/TypeScript/issues/24587\n    globalThis[symbol] || undefined\n  );\n}\nexports.getGlobalSymbol = getGlobalSymbol;\nfunction setGlobalSymbol(symbol, value) {\n  // @ts-ignore\n  globalThis[symbol] = value;\n}\nfunction deleteGlobalSymbol(symbol) {\n  // @ts-ignore\n  delete globalThis[symbol];\n}\nexports.deleteGlobalSymbol = deleteGlobalSymbol;\nvar InterceptorReadyState;\n(function (InterceptorReadyState) {\n  InterceptorReadyState[\"IDLE\"] = \"IDLE\";\n  InterceptorReadyState[\"APPLYING\"] = \"APPLYING\";\n  InterceptorReadyState[\"APPLIED\"] = \"APPLIED\";\n  InterceptorReadyState[\"DISPOSING\"] = \"DISPOSING\";\n  InterceptorReadyState[\"DISPOSED\"] = \"DISPOSED\";\n})(InterceptorReadyState = exports.InterceptorReadyState || (exports.InterceptorReadyState = {}));\nvar Interceptor = /** @class */function () {\n  function Interceptor(symbol) {\n    this.symbol = symbol;\n    this.readyState = InterceptorReadyState.IDLE;\n    this.emitter = new AsyncEventEmitter_1.AsyncEventEmitter();\n    this.subscriptions = [];\n    this.log = debug_1.debug(symbol.description);\n    // Do not limit the maximum number of listeners\n    // so not to limit the maximum amount of parallel events emitted.\n    this.emitter.setMaxListeners(0);\n    this.log('constructing the interceptor...');\n  }\n  /**\n   * Determine if this interceptor can be applied\n   * in the current environment.\n   */\n  Interceptor.prototype.checkEnvironment = function () {\n    return true;\n  };\n  /**\n   * Apply this interceptor to the current process.\n   * Returns an already running interceptor instance if it's present.\n   */\n  Interceptor.prototype.apply = function () {\n    var _this = this;\n    var log = this.log.extend('apply');\n    log('applying the interceptor...');\n    if (this.readyState === InterceptorReadyState.APPLIED) {\n      log('intercepted already applied!');\n      return;\n    }\n    var shouldApply = this.checkEnvironment();\n    if (!shouldApply) {\n      log('the interceptor cannot be applied in this environment!');\n      return;\n    }\n    this.readyState = InterceptorReadyState.APPLYING;\n    // Always activate the emitter when applying the interceptor.\n    // This will ensure the interceptor can process events after it's\n    // been disposed and re-applied again (it may be a singleton).\n    this.emitter.activate();\n    log('activated the emiter!', this.emitter.readyState);\n    // Whenever applying a new interceptor, check if it hasn't been applied already.\n    // This enables to apply the same interceptor multiple times, for example from a different\n    // interceptor, only proxying events but keeping the stubs in a single place.\n    var runningInstance = this.getInstance();\n    if (runningInstance) {\n      log('found a running instance, reusing...');\n      // Proxy any listeners you set on this instance to the running instance.\n      this.on = function (event, listener) {\n        log('proxying the \"%s\" listener', event);\n        // Add listeners to the running instance so they appear\n        // at the top of the event listeners list and are executed first.\n        runningInstance.emitter.addListener(event, listener);\n        // Ensure that once this interceptor instance is disposed,\n        // it removes all listeners it has appended to the running interceptor instance.\n        _this.subscriptions.push(function () {\n          runningInstance.emitter.removeListener(event, listener);\n          log('removed proxied \"%s\" listener!', event);\n        });\n      };\n      nextTick_1.nextTick(function () {\n        _this.readyState = InterceptorReadyState.APPLIED;\n      });\n      return;\n    }\n    log('no running instance found, setting up a new instance...');\n    // Setup the interceptor.\n    this.setup();\n    // Store the newly applied interceptor instance globally.\n    this.setInstance();\n    nextTick_1.nextTick(function () {\n      _this.readyState = InterceptorReadyState.APPLIED;\n    });\n  };\n  /**\n   * Setup the module augments and stubs necessary for this interceptor.\n   * This method is not run if there's a running interceptor instance\n   * to prevent instantiating an interceptor multiple times.\n   */\n  Interceptor.prototype.setup = function () {};\n  /**\n   * Listen to the interceptor's public events.\n   */\n  Interceptor.prototype.on = function (event, listener) {\n    var log = this.log.extend('on');\n    if (this.readyState === InterceptorReadyState.DISPOSING || this.readyState === InterceptorReadyState.DISPOSED) {\n      log('cannot listen to events, already disposed!');\n      return;\n    }\n    log('adding \"%s\" event listener:', event, listener.name);\n    this.emitter.on(event, listener);\n  };\n  /**\n   * Disposes of any side-effects this interceptor has introduced.\n   */\n  Interceptor.prototype.dispose = function () {\n    var e_1, _a;\n    var _this = this;\n    var log = this.log.extend('dispose');\n    if (this.readyState === InterceptorReadyState.DISPOSED) {\n      log('cannot dispose, already disposed!');\n      return;\n    }\n    log('disposing the interceptor...');\n    this.readyState = InterceptorReadyState.DISPOSING;\n    if (!this.getInstance()) {\n      log('no interceptors running, skipping dispose...');\n      return;\n    }\n    // Delete the global symbol as soon as possible,\n    // indicating that the interceptor is no longer running.\n    this.clearInstance();\n    log('global symbol deleted:', getGlobalSymbol(this.symbol));\n    if (this.subscriptions.length > 0) {\n      log('disposing of %d subscriptions...', this.subscriptions.length);\n      try {\n        for (var _b = __values(this.subscriptions), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var dispose = _c.value;\n          dispose();\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      this.subscriptions = [];\n      log('disposed of all subscriptions!', this.subscriptions.length);\n    }\n    this.emitter.deactivate();\n    log('destroyed the listener!');\n    nextTick_1.nextTick(function () {\n      _this.readyState = InterceptorReadyState.DISPOSED;\n    });\n  };\n  Interceptor.prototype.getInstance = function () {\n    var _a;\n    var instance = getGlobalSymbol(this.symbol);\n    this.log('retrieved global instance:', (_a = instance === null || instance === void 0 ? void 0 : instance.constructor) === null || _a === void 0 ? void 0 : _a.name);\n    return instance;\n  };\n  Interceptor.prototype.setInstance = function () {\n    setGlobalSymbol(this.symbol, this);\n    this.log('set global instance!', this.symbol.description);\n  };\n  Interceptor.prototype.clearInstance = function () {\n    deleteGlobalSymbol(this.symbol);\n    this.log('cleared global instance!', this.symbol.description);\n  };\n  return Interceptor;\n}();\nexports.Interceptor = Interceptor;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAKA,SAAgBA,eAAe,CAAIC,MAAc;EAC/C;IACE;IACAC,UAAU,CAACD,MAAM,CAAC,IAAIE;EAAS;AAEnC;AALAC;AAOA,SAASC,eAAe,CAACJ,MAAc,EAAEK,KAAU;EACjD;EACAJ,UAAU,CAACD,MAAM,CAAC,GAAGK,KAAK;AAC5B;AAEA,SAAgBC,kBAAkB,CAACN,MAAc;EAC/C;EACA,OAAOC,UAAU,CAACD,MAAM,CAAC;AAC3B;AAHAG;AAKA,IAAYI,qBAMX;AAND,WAAYA,qBAAqB;EAC/BA,sCAAa;EACbA,8CAAqB;EACrBA,4CAAmB;EACnBA,gDAAuB;EACvBA,8CAAqB;AACvB,CAAC,EANWA,qBAAqB,GAArBJ,6BAAqB,KAArBA,6BAAqB;AAWjC;EAOE,qBAA6BH,MAAc;IAAd,WAAM,GAANA,MAAM;IACjC,IAAI,CAACQ,UAAU,GAAGD,qBAAqB,CAACE,IAAI;IAE5C,IAAI,CAACC,OAAO,GAAG,IAAIC,qCAAiB,EAAE;IACtC,IAAI,CAACC,aAAa,GAAG,EAAE;IACvB,IAAI,CAACC,GAAG,GAAGC,aAAK,CAACd,MAAM,CAACe,WAAY,CAAC;IAErC;IACA;IACA,IAAI,CAACL,OAAO,CAACM,eAAe,CAAC,CAAC,CAAC;IAE/B,IAAI,CAACH,GAAG,CAAC,iCAAiC,CAAC;EAC7C;EAEA;;;;EAIUI,sCAAgB,GAA1B;IACE,OAAO,IAAI;EACb,CAAC;EAED;;;;EAIOA,2BAAK,GAAZ;IAAA;IACE,IAAMJ,GAAG,GAAG,IAAI,CAACA,GAAG,CAACK,MAAM,CAAC,OAAO,CAAC;IACpCL,GAAG,CAAC,6BAA6B,CAAC;IAElC,IAAI,IAAI,CAACL,UAAU,KAAKD,qBAAqB,CAACY,OAAO,EAAE;MACrDN,GAAG,CAAC,8BAA8B,CAAC;MACnC;;IAGF,IAAMO,WAAW,GAAG,IAAI,CAACC,gBAAgB,EAAE;IAE3C,IAAI,CAACD,WAAW,EAAE;MAChBP,GAAG,CAAC,wDAAwD,CAAC;MAC7D;;IAGF,IAAI,CAACL,UAAU,GAAGD,qBAAqB,CAACe,QAAQ;IAEhD;IACA;IACA;IACA,IAAI,CAACZ,OAAO,CAACa,QAAQ,EAAE;IACvBV,GAAG,CAAC,uBAAuB,EAAE,IAAI,CAACH,OAAO,CAACF,UAAU,CAAC;IAErD;IACA;IACA;IACA,IAAMgB,eAAe,GAAG,IAAI,CAACC,WAAW,EAAE;IAE1C,IAAID,eAAe,EAAE;MACnBX,GAAG,CAAC,sCAAsC,CAAC;MAE3C;MACA,IAAI,CAACa,EAAE,GAAG,UAACC,KAAK,EAAEC,QAAQ;QACxBf,GAAG,CAAC,4BAA4B,EAAEc,KAAK,CAAC;QAExC;QACA;QACAH,eAAe,CAACd,OAAO,CAACmB,WAAW,CAACF,KAAK,EAAEC,QAAQ,CAAC;QAEpD;QACA;QACAE,KAAI,CAAClB,aAAa,CAACmB,IAAI,CAAC;UACtBP,eAAe,CAACd,OAAO,CAACsB,cAAc,CAACL,KAAK,EAAEC,QAAQ,CAAC;UACvDf,GAAG,CAAC,gCAAgC,EAAEc,KAAK,CAAC;QAC9C,CAAC,CAAC;MACJ,CAAC;MAEDM,mBAAQ,CAAC;QACPH,KAAI,CAACtB,UAAU,GAAGD,qBAAqB,CAACY,OAAO;MACjD,CAAC,CAAC;MAEF;;IAGFN,GAAG,CAAC,yDAAyD,CAAC;IAE9D;IACA,IAAI,CAACqB,KAAK,EAAE;IAEZ;IACA,IAAI,CAACC,WAAW,EAAE;IAElBF,mBAAQ,CAAC;MACPH,KAAI,CAACtB,UAAU,GAAGD,qBAAqB,CAACY,OAAO;IACjD,CAAC,CAAC;EACJ,CAAC;EAED;;;;;EAKUF,2BAAK,GAAf,aAAyB,CAAC;EAE1B;;;EAGOA,wBAAE,GAAT,UACEU,KAAY,EACZC,QAAyB;IAEzB,IAAMf,GAAG,GAAG,IAAI,CAACA,GAAG,CAACK,MAAM,CAAC,IAAI,CAAC;IAEjC,IACE,IAAI,CAACV,UAAU,KAAKD,qBAAqB,CAAC6B,SAAS,IACnD,IAAI,CAAC5B,UAAU,KAAKD,qBAAqB,CAAC8B,QAAQ,EAClD;MACAxB,GAAG,CAAC,4CAA4C,CAAC;MACjD;;IAGFA,GAAG,CAAC,6BAA6B,EAAEc,KAAK,EAAEC,QAAQ,CAACU,IAAI,CAAC;IAExD,IAAI,CAAC5B,OAAO,CAACgB,EAAE,CAACC,KAAK,EAAEC,QAAQ,CAAC;EAClC,CAAC;EAED;;;EAGOX,6BAAO,GAAd;;IAAA;IACE,IAAMJ,GAAG,GAAG,IAAI,CAACA,GAAG,CAACK,MAAM,CAAC,SAAS,CAAC;IAEtC,IAAI,IAAI,CAACV,UAAU,KAAKD,qBAAqB,CAAC8B,QAAQ,EAAE;MACtDxB,GAAG,CAAC,mCAAmC,CAAC;MACxC;;IAGFA,GAAG,CAAC,8BAA8B,CAAC;IACnC,IAAI,CAACL,UAAU,GAAGD,qBAAqB,CAAC6B,SAAS;IAEjD,IAAI,CAAC,IAAI,CAACX,WAAW,EAAE,EAAE;MACvBZ,GAAG,CAAC,8CAA8C,CAAC;MACnD;;IAGF;IACA;IACA,IAAI,CAAC0B,aAAa,EAAE;IAEpB1B,GAAG,CAAC,wBAAwB,EAAEd,eAAe,CAAC,IAAI,CAACC,MAAM,CAAC,CAAC;IAE3D,IAAI,IAAI,CAACY,aAAa,CAAC4B,MAAM,GAAG,CAAC,EAAE;MACjC3B,GAAG,CAAC,kCAAkC,EAAE,IAAI,CAACD,aAAa,CAAC4B,MAAM,CAAC;;QAElE,KAAsB,sBAAI,CAAC5B,aAAa,6CAAE;UAArC,IAAM6B,OAAO;UAChBA,OAAO,EAAE;;;;;;;;;;;;;MAGX,IAAI,CAAC7B,aAAa,GAAG,EAAE;MAEvBC,GAAG,CAAC,gCAAgC,EAAE,IAAI,CAACD,aAAa,CAAC4B,MAAM,CAAC;;IAGlE,IAAI,CAAC9B,OAAO,CAACgC,UAAU,EAAE;IACzB7B,GAAG,CAAC,yBAAyB,CAAC;IAE9BoB,mBAAQ,CAAC;MACPH,KAAI,CAACtB,UAAU,GAAGD,qBAAqB,CAAC8B,QAAQ;IAClD,CAAC,CAAC;EACJ,CAAC;EAEOpB,iCAAW,GAAnB;;IACE,IAAM0B,QAAQ,GAAG5C,eAAe,CAAO,IAAI,CAACC,MAAM,CAAC;IACnD,IAAI,CAACa,GAAG,CAAC,4BAA4B,EAAE,cAAQ,aAAR8B,QAAQ,uBAARA,QAAQ,CAAEC,WAAW,0CAAEN,IAAI,CAAC;IACnE,OAAOK,QAAQ;EACjB,CAAC;EAEO1B,iCAAW,GAAnB;IACEb,eAAe,CAAC,IAAI,CAACJ,MAAM,EAAE,IAAI,CAAC;IAClC,IAAI,CAACa,GAAG,CAAC,sBAAsB,EAAE,IAAI,CAACb,MAAM,CAACe,WAAW,CAAC;EAC3D,CAAC;EAEOE,mCAAa,GAArB;IACEX,kBAAkB,CAAC,IAAI,CAACN,MAAM,CAAC;IAC/B,IAAI,CAACa,GAAG,CAAC,0BAA0B,EAAE,IAAI,CAACb,MAAM,CAACe,WAAW,CAAC;EAC/D,CAAC;EACH,kBAAC;AAAD,CAAC,EA9LD;AAAaZ","names":["getGlobalSymbol","symbol","globalThis","undefined","exports","setGlobalSymbol","value","deleteGlobalSymbol","InterceptorReadyState","readyState","IDLE","emitter","AsyncEventEmitter_1","subscriptions","log","debug_1","description","setMaxListeners","Interceptor","extend","APPLIED","shouldApply","checkEnvironment","APPLYING","activate","runningInstance","getInstance","on","event","listener","addListener","_this","push","removeListener","nextTick_1","setup","setInstance","DISPOSING","DISPOSED","name","clearInstance","length","dispose","deactivate","instance","constructor"],"sources":["/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/@mswjs/interceptors/src/Interceptor.ts"],"sourcesContent":["import { Debugger, debug } from 'debug'\nimport { AsyncEventEmitter } from './utils/AsyncEventEmitter'\nimport { nextTick } from './utils/nextTick'\n\nexport type InterceptorEventMap = Record<string, (...args: any[]) => void>\nexport type InterceptorSubscription = () => void\n\nexport function getGlobalSymbol<V>(symbol: Symbol): V | undefined {\n  return (\n    // @ts-ignore https://github.com/Microsoft/TypeScript/issues/24587\n    globalThis[symbol] || undefined\n  )\n}\n\nfunction setGlobalSymbol(symbol: Symbol, value: any): void {\n  // @ts-ignore\n  globalThis[symbol] = value\n}\n\nexport function deleteGlobalSymbol(symbol: Symbol): void {\n  // @ts-ignore\n  delete globalThis[symbol]\n}\n\nexport enum InterceptorReadyState {\n  IDLE = 'IDLE',\n  APPLYING = 'APPLYING',\n  APPLIED = 'APPLIED',\n  DISPOSING = 'DISPOSING',\n  DISPOSED = 'DISPOSED',\n}\n\nexport type ExtractEventNames<EventMap extends Record<string, any>> =\n  EventMap extends Record<infer EventName, any> ? EventName : never\n\nexport class Interceptor<EventMap extends InterceptorEventMap> {\n  protected emitter: AsyncEventEmitter<EventMap>\n  protected subscriptions: InterceptorSubscription[]\n  protected log: Debugger\n\n  public readyState: InterceptorReadyState\n\n  constructor(private readonly symbol: Symbol) {\n    this.readyState = InterceptorReadyState.IDLE\n\n    this.emitter = new AsyncEventEmitter()\n    this.subscriptions = []\n    this.log = debug(symbol.description!)\n\n    // Do not limit the maximum number of listeners\n    // so not to limit the maximum amount of parallel events emitted.\n    this.emitter.setMaxListeners(0)\n\n    this.log('constructing the interceptor...')\n  }\n\n  /**\n   * Determine if this interceptor can be applied\n   * in the current environment.\n   */\n  protected checkEnvironment(): boolean {\n    return true\n  }\n\n  /**\n   * Apply this interceptor to the current process.\n   * Returns an already running interceptor instance if it's present.\n   */\n  public apply(): void {\n    const log = this.log.extend('apply')\n    log('applying the interceptor...')\n\n    if (this.readyState === InterceptorReadyState.APPLIED) {\n      log('intercepted already applied!')\n      return\n    }\n\n    const shouldApply = this.checkEnvironment()\n\n    if (!shouldApply) {\n      log('the interceptor cannot be applied in this environment!')\n      return\n    }\n\n    this.readyState = InterceptorReadyState.APPLYING\n\n    // Always activate the emitter when applying the interceptor.\n    // This will ensure the interceptor can process events after it's\n    // been disposed and re-applied again (it may be a singleton).\n    this.emitter.activate()\n    log('activated the emiter!', this.emitter.readyState)\n\n    // Whenever applying a new interceptor, check if it hasn't been applied already.\n    // This enables to apply the same interceptor multiple times, for example from a different\n    // interceptor, only proxying events but keeping the stubs in a single place.\n    const runningInstance = this.getInstance()\n\n    if (runningInstance) {\n      log('found a running instance, reusing...')\n\n      // Proxy any listeners you set on this instance to the running instance.\n      this.on = (event, listener) => {\n        log('proxying the \"%s\" listener', event)\n\n        // Add listeners to the running instance so they appear\n        // at the top of the event listeners list and are executed first.\n        runningInstance.emitter.addListener(event, listener)\n\n        // Ensure that once this interceptor instance is disposed,\n        // it removes all listeners it has appended to the running interceptor instance.\n        this.subscriptions.push(() => {\n          runningInstance.emitter.removeListener(event, listener)\n          log('removed proxied \"%s\" listener!', event)\n        })\n      }\n\n      nextTick(() => {\n        this.readyState = InterceptorReadyState.APPLIED\n      })\n\n      return\n    }\n\n    log('no running instance found, setting up a new instance...')\n\n    // Setup the interceptor.\n    this.setup()\n\n    // Store the newly applied interceptor instance globally.\n    this.setInstance()\n\n    nextTick(() => {\n      this.readyState = InterceptorReadyState.APPLIED\n    })\n  }\n\n  /**\n   * Setup the module augments and stubs necessary for this interceptor.\n   * This method is not run if there's a running interceptor instance\n   * to prevent instantiating an interceptor multiple times.\n   */\n  protected setup(): void {}\n\n  /**\n   * Listen to the interceptor's public events.\n   */\n  public on<Event extends ExtractEventNames<EventMap>>(\n    event: Event,\n    listener: EventMap[Event]\n  ): void {\n    const log = this.log.extend('on')\n\n    if (\n      this.readyState === InterceptorReadyState.DISPOSING ||\n      this.readyState === InterceptorReadyState.DISPOSED\n    ) {\n      log('cannot listen to events, already disposed!')\n      return\n    }\n\n    log('adding \"%s\" event listener:', event, listener.name)\n\n    this.emitter.on(event, listener)\n  }\n\n  /**\n   * Disposes of any side-effects this interceptor has introduced.\n   */\n  public dispose(): void {\n    const log = this.log.extend('dispose')\n\n    if (this.readyState === InterceptorReadyState.DISPOSED) {\n      log('cannot dispose, already disposed!')\n      return\n    }\n\n    log('disposing the interceptor...')\n    this.readyState = InterceptorReadyState.DISPOSING\n\n    if (!this.getInstance()) {\n      log('no interceptors running, skipping dispose...')\n      return\n    }\n\n    // Delete the global symbol as soon as possible,\n    // indicating that the interceptor is no longer running.\n    this.clearInstance()\n\n    log('global symbol deleted:', getGlobalSymbol(this.symbol))\n\n    if (this.subscriptions.length > 0) {\n      log('disposing of %d subscriptions...', this.subscriptions.length)\n\n      for (const dispose of this.subscriptions) {\n        dispose()\n      }\n\n      this.subscriptions = []\n\n      log('disposed of all subscriptions!', this.subscriptions.length)\n    }\n\n    this.emitter.deactivate()\n    log('destroyed the listener!')\n\n    nextTick(() => {\n      this.readyState = InterceptorReadyState.DISPOSED\n    })\n  }\n\n  private getInstance(): this | undefined {\n    const instance = getGlobalSymbol<this>(this.symbol)\n    this.log('retrieved global instance:', instance?.constructor?.name)\n    return instance\n  }\n\n  private setInstance(): void {\n    setGlobalSymbol(this.symbol, this)\n    this.log('set global instance!', this.symbol.description)\n  }\n\n  private clearInstance(): void {\n    deleteGlobalSymbol(this.symbol)\n    this.log('cleared global instance!', this.symbol.description)\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}