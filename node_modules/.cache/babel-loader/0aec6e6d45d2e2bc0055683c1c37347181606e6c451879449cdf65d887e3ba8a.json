{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.separateOperations = separateOperations;\nvar _kinds = require('../language/kinds.js');\nvar _visitor = require('../language/visitor.js');\n\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\nfunction separateOperations(documentAST) {\n  const operations = [];\n  const depGraph = Object.create(null); // Populate metadata and build a dependency graph.\n\n  for (const definitionNode of documentAST.definitions) {\n    switch (definitionNode.kind) {\n      case _kinds.Kind.OPERATION_DEFINITION:\n        operations.push(definitionNode);\n        break;\n      case _kinds.Kind.FRAGMENT_DEFINITION:\n        depGraph[definitionNode.name.value] = collectDependencies(definitionNode.selectionSet);\n        break;\n      default: // ignore non-executable definitions\n    }\n  } // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n  const separatedDocumentASTs = Object.create(null);\n  for (const operation of operations) {\n    const dependencies = new Set();\n    for (const fragmentName of collectDependencies(operation.selectionSet)) {\n      collectTransitiveDependencies(dependencies, depGraph, fragmentName);\n    } // Provides the empty string for anonymous operations.\n\n    const operationName = operation.name ? operation.name.value : ''; // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: _kinds.Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(node => node === operation || node.kind === _kinds.Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value))\n    };\n  }\n  return separatedDocumentASTs;\n}\n\n// From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  if (!collected.has(fromName)) {\n    collected.add(fromName);\n    const immediateDeps = depGraph[fromName];\n    if (immediateDeps !== undefined) {\n      for (const toName of immediateDeps) {\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}\nfunction collectDependencies(selectionSet) {\n  const dependencies = [];\n  (0, _visitor.visit)(selectionSet, {\n    FragmentSpread(node) {\n      dependencies.push(node.name.value);\n    }\n  });\n  return dependencies;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","separateOperations","_kinds","require","_visitor","documentAST","operations","depGraph","create","definitionNode","definitions","kind","Kind","OPERATION_DEFINITION","push","FRAGMENT_DEFINITION","name","collectDependencies","selectionSet","separatedDocumentASTs","operation","dependencies","Set","fragmentName","collectTransitiveDependencies","operationName","DOCUMENT","filter","node","has","collected","fromName","add","immediateDeps","undefined","toName","visit","FragmentSpread"],"sources":["/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/graphql/utilities/separateOperations.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.separateOperations = separateOperations;\n\nvar _kinds = require('../language/kinds.js');\n\nvar _visitor = require('../language/visitor.js');\n\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\nfunction separateOperations(documentAST) {\n  const operations = [];\n  const depGraph = Object.create(null); // Populate metadata and build a dependency graph.\n\n  for (const definitionNode of documentAST.definitions) {\n    switch (definitionNode.kind) {\n      case _kinds.Kind.OPERATION_DEFINITION:\n        operations.push(definitionNode);\n        break;\n\n      case _kinds.Kind.FRAGMENT_DEFINITION:\n        depGraph[definitionNode.name.value] = collectDependencies(\n          definitionNode.selectionSet,\n        );\n        break;\n\n      default: // ignore non-executable definitions\n    }\n  } // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n  const separatedDocumentASTs = Object.create(null);\n\n  for (const operation of operations) {\n    const dependencies = new Set();\n\n    for (const fragmentName of collectDependencies(operation.selectionSet)) {\n      collectTransitiveDependencies(dependencies, depGraph, fragmentName);\n    } // Provides the empty string for anonymous operations.\n\n    const operationName = operation.name ? operation.name.value : ''; // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: _kinds.Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(\n        (node) =>\n          node === operation ||\n          (node.kind === _kinds.Kind.FRAGMENT_DEFINITION &&\n            dependencies.has(node.name.value)),\n      ),\n    };\n  }\n\n  return separatedDocumentASTs;\n}\n\n// From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  if (!collected.has(fromName)) {\n    collected.add(fromName);\n    const immediateDeps = depGraph[fromName];\n\n    if (immediateDeps !== undefined) {\n      for (const toName of immediateDeps) {\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}\n\nfunction collectDependencies(selectionSet) {\n  const dependencies = [];\n  (0, _visitor.visit)(selectionSet, {\n    FragmentSpread(node) {\n      dependencies.push(node.name.value);\n    },\n  });\n  return dependencies;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}