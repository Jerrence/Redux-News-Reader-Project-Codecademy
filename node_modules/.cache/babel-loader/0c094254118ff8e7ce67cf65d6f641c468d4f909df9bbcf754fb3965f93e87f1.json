{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.PossibleFragmentSpreadsRule = PossibleFragmentSpreadsRule;\nvar _inspect = require('../../jsutils/inspect.js');\nvar _GraphQLError = require('../../error/GraphQLError.js');\nvar _definition = require('../../type/definition.js');\nvar _typeComparators = require('../../utilities/typeComparators.js');\nvar _typeFromAST = require('../../utilities/typeFromAST.js');\n\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\nfunction PossibleFragmentSpreadsRule(context) {\n  return {\n    InlineFragment(node) {\n      const fragType = context.getType();\n      const parentType = context.getParentType();\n      if ((0, _definition.isCompositeType)(fragType) && (0, _definition.isCompositeType)(parentType) && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {\n        const parentTypeStr = (0, _inspect.inspect)(parentType);\n        const fragTypeStr = (0, _inspect.inspect)(fragType);\n        context.reportError(new _GraphQLError.GraphQLError(`Fragment cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`, {\n          nodes: node\n        }));\n      }\n    },\n    FragmentSpread(node) {\n      const fragName = node.name.value;\n      const fragType = getFragmentType(context, fragName);\n      const parentType = context.getParentType();\n      if (fragType && parentType && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {\n        const parentTypeStr = (0, _inspect.inspect)(parentType);\n        const fragTypeStr = (0, _inspect.inspect)(fragType);\n        context.reportError(new _GraphQLError.GraphQLError(`Fragment \"${fragName}\" cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`, {\n          nodes: node\n        }));\n      }\n    }\n  };\n}\nfunction getFragmentType(context, name) {\n  const frag = context.getFragment(name);\n  if (frag) {\n    const type = (0, _typeFromAST.typeFromAST)(context.getSchema(), frag.typeCondition);\n    if ((0, _definition.isCompositeType)(type)) {\n      return type;\n    }\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","PossibleFragmentSpreadsRule","_inspect","require","_GraphQLError","_definition","_typeComparators","_typeFromAST","context","InlineFragment","node","fragType","getType","parentType","getParentType","isCompositeType","doTypesOverlap","getSchema","parentTypeStr","inspect","fragTypeStr","reportError","GraphQLError","nodes","FragmentSpread","fragName","name","getFragmentType","frag","getFragment","type","typeFromAST","typeCondition"],"sources":["/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.PossibleFragmentSpreadsRule = PossibleFragmentSpreadsRule;\n\nvar _inspect = require('../../jsutils/inspect.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _definition = require('../../type/definition.js');\n\nvar _typeComparators = require('../../utilities/typeComparators.js');\n\nvar _typeFromAST = require('../../utilities/typeFromAST.js');\n\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\nfunction PossibleFragmentSpreadsRule(context) {\n  return {\n    InlineFragment(node) {\n      const fragType = context.getType();\n      const parentType = context.getParentType();\n\n      if (\n        (0, _definition.isCompositeType)(fragType) &&\n        (0, _definition.isCompositeType)(parentType) &&\n        !(0, _typeComparators.doTypesOverlap)(\n          context.getSchema(),\n          fragType,\n          parentType,\n        )\n      ) {\n        const parentTypeStr = (0, _inspect.inspect)(parentType);\n        const fragTypeStr = (0, _inspect.inspect)(fragType);\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Fragment cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    FragmentSpread(node) {\n      const fragName = node.name.value;\n      const fragType = getFragmentType(context, fragName);\n      const parentType = context.getParentType();\n\n      if (\n        fragType &&\n        parentType &&\n        !(0, _typeComparators.doTypesOverlap)(\n          context.getSchema(),\n          fragType,\n          parentType,\n        )\n      ) {\n        const parentTypeStr = (0, _inspect.inspect)(parentType);\n        const fragTypeStr = (0, _inspect.inspect)(fragType);\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Fragment \"${fragName}\" cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\nfunction getFragmentType(context, name) {\n  const frag = context.getFragment(name);\n\n  if (frag) {\n    const type = (0, _typeFromAST.typeFromAST)(\n      context.getSchema(),\n      frag.typeCondition,\n    );\n\n    if ((0, _definition.isCompositeType)(type)) {\n      return type;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}