{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.TypeInfo = void 0;\nexports.visitWithTypeInfo = visitWithTypeInfo;\nvar _ast = require('../language/ast.js');\nvar _kinds = require('../language/kinds.js');\nvar _visitor = require('../language/visitor.js');\nvar _definition = require('../type/definition.js');\nvar _introspection = require('../type/introspection.js');\nvar _typeFromAST = require('./typeFromAST.js');\n\n/**\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n * of the current field and type definitions at any point in a GraphQL document\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n */\nclass TypeInfo {\n  constructor(schema,\n  /**\n   * Initial type may be provided in rare cases to facilitate traversals\n   *  beginning somewhere other than documents.\n   */\n  initialType, /** @deprecated will be removed in 17.0.0 */\n  getFieldDefFn) {\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._defaultValueStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;\n    if (initialType) {\n      if ((0, _definition.isInputType)(initialType)) {\n        this._inputTypeStack.push(initialType);\n      }\n      if ((0, _definition.isCompositeType)(initialType)) {\n        this._parentTypeStack.push(initialType);\n      }\n      if ((0, _definition.isOutputType)(initialType)) {\n        this._typeStack.push(initialType);\n      }\n    }\n  }\n  get [Symbol.toStringTag]() {\n    return 'TypeInfo';\n  }\n  getType() {\n    if (this._typeStack.length > 0) {\n      return this._typeStack[this._typeStack.length - 1];\n    }\n  }\n  getParentType() {\n    if (this._parentTypeStack.length > 0) {\n      return this._parentTypeStack[this._parentTypeStack.length - 1];\n    }\n  }\n  getInputType() {\n    if (this._inputTypeStack.length > 0) {\n      return this._inputTypeStack[this._inputTypeStack.length - 1];\n    }\n  }\n  getParentInputType() {\n    if (this._inputTypeStack.length > 1) {\n      return this._inputTypeStack[this._inputTypeStack.length - 2];\n    }\n  }\n  getFieldDef() {\n    if (this._fieldDefStack.length > 0) {\n      return this._fieldDefStack[this._fieldDefStack.length - 1];\n    }\n  }\n  getDefaultValue() {\n    if (this._defaultValueStack.length > 0) {\n      return this._defaultValueStack[this._defaultValueStack.length - 1];\n    }\n  }\n  getDirective() {\n    return this._directive;\n  }\n  getArgument() {\n    return this._argument;\n  }\n  getEnumValue() {\n    return this._enumValue;\n  }\n  enter(node) {\n    const schema = this._schema; // Note: many of the types below are explicitly typed as \"unknown\" to drop\n    // any assumptions of a valid schema to ensure runtime types are properly\n    // checked before continuing since TypeInfo is used as part of validation\n    // which occurs before guarantees of schema and document validity.\n\n    switch (node.kind) {\n      case _kinds.Kind.SELECTION_SET:\n        {\n          const namedType = (0, _definition.getNamedType)(this.getType());\n          this._parentTypeStack.push((0, _definition.isCompositeType)(namedType) ? namedType : undefined);\n          break;\n        }\n      case _kinds.Kind.FIELD:\n        {\n          const parentType = this.getParentType();\n          let fieldDef;\n          let fieldType;\n          if (parentType) {\n            fieldDef = this._getFieldDef(schema, parentType, node);\n            if (fieldDef) {\n              fieldType = fieldDef.type;\n            }\n          }\n          this._fieldDefStack.push(fieldDef);\n          this._typeStack.push((0, _definition.isOutputType)(fieldType) ? fieldType : undefined);\n          break;\n        }\n      case _kinds.Kind.DIRECTIVE:\n        this._directive = schema.getDirective(node.name.value);\n        break;\n      case _kinds.Kind.OPERATION_DEFINITION:\n        {\n          const rootType = schema.getRootType(node.operation);\n          this._typeStack.push((0, _definition.isObjectType)(rootType) ? rootType : undefined);\n          break;\n        }\n      case _kinds.Kind.INLINE_FRAGMENT:\n      case _kinds.Kind.FRAGMENT_DEFINITION:\n        {\n          const typeConditionAST = node.typeCondition;\n          const outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST) : (0, _definition.getNamedType)(this.getType());\n          this._typeStack.push((0, _definition.isOutputType)(outputType) ? outputType : undefined);\n          break;\n        }\n      case _kinds.Kind.VARIABLE_DEFINITION:\n        {\n          const inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);\n          this._inputTypeStack.push((0, _definition.isInputType)(inputType) ? inputType : undefined);\n          break;\n        }\n      case _kinds.Kind.ARGUMENT:\n        {\n          var _this$getDirective;\n          let argDef;\n          let argType;\n          const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();\n          if (fieldOrDirective) {\n            argDef = fieldOrDirective.args.find(arg => arg.name === node.name.value);\n            if (argDef) {\n              argType = argDef.type;\n            }\n          }\n          this._argument = argDef;\n          this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);\n          this._inputTypeStack.push((0, _definition.isInputType)(argType) ? argType : undefined);\n          break;\n        }\n      case _kinds.Kind.LIST:\n        {\n          const listType = (0, _definition.getNullableType)(this.getInputType());\n          const itemType = (0, _definition.isListType)(listType) ? listType.ofType : listType; // List positions never have a default value.\n\n          this._defaultValueStack.push(undefined);\n          this._inputTypeStack.push((0, _definition.isInputType)(itemType) ? itemType : undefined);\n          break;\n        }\n      case _kinds.Kind.OBJECT_FIELD:\n        {\n          const objectType = (0, _definition.getNamedType)(this.getInputType());\n          let inputFieldType;\n          let inputField;\n          if ((0, _definition.isInputObjectType)(objectType)) {\n            inputField = objectType.getFields()[node.name.value];\n            if (inputField) {\n              inputFieldType = inputField.type;\n            }\n          }\n          this._defaultValueStack.push(inputField ? inputField.defaultValue : undefined);\n          this._inputTypeStack.push((0, _definition.isInputType)(inputFieldType) ? inputFieldType : undefined);\n          break;\n        }\n      case _kinds.Kind.ENUM:\n        {\n          const enumType = (0, _definition.getNamedType)(this.getInputType());\n          let enumValue;\n          if ((0, _definition.isEnumType)(enumType)) {\n            enumValue = enumType.getValue(node.value);\n          }\n          this._enumValue = enumValue;\n          break;\n        }\n      default: // Ignore other nodes\n    }\n  }\n\n  leave(node) {\n    switch (node.kind) {\n      case _kinds.Kind.SELECTION_SET:\n        this._parentTypeStack.pop();\n        break;\n      case _kinds.Kind.FIELD:\n        this._fieldDefStack.pop();\n        this._typeStack.pop();\n        break;\n      case _kinds.Kind.DIRECTIVE:\n        this._directive = null;\n        break;\n      case _kinds.Kind.OPERATION_DEFINITION:\n      case _kinds.Kind.INLINE_FRAGMENT:\n      case _kinds.Kind.FRAGMENT_DEFINITION:\n        this._typeStack.pop();\n        break;\n      case _kinds.Kind.VARIABLE_DEFINITION:\n        this._inputTypeStack.pop();\n        break;\n      case _kinds.Kind.ARGUMENT:\n        this._argument = null;\n        this._defaultValueStack.pop();\n        this._inputTypeStack.pop();\n        break;\n      case _kinds.Kind.LIST:\n      case _kinds.Kind.OBJECT_FIELD:\n        this._defaultValueStack.pop();\n        this._inputTypeStack.pop();\n        break;\n      case _kinds.Kind.ENUM:\n        this._enumValue = null;\n        break;\n      default: // Ignore other nodes\n    }\n  }\n}\n\nexports.TypeInfo = TypeInfo;\n\n/**\n * Not exactly the same as the executor's definition of getFieldDef, in this\n * statically evaluated environment we do not always have an Object type,\n * and need to handle Interface and Union types.\n */\nfunction getFieldDef(schema, parentType, fieldNode) {\n  const name = fieldNode.name.value;\n  if (name === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return _introspection.SchemaMetaFieldDef;\n  }\n  if (name === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return _introspection.TypeMetaFieldDef;\n  }\n  if (name === _introspection.TypeNameMetaFieldDef.name && (0, _definition.isCompositeType)(parentType)) {\n    return _introspection.TypeNameMetaFieldDef;\n  }\n  if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {\n    return parentType.getFields()[name];\n  }\n}\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\n\nfunction visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      const node = args[0];\n      typeInfo.enter(node);\n      const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).enter;\n      if (fn) {\n        const result = fn.apply(visitor, args);\n        if (result !== undefined) {\n          typeInfo.leave(node);\n          if ((0, _ast.isNode)(result)) {\n            typeInfo.enter(result);\n          }\n        }\n        return result;\n      }\n    },\n    leave() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      const node = args[0];\n      const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).leave;\n      let result;\n      if (fn) {\n        result = fn.apply(visitor, args);\n      }\n      typeInfo.leave(node);\n      return result;\n    }\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","TypeInfo","visitWithTypeInfo","_ast","require","_kinds","_visitor","_definition","_introspection","_typeFromAST","constructor","schema","initialType","getFieldDefFn","_schema","_typeStack","_parentTypeStack","_inputTypeStack","_fieldDefStack","_defaultValueStack","_directive","_argument","_enumValue","_getFieldDef","getFieldDef","isInputType","push","isCompositeType","isOutputType","Symbol","toStringTag","getType","length","getParentType","getInputType","getParentInputType","getDefaultValue","getDirective","getArgument","getEnumValue","enter","node","kind","Kind","SELECTION_SET","namedType","getNamedType","undefined","FIELD","parentType","fieldDef","fieldType","type","DIRECTIVE","name","OPERATION_DEFINITION","rootType","getRootType","operation","isObjectType","INLINE_FRAGMENT","FRAGMENT_DEFINITION","typeConditionAST","typeCondition","outputType","typeFromAST","VARIABLE_DEFINITION","inputType","ARGUMENT","_this$getDirective","argDef","argType","fieldOrDirective","args","find","arg","defaultValue","LIST","listType","getNullableType","itemType","isListType","ofType","OBJECT_FIELD","objectType","inputFieldType","inputField","isInputObjectType","getFields","ENUM","enumType","enumValue","isEnumType","getValue","leave","pop","fieldNode","SchemaMetaFieldDef","getQueryType","TypeMetaFieldDef","TypeNameMetaFieldDef","isInterfaceType","typeInfo","visitor","fn","getEnterLeaveForKind","result","apply","isNode"],"sources":["/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/graphql/utilities/TypeInfo.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.TypeInfo = void 0;\nexports.visitWithTypeInfo = visitWithTypeInfo;\n\nvar _ast = require('../language/ast.js');\n\nvar _kinds = require('../language/kinds.js');\n\nvar _visitor = require('../language/visitor.js');\n\nvar _definition = require('../type/definition.js');\n\nvar _introspection = require('../type/introspection.js');\n\nvar _typeFromAST = require('./typeFromAST.js');\n\n/**\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n * of the current field and type definitions at any point in a GraphQL document\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n */\nclass TypeInfo {\n  constructor(\n    schema,\n    /**\n     * Initial type may be provided in rare cases to facilitate traversals\n     *  beginning somewhere other than documents.\n     */\n    initialType,\n    /** @deprecated will be removed in 17.0.0 */\n    getFieldDefFn,\n  ) {\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._defaultValueStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef =\n      getFieldDefFn !== null && getFieldDefFn !== void 0\n        ? getFieldDefFn\n        : getFieldDef;\n\n    if (initialType) {\n      if ((0, _definition.isInputType)(initialType)) {\n        this._inputTypeStack.push(initialType);\n      }\n\n      if ((0, _definition.isCompositeType)(initialType)) {\n        this._parentTypeStack.push(initialType);\n      }\n\n      if ((0, _definition.isOutputType)(initialType)) {\n        this._typeStack.push(initialType);\n      }\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'TypeInfo';\n  }\n\n  getType() {\n    if (this._typeStack.length > 0) {\n      return this._typeStack[this._typeStack.length - 1];\n    }\n  }\n\n  getParentType() {\n    if (this._parentTypeStack.length > 0) {\n      return this._parentTypeStack[this._parentTypeStack.length - 1];\n    }\n  }\n\n  getInputType() {\n    if (this._inputTypeStack.length > 0) {\n      return this._inputTypeStack[this._inputTypeStack.length - 1];\n    }\n  }\n\n  getParentInputType() {\n    if (this._inputTypeStack.length > 1) {\n      return this._inputTypeStack[this._inputTypeStack.length - 2];\n    }\n  }\n\n  getFieldDef() {\n    if (this._fieldDefStack.length > 0) {\n      return this._fieldDefStack[this._fieldDefStack.length - 1];\n    }\n  }\n\n  getDefaultValue() {\n    if (this._defaultValueStack.length > 0) {\n      return this._defaultValueStack[this._defaultValueStack.length - 1];\n    }\n  }\n\n  getDirective() {\n    return this._directive;\n  }\n\n  getArgument() {\n    return this._argument;\n  }\n\n  getEnumValue() {\n    return this._enumValue;\n  }\n\n  enter(node) {\n    const schema = this._schema; // Note: many of the types below are explicitly typed as \"unknown\" to drop\n    // any assumptions of a valid schema to ensure runtime types are properly\n    // checked before continuing since TypeInfo is used as part of validation\n    // which occurs before guarantees of schema and document validity.\n\n    switch (node.kind) {\n      case _kinds.Kind.SELECTION_SET: {\n        const namedType = (0, _definition.getNamedType)(this.getType());\n\n        this._parentTypeStack.push(\n          (0, _definition.isCompositeType)(namedType) ? namedType : undefined,\n        );\n\n        break;\n      }\n\n      case _kinds.Kind.FIELD: {\n        const parentType = this.getParentType();\n        let fieldDef;\n        let fieldType;\n\n        if (parentType) {\n          fieldDef = this._getFieldDef(schema, parentType, node);\n\n          if (fieldDef) {\n            fieldType = fieldDef.type;\n          }\n        }\n\n        this._fieldDefStack.push(fieldDef);\n\n        this._typeStack.push(\n          (0, _definition.isOutputType)(fieldType) ? fieldType : undefined,\n        );\n\n        break;\n      }\n\n      case _kinds.Kind.DIRECTIVE:\n        this._directive = schema.getDirective(node.name.value);\n        break;\n\n      case _kinds.Kind.OPERATION_DEFINITION: {\n        const rootType = schema.getRootType(node.operation);\n\n        this._typeStack.push(\n          (0, _definition.isObjectType)(rootType) ? rootType : undefined,\n        );\n\n        break;\n      }\n\n      case _kinds.Kind.INLINE_FRAGMENT:\n      case _kinds.Kind.FRAGMENT_DEFINITION: {\n        const typeConditionAST = node.typeCondition;\n        const outputType = typeConditionAST\n          ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST)\n          : (0, _definition.getNamedType)(this.getType());\n\n        this._typeStack.push(\n          (0, _definition.isOutputType)(outputType) ? outputType : undefined,\n        );\n\n        break;\n      }\n\n      case _kinds.Kind.VARIABLE_DEFINITION: {\n        const inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);\n\n        this._inputTypeStack.push(\n          (0, _definition.isInputType)(inputType) ? inputType : undefined,\n        );\n\n        break;\n      }\n\n      case _kinds.Kind.ARGUMENT: {\n        var _this$getDirective;\n\n        let argDef;\n        let argType;\n        const fieldOrDirective =\n          (_this$getDirective = this.getDirective()) !== null &&\n          _this$getDirective !== void 0\n            ? _this$getDirective\n            : this.getFieldDef();\n\n        if (fieldOrDirective) {\n          argDef = fieldOrDirective.args.find(\n            (arg) => arg.name === node.name.value,\n          );\n\n          if (argDef) {\n            argType = argDef.type;\n          }\n        }\n\n        this._argument = argDef;\n\n        this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);\n\n        this._inputTypeStack.push(\n          (0, _definition.isInputType)(argType) ? argType : undefined,\n        );\n\n        break;\n      }\n\n      case _kinds.Kind.LIST: {\n        const listType = (0, _definition.getNullableType)(this.getInputType());\n        const itemType = (0, _definition.isListType)(listType)\n          ? listType.ofType\n          : listType; // List positions never have a default value.\n\n        this._defaultValueStack.push(undefined);\n\n        this._inputTypeStack.push(\n          (0, _definition.isInputType)(itemType) ? itemType : undefined,\n        );\n\n        break;\n      }\n\n      case _kinds.Kind.OBJECT_FIELD: {\n        const objectType = (0, _definition.getNamedType)(this.getInputType());\n        let inputFieldType;\n        let inputField;\n\n        if ((0, _definition.isInputObjectType)(objectType)) {\n          inputField = objectType.getFields()[node.name.value];\n\n          if (inputField) {\n            inputFieldType = inputField.type;\n          }\n        }\n\n        this._defaultValueStack.push(\n          inputField ? inputField.defaultValue : undefined,\n        );\n\n        this._inputTypeStack.push(\n          (0, _definition.isInputType)(inputFieldType)\n            ? inputFieldType\n            : undefined,\n        );\n\n        break;\n      }\n\n      case _kinds.Kind.ENUM: {\n        const enumType = (0, _definition.getNamedType)(this.getInputType());\n        let enumValue;\n\n        if ((0, _definition.isEnumType)(enumType)) {\n          enumValue = enumType.getValue(node.value);\n        }\n\n        this._enumValue = enumValue;\n        break;\n      }\n\n      default: // Ignore other nodes\n    }\n  }\n\n  leave(node) {\n    switch (node.kind) {\n      case _kinds.Kind.SELECTION_SET:\n        this._parentTypeStack.pop();\n\n        break;\n\n      case _kinds.Kind.FIELD:\n        this._fieldDefStack.pop();\n\n        this._typeStack.pop();\n\n        break;\n\n      case _kinds.Kind.DIRECTIVE:\n        this._directive = null;\n        break;\n\n      case _kinds.Kind.OPERATION_DEFINITION:\n      case _kinds.Kind.INLINE_FRAGMENT:\n      case _kinds.Kind.FRAGMENT_DEFINITION:\n        this._typeStack.pop();\n\n        break;\n\n      case _kinds.Kind.VARIABLE_DEFINITION:\n        this._inputTypeStack.pop();\n\n        break;\n\n      case _kinds.Kind.ARGUMENT:\n        this._argument = null;\n\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case _kinds.Kind.LIST:\n      case _kinds.Kind.OBJECT_FIELD:\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case _kinds.Kind.ENUM:\n        this._enumValue = null;\n        break;\n\n      default: // Ignore other nodes\n    }\n  }\n}\n\nexports.TypeInfo = TypeInfo;\n\n/**\n * Not exactly the same as the executor's definition of getFieldDef, in this\n * statically evaluated environment we do not always have an Object type,\n * and need to handle Interface and Union types.\n */\nfunction getFieldDef(schema, parentType, fieldNode) {\n  const name = fieldNode.name.value;\n\n  if (\n    name === _introspection.SchemaMetaFieldDef.name &&\n    schema.getQueryType() === parentType\n  ) {\n    return _introspection.SchemaMetaFieldDef;\n  }\n\n  if (\n    name === _introspection.TypeMetaFieldDef.name &&\n    schema.getQueryType() === parentType\n  ) {\n    return _introspection.TypeMetaFieldDef;\n  }\n\n  if (\n    name === _introspection.TypeNameMetaFieldDef.name &&\n    (0, _definition.isCompositeType)(parentType)\n  ) {\n    return _introspection.TypeNameMetaFieldDef;\n  }\n\n  if (\n    (0, _definition.isObjectType)(parentType) ||\n    (0, _definition.isInterfaceType)(parentType)\n  ) {\n    return parentType.getFields()[name];\n  }\n}\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\n\nfunction visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter(...args) {\n      const node = args[0];\n      typeInfo.enter(node);\n      const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).enter;\n\n      if (fn) {\n        const result = fn.apply(visitor, args);\n\n        if (result !== undefined) {\n          typeInfo.leave(node);\n\n          if ((0, _ast.isNode)(result)) {\n            typeInfo.enter(result);\n          }\n        }\n\n        return result;\n      }\n    },\n\n    leave(...args) {\n      const node = args[0];\n      const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).leave;\n      let result;\n\n      if (fn) {\n        result = fn.apply(visitor, args);\n      }\n\n      typeInfo.leave(node);\n      return result;\n    },\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}