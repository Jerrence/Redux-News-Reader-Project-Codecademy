{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.assertValidSchema = assertValidSchema;\nexports.validateSchema = validateSchema;\nvar _inspect = require('../jsutils/inspect.js');\nvar _GraphQLError = require('../error/GraphQLError.js');\nvar _ast = require('../language/ast.js');\nvar _typeComparators = require('../utilities/typeComparators.js');\nvar _definition = require('./definition.js');\nvar _directives = require('./directives.js');\nvar _introspection = require('./introspection.js');\nvar _schema = require('./schema.js');\n\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\nfunction validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  (0, _schema.assertSchema)(schema); // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n  const context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  const errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nfunction assertValidSchema(schema) {\n  const errors = validateSchema(schema);\n  if (errors.length !== 0) {\n    throw new Error(errors.map(error => error.message).join('\\n\\n'));\n  }\n}\nclass SchemaValidationContext {\n  constructor(schema) {\n    this._errors = [];\n    this.schema = schema;\n  }\n  reportError(message, nodes) {\n    const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\n    this._errors.push(new _GraphQLError.GraphQLError(message, {\n      nodes: _nodes\n    }));\n  }\n  getErrors() {\n    return this._errors;\n  }\n}\nfunction validateRootTypes(context) {\n  const schema = context.schema;\n  const queryType = schema.getQueryType();\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!(0, _definition.isObjectType)(queryType)) {\n    var _getOperationTypeNode;\n    context.reportError(`Query root type must be Object type, it cannot be ${(0, _inspect.inspect)(queryType)}.`, (_getOperationTypeNode = getOperationTypeNode(schema, _ast.OperationTypeNode.QUERY)) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode);\n  }\n  const mutationType = schema.getMutationType();\n  if (mutationType && !(0, _definition.isObjectType)(mutationType)) {\n    var _getOperationTypeNode2;\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + `${(0, _inspect.inspect)(mutationType)}.`, (_getOperationTypeNode2 = getOperationTypeNode(schema, _ast.OperationTypeNode.MUTATION)) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode);\n  }\n  const subscriptionType = schema.getSubscriptionType();\n  if (subscriptionType && !(0, _definition.isObjectType)(subscriptionType)) {\n    var _getOperationTypeNode3;\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + `${(0, _inspect.inspect)(subscriptionType)}.`, (_getOperationTypeNode3 = getOperationTypeNode(schema, _ast.OperationTypeNode.SUBSCRIPTION)) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode);\n  }\n}\nfunction getOperationTypeNode(schema, operation) {\n  var _flatMap$find;\n  return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes].flatMap(\n  // FIXME: https://github.com/graphql/graphql-js/issues/2203\n  schemaNode => {\n    var _schemaNode$operation;\n    return (/* c8 ignore next */\n      (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : []\n    );\n  }).find(operationNode => operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;\n}\nfunction validateDirectives(context) {\n  for (const directive of context.schema.getDirectives()) {\n    // Ensure all directives are in fact GraphQL directives.\n    if (!(0, _directives.isDirective)(directive)) {\n      context.reportError(`Expected directive but got: ${(0, _inspect.inspect)(directive)}.`, directive === null || directive === void 0 ? void 0 : directive.astNode);\n      continue;\n    } // Ensure they are named correctly.\n\n    validateName(context, directive); // TODO: Ensure proper locations.\n    // Ensure the arguments are valid.\n\n    for (const arg of directive.args) {\n      // Ensure they are named correctly.\n      validateName(context, arg); // Ensure the type is an input type.\n\n      if (!(0, _definition.isInputType)(arg.type)) {\n        context.reportError(`The type of @${directive.name}(${arg.name}:) must be Input Type ` + `but got: ${(0, _inspect.inspect)(arg.type)}.`, arg.astNode);\n      }\n      if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {\n        var _arg$astNode;\n        context.reportError(`Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`, [getDeprecatedDirectiveNode(arg.astNode), (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type]);\n      }\n    }\n  }\n}\nfunction validateName(context, node) {\n  // Ensure names are valid, however introspection types opt out.\n  if (node.name.startsWith('__')) {\n    context.reportError(`Name \"${node.name}\" must not begin with \"__\", which is reserved by GraphQL introspection.`, node.astNode);\n  }\n}\nfunction validateTypes(context) {\n  const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);\n  const typeMap = context.schema.getTypeMap();\n  for (const type of Object.values(typeMap)) {\n    // Ensure all provided types are in fact GraphQL type.\n    if (!(0, _definition.isNamedType)(type)) {\n      context.reportError(`Expected GraphQL named type but got: ${(0, _inspect.inspect)(type)}.`, type.astNode);\n      continue;\n    } // Ensure it is named correctly (excluding introspection types).\n\n    if (!(0, _introspection.isIntrospectionType)(type)) {\n      validateName(context, type);\n    }\n    if ((0, _definition.isObjectType)(type)) {\n      // Ensure fields are valid\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if ((0, _definition.isInterfaceType)(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type); // Ensure interfaces implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if ((0, _definition.isUnionType)(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if ((0, _definition.isEnumType)(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if ((0, _definition.isInputObjectType)(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references\n\n      validateInputObjectCircularRefs(type);\n    }\n  }\n}\nfunction validateFields(context, type) {\n  const fields = Object.values(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(`Type ${type.name} must define one or more fields.`, [type.astNode, ...type.extensionASTNodes]);\n  }\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an output type\n\n    if (!(0, _definition.isOutputType)(field.type)) {\n      var _field$astNode;\n      context.reportError(`The type of ${type.name}.${field.name} must be Output Type ` + `but got: ${(0, _inspect.inspect)(field.type)}.`, (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type);\n    } // Ensure the arguments are valid\n\n    for (const arg of field.args) {\n      const argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure the type is an input type\n\n      if (!(0, _definition.isInputType)(arg.type)) {\n        var _arg$astNode2;\n        context.reportError(`The type of ${type.name}.${field.name}(${argName}:) must be Input ` + `Type but got: ${(0, _inspect.inspect)(arg.type)}.`, (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type);\n      }\n      if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {\n        var _arg$astNode3;\n        context.reportError(`Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`, [getDeprecatedDirectiveNode(arg.astNode), (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type]);\n      }\n    }\n  }\n}\nfunction validateInterfaces(context, type) {\n  const ifaceTypeNames = Object.create(null);\n  for (const iface of type.getInterfaces()) {\n    if (!(0, _definition.isInterfaceType)(iface)) {\n      context.reportError(`Type ${(0, _inspect.inspect)(type)} must only implement Interface types, ` + `it cannot implement ${(0, _inspect.inspect)(iface)}.`, getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n    if (type === iface) {\n      context.reportError(`Type ${type.name} cannot implement itself because it would create a circular reference.`, getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n    if (ifaceTypeNames[iface.name]) {\n      context.reportError(`Type ${type.name} can only implement ${iface.name} once.`, getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n    ifaceTypeNames[iface.name] = true;\n    validateTypeImplementsAncestors(context, type, iface);\n    validateTypeImplementsInterface(context, type, iface);\n  }\n}\nfunction validateTypeImplementsInterface(context, type, iface) {\n  const typeFieldMap = type.getFields(); // Assert each interface field is implemented.\n\n  for (const ifaceField of Object.values(iface.getFields())) {\n    const fieldName = ifaceField.name;\n    const typeField = typeFieldMap[fieldName]; // Assert interface field exists on type.\n\n    if (!typeField) {\n      context.reportError(`Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`, [ifaceField.astNode, type.astNode, ...type.extensionASTNodes]);\n      continue;\n    } // Assert interface field type is satisfied by type field type, by being\n    // a valid subtype. (covariant)\n\n    if (!(0, _typeComparators.isTypeSubTypeOf)(context.schema, typeField.type, ifaceField.type)) {\n      var _ifaceField$astNode, _typeField$astNode;\n      context.reportError(`Interface field ${iface.name}.${fieldName} expects type ` + `${(0, _inspect.inspect)(ifaceField.type)} but ${type.name}.${fieldName} ` + `is type ${(0, _inspect.inspect)(typeField.type)}.`, [(_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type, (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type]);\n    } // Assert each interface field arg is implemented.\n\n    for (const ifaceArg of ifaceField.args) {\n      const argName = ifaceArg.name;\n      const typeArg = typeField.args.find(arg => arg.name === argName); // Assert interface field arg exists on object field.\n\n      if (!typeArg) {\n        context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`, [ifaceArg.astNode, typeField.astNode]);\n        continue;\n      } // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n\n      if (!(0, _typeComparators.isEqualType)(ifaceArg.type, typeArg.type)) {\n        var _ifaceArg$astNode, _typeArg$astNode;\n        context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) ` + `expects type ${(0, _inspect.inspect)(ifaceArg.type)} but ` + `${type.name}.${fieldName}(${argName}:) is type ` + `${(0, _inspect.inspect)(typeArg.type)}.`, [(_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type, (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type]);\n      } // TODO: validate default values?\n    } // Assert additional arguments must not be required.\n\n    for (const typeArg of typeField.args) {\n      const argName = typeArg.name;\n      const ifaceArg = ifaceField.args.find(arg => arg.name === argName);\n      if (!ifaceArg && (0, _definition.isRequiredArgument)(typeArg)) {\n        context.reportError(`Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`, [typeArg.astNode, ifaceField.astNode]);\n      }\n    }\n  }\n}\nfunction validateTypeImplementsAncestors(context, type, iface) {\n  const ifaceInterfaces = type.getInterfaces();\n  for (const transitive of iface.getInterfaces()) {\n    if (!ifaceInterfaces.includes(transitive)) {\n      context.reportError(transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`, [...getAllImplementsInterfaceNodes(iface, transitive), ...getAllImplementsInterfaceNodes(type, iface)]);\n    }\n  }\n}\nfunction validateUnionMembers(context, union) {\n  const memberTypes = union.getTypes();\n  if (memberTypes.length === 0) {\n    context.reportError(`Union type ${union.name} must define one or more member types.`, [union.astNode, ...union.extensionASTNodes]);\n  }\n  const includedTypeNames = Object.create(null);\n  for (const memberType of memberTypes) {\n    if (includedTypeNames[memberType.name]) {\n      context.reportError(`Union type ${union.name} can only include type ${memberType.name} once.`, getUnionMemberTypeNodes(union, memberType.name));\n      continue;\n    }\n    includedTypeNames[memberType.name] = true;\n    if (!(0, _definition.isObjectType)(memberType)) {\n      context.reportError(`Union type ${union.name} can only include Object types, ` + `it cannot include ${(0, _inspect.inspect)(memberType)}.`, getUnionMemberTypeNodes(union, String(memberType)));\n    }\n  }\n}\nfunction validateEnumValues(context, enumType) {\n  const enumValues = enumType.getValues();\n  if (enumValues.length === 0) {\n    context.reportError(`Enum type ${enumType.name} must define one or more values.`, [enumType.astNode, ...enumType.extensionASTNodes]);\n  }\n  for (const enumValue of enumValues) {\n    // Ensure valid name.\n    validateName(context, enumValue);\n  }\n}\nfunction validateInputFields(context, inputObj) {\n  const fields = Object.values(inputObj.getFields());\n  if (fields.length === 0) {\n    context.reportError(`Input Object type ${inputObj.name} must define one or more fields.`, [inputObj.astNode, ...inputObj.extensionASTNodes]);\n  } // Ensure the arguments are valid\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an input type\n\n    if (!(0, _definition.isInputType)(field.type)) {\n      var _field$astNode2;\n      context.reportError(`The type of ${inputObj.name}.${field.name} must be Input Type ` + `but got: ${(0, _inspect.inspect)(field.type)}.`, (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type);\n    }\n    if ((0, _definition.isRequiredInputField)(field) && field.deprecationReason != null) {\n      var _field$astNode3;\n      context.reportError(`Required input field ${inputObj.name}.${field.name} cannot be deprecated.`, [getDeprecatedDirectiveNode(field.astNode), (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type]);\n    }\n  }\n}\nfunction createInputObjectCircularRefsValidator(context) {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors\n\n  const fieldPath = []; // Position in the type path\n\n  const fieldPathIndexByTypeName = Object.create(null);\n  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(inputObj) {\n    if (visitedTypes[inputObj.name]) {\n      return;\n    }\n    visitedTypes[inputObj.name] = true;\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n    const fields = Object.values(inputObj.getFields());\n    for (const field of fields) {\n      if ((0, _definition.isNonNullType)(field.type) && (0, _definition.isInputObjectType)(field.type.ofType)) {\n        const fieldType = field.type.ofType;\n        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n        fieldPath.push(field);\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          const cyclePath = fieldPath.slice(cycleIndex);\n          const pathStr = cyclePath.map(fieldObj => fieldObj.name).join('.');\n          context.reportError(`Cannot reference Input Object \"${fieldType.name}\" within itself through a series of non-null fields: \"${pathStr}\".`, cyclePath.map(fieldObj => fieldObj.astNode));\n        }\n        fieldPath.pop();\n      }\n    }\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  const {\n    astNode,\n    extensionASTNodes\n  } = type;\n  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes.flatMap(typeNode => {\n    var _typeNode$interfaces;\n    return (/* c8 ignore next */\n      (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : []\n    );\n  }).filter(ifaceNode => ifaceNode.name.value === iface.name);\n}\nfunction getUnionMemberTypeNodes(union, typeName) {\n  const {\n    astNode,\n    extensionASTNodes\n  } = union;\n  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes.flatMap(unionNode => {\n    var _unionNode$types;\n    return (/* c8 ignore next */\n      (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : []\n    );\n  }).filter(typeNode => typeNode.name.value === typeName);\n}\nfunction getDeprecatedDirectiveNode(definitionNode) {\n  var _definitionNode$direc;\n  return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(node => node.name.value === _directives.GraphQLDeprecatedDirective.name);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","assertValidSchema","validateSchema","_inspect","require","_GraphQLError","_ast","_typeComparators","_definition","_directives","_introspection","_schema","schema","assertSchema","__validationErrors","context","SchemaValidationContext","validateRootTypes","validateDirectives","validateTypes","errors","getErrors","length","Error","map","error","message","join","constructor","_errors","reportError","nodes","_nodes","Array","isArray","filter","Boolean","push","GraphQLError","queryType","getQueryType","astNode","isObjectType","_getOperationTypeNode","inspect","getOperationTypeNode","OperationTypeNode","QUERY","mutationType","getMutationType","_getOperationTypeNode2","MUTATION","subscriptionType","getSubscriptionType","_getOperationTypeNode3","SUBSCRIPTION","operation","_flatMap$find","extensionASTNodes","flatMap","schemaNode","_schemaNode$operation","operationTypes","find","operationNode","type","directive","getDirectives","isDirective","validateName","arg","args","isInputType","name","isRequiredArgument","deprecationReason","_arg$astNode","getDeprecatedDirectiveNode","node","startsWith","validateInputObjectCircularRefs","createInputObjectCircularRefsValidator","typeMap","getTypeMap","values","isNamedType","isIntrospectionType","validateFields","validateInterfaces","isInterfaceType","isUnionType","validateUnionMembers","isEnumType","validateEnumValues","isInputObjectType","validateInputFields","fields","getFields","field","isOutputType","_field$astNode","argName","_arg$astNode2","_arg$astNode3","ifaceTypeNames","create","iface","getInterfaces","getAllImplementsInterfaceNodes","validateTypeImplementsAncestors","validateTypeImplementsInterface","typeFieldMap","ifaceField","fieldName","typeField","isTypeSubTypeOf","_ifaceField$astNode","_typeField$astNode","ifaceArg","typeArg","isEqualType","_ifaceArg$astNode","_typeArg$astNode","ifaceInterfaces","transitive","includes","union","memberTypes","getTypes","includedTypeNames","memberType","getUnionMemberTypeNodes","String","enumType","enumValues","getValues","enumValue","inputObj","_field$astNode2","isRequiredInputField","_field$astNode3","visitedTypes","fieldPath","fieldPathIndexByTypeName","detectCycleRecursive","isNonNullType","ofType","fieldType","cycleIndex","undefined","cyclePath","slice","pathStr","fieldObj","pop","typeNode","_typeNode$interfaces","interfaces","ifaceNode","typeName","unionNode","_unionNode$types","types","definitionNode","_definitionNode$direc","directives","GraphQLDeprecatedDirective"],"sources":["/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/graphql/type/validate.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.assertValidSchema = assertValidSchema;\nexports.validateSchema = validateSchema;\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _GraphQLError = require('../error/GraphQLError.js');\n\nvar _ast = require('../language/ast.js');\n\nvar _typeComparators = require('../utilities/typeComparators.js');\n\nvar _definition = require('./definition.js');\n\nvar _directives = require('./directives.js');\n\nvar _introspection = require('./introspection.js');\n\nvar _schema = require('./schema.js');\n\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\nfunction validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  (0, _schema.assertSchema)(schema); // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n  const context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  const errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nfunction assertValidSchema(schema) {\n  const errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n\nclass SchemaValidationContext {\n  constructor(schema) {\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  reportError(message, nodes) {\n    const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\n\n    this._errors.push(\n      new _GraphQLError.GraphQLError(message, {\n        nodes: _nodes,\n      }),\n    );\n  }\n\n  getErrors() {\n    return this._errors;\n  }\n}\n\nfunction validateRootTypes(context) {\n  const schema = context.schema;\n  const queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!(0, _definition.isObjectType)(queryType)) {\n    var _getOperationTypeNode;\n\n    context.reportError(\n      `Query root type must be Object type, it cannot be ${(0,\n      _inspect.inspect)(queryType)}.`,\n      (_getOperationTypeNode = getOperationTypeNode(\n        schema,\n        _ast.OperationTypeNode.QUERY,\n      )) !== null && _getOperationTypeNode !== void 0\n        ? _getOperationTypeNode\n        : queryType.astNode,\n    );\n  }\n\n  const mutationType = schema.getMutationType();\n\n  if (mutationType && !(0, _definition.isObjectType)(mutationType)) {\n    var _getOperationTypeNode2;\n\n    context.reportError(\n      'Mutation root type must be Object type if provided, it cannot be ' +\n        `${(0, _inspect.inspect)(mutationType)}.`,\n      (_getOperationTypeNode2 = getOperationTypeNode(\n        schema,\n        _ast.OperationTypeNode.MUTATION,\n      )) !== null && _getOperationTypeNode2 !== void 0\n        ? _getOperationTypeNode2\n        : mutationType.astNode,\n    );\n  }\n\n  const subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !(0, _definition.isObjectType)(subscriptionType)) {\n    var _getOperationTypeNode3;\n\n    context.reportError(\n      'Subscription root type must be Object type if provided, it cannot be ' +\n        `${(0, _inspect.inspect)(subscriptionType)}.`,\n      (_getOperationTypeNode3 = getOperationTypeNode(\n        schema,\n        _ast.OperationTypeNode.SUBSCRIPTION,\n      )) !== null && _getOperationTypeNode3 !== void 0\n        ? _getOperationTypeNode3\n        : subscriptionType.astNode,\n    );\n  }\n}\n\nfunction getOperationTypeNode(schema, operation) {\n  var _flatMap$find;\n\n  return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes]\n    .flatMap(\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      (schemaNode) => {\n        var _schemaNode$operation;\n\n        return (\n          /* c8 ignore next */\n          (_schemaNode$operation =\n            schemaNode === null || schemaNode === void 0\n              ? void 0\n              : schemaNode.operationTypes) !== null &&\n            _schemaNode$operation !== void 0\n            ? _schemaNode$operation\n            : []\n        );\n      },\n    )\n    .find((operationNode) => operationNode.operation === operation)) === null ||\n    _flatMap$find === void 0\n    ? void 0\n    : _flatMap$find.type;\n}\n\nfunction validateDirectives(context) {\n  for (const directive of context.schema.getDirectives()) {\n    // Ensure all directives are in fact GraphQL directives.\n    if (!(0, _directives.isDirective)(directive)) {\n      context.reportError(\n        `Expected directive but got: ${(0, _inspect.inspect)(directive)}.`,\n        directive === null || directive === void 0 ? void 0 : directive.astNode,\n      );\n      continue;\n    } // Ensure they are named correctly.\n\n    validateName(context, directive); // TODO: Ensure proper locations.\n    // Ensure the arguments are valid.\n\n    for (const arg of directive.args) {\n      // Ensure they are named correctly.\n      validateName(context, arg); // Ensure the type is an input type.\n\n      if (!(0, _definition.isInputType)(arg.type)) {\n        context.reportError(\n          `The type of @${directive.name}(${arg.name}:) must be Input Type ` +\n            `but got: ${(0, _inspect.inspect)(arg.type)}.`,\n          arg.astNode,\n        );\n      }\n\n      if (\n        (0, _definition.isRequiredArgument)(arg) &&\n        arg.deprecationReason != null\n      ) {\n        var _arg$astNode;\n\n        context.reportError(\n          `Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`,\n          [\n            getDeprecatedDirectiveNode(arg.astNode),\n            (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0\n              ? void 0\n              : _arg$astNode.type,\n          ],\n        );\n      }\n    }\n  }\n}\n\nfunction validateName(context, node) {\n  // Ensure names are valid, however introspection types opt out.\n  if (node.name.startsWith('__')) {\n    context.reportError(\n      `Name \"${node.name}\" must not begin with \"__\", which is reserved by GraphQL introspection.`,\n      node.astNode,\n    );\n  }\n}\n\nfunction validateTypes(context) {\n  const validateInputObjectCircularRefs =\n    createInputObjectCircularRefsValidator(context);\n  const typeMap = context.schema.getTypeMap();\n\n  for (const type of Object.values(typeMap)) {\n    // Ensure all provided types are in fact GraphQL type.\n    if (!(0, _definition.isNamedType)(type)) {\n      context.reportError(\n        `Expected GraphQL named type but got: ${(0, _inspect.inspect)(type)}.`,\n        type.astNode,\n      );\n      continue;\n    } // Ensure it is named correctly (excluding introspection types).\n\n    if (!(0, _introspection.isIntrospectionType)(type)) {\n      validateName(context, type);\n    }\n\n    if ((0, _definition.isObjectType)(type)) {\n      // Ensure fields are valid\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if ((0, _definition.isInterfaceType)(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type); // Ensure interfaces implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if ((0, _definition.isUnionType)(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if ((0, _definition.isEnumType)(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if ((0, _definition.isInputObjectType)(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references\n\n      validateInputObjectCircularRefs(type);\n    }\n  }\n}\n\nfunction validateFields(context, type) {\n  const fields = Object.values(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(`Type ${type.name} must define one or more fields.`, [\n      type.astNode,\n      ...type.extensionASTNodes,\n    ]);\n  }\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an output type\n\n    if (!(0, _definition.isOutputType)(field.type)) {\n      var _field$astNode;\n\n      context.reportError(\n        `The type of ${type.name}.${field.name} must be Output Type ` +\n          `but got: ${(0, _inspect.inspect)(field.type)}.`,\n        (_field$astNode = field.astNode) === null || _field$astNode === void 0\n          ? void 0\n          : _field$astNode.type,\n      );\n    } // Ensure the arguments are valid\n\n    for (const arg of field.args) {\n      const argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure the type is an input type\n\n      if (!(0, _definition.isInputType)(arg.type)) {\n        var _arg$astNode2;\n\n        context.reportError(\n          `The type of ${type.name}.${field.name}(${argName}:) must be Input ` +\n            `Type but got: ${(0, _inspect.inspect)(arg.type)}.`,\n          (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0\n            ? void 0\n            : _arg$astNode2.type,\n        );\n      }\n\n      if (\n        (0, _definition.isRequiredArgument)(arg) &&\n        arg.deprecationReason != null\n      ) {\n        var _arg$astNode3;\n\n        context.reportError(\n          `Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`,\n          [\n            getDeprecatedDirectiveNode(arg.astNode),\n            (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0\n              ? void 0\n              : _arg$astNode3.type,\n          ],\n        );\n      }\n    }\n  }\n}\n\nfunction validateInterfaces(context, type) {\n  const ifaceTypeNames = Object.create(null);\n\n  for (const iface of type.getInterfaces()) {\n    if (!(0, _definition.isInterfaceType)(iface)) {\n      context.reportError(\n        `Type ${(0, _inspect.inspect)(\n          type,\n        )} must only implement Interface types, ` +\n          `it cannot implement ${(0, _inspect.inspect)(iface)}.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    if (type === iface) {\n      context.reportError(\n        `Type ${type.name} cannot implement itself because it would create a circular reference.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    if (ifaceTypeNames[iface.name]) {\n      context.reportError(\n        `Type ${type.name} can only implement ${iface.name} once.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    ifaceTypeNames[iface.name] = true;\n    validateTypeImplementsAncestors(context, type, iface);\n    validateTypeImplementsInterface(context, type, iface);\n  }\n}\n\nfunction validateTypeImplementsInterface(context, type, iface) {\n  const typeFieldMap = type.getFields(); // Assert each interface field is implemented.\n\n  for (const ifaceField of Object.values(iface.getFields())) {\n    const fieldName = ifaceField.name;\n    const typeField = typeFieldMap[fieldName]; // Assert interface field exists on type.\n\n    if (!typeField) {\n      context.reportError(\n        `Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`,\n        [ifaceField.astNode, type.astNode, ...type.extensionASTNodes],\n      );\n      continue;\n    } // Assert interface field type is satisfied by type field type, by being\n    // a valid subtype. (covariant)\n\n    if (\n      !(0, _typeComparators.isTypeSubTypeOf)(\n        context.schema,\n        typeField.type,\n        ifaceField.type,\n      )\n    ) {\n      var _ifaceField$astNode, _typeField$astNode;\n\n      context.reportError(\n        `Interface field ${iface.name}.${fieldName} expects type ` +\n          `${(0, _inspect.inspect)(ifaceField.type)} but ${\n            type.name\n          }.${fieldName} ` +\n          `is type ${(0, _inspect.inspect)(typeField.type)}.`,\n        [\n          (_ifaceField$astNode = ifaceField.astNode) === null ||\n          _ifaceField$astNode === void 0\n            ? void 0\n            : _ifaceField$astNode.type,\n          (_typeField$astNode = typeField.astNode) === null ||\n          _typeField$astNode === void 0\n            ? void 0\n            : _typeField$astNode.type,\n        ],\n      );\n    } // Assert each interface field arg is implemented.\n\n    for (const ifaceArg of ifaceField.args) {\n      const argName = ifaceArg.name;\n      const typeArg = typeField.args.find((arg) => arg.name === argName); // Assert interface field arg exists on object field.\n\n      if (!typeArg) {\n        context.reportError(\n          `Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`,\n          [ifaceArg.astNode, typeField.astNode],\n        );\n        continue;\n      } // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n\n      if (!(0, _typeComparators.isEqualType)(ifaceArg.type, typeArg.type)) {\n        var _ifaceArg$astNode, _typeArg$astNode;\n\n        context.reportError(\n          `Interface field argument ${iface.name}.${fieldName}(${argName}:) ` +\n            `expects type ${(0, _inspect.inspect)(ifaceArg.type)} but ` +\n            `${type.name}.${fieldName}(${argName}:) is type ` +\n            `${(0, _inspect.inspect)(typeArg.type)}.`,\n          [\n            (_ifaceArg$astNode = ifaceArg.astNode) === null ||\n            _ifaceArg$astNode === void 0\n              ? void 0\n              : _ifaceArg$astNode.type,\n            (_typeArg$astNode = typeArg.astNode) === null ||\n            _typeArg$astNode === void 0\n              ? void 0\n              : _typeArg$astNode.type,\n          ],\n        );\n      } // TODO: validate default values?\n    } // Assert additional arguments must not be required.\n\n    for (const typeArg of typeField.args) {\n      const argName = typeArg.name;\n      const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);\n\n      if (!ifaceArg && (0, _definition.isRequiredArgument)(typeArg)) {\n        context.reportError(\n          `Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`,\n          [typeArg.astNode, ifaceField.astNode],\n        );\n      }\n    }\n  }\n}\n\nfunction validateTypeImplementsAncestors(context, type, iface) {\n  const ifaceInterfaces = type.getInterfaces();\n\n  for (const transitive of iface.getInterfaces()) {\n    if (!ifaceInterfaces.includes(transitive)) {\n      context.reportError(\n        transitive === type\n          ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.`\n          : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`,\n        [\n          ...getAllImplementsInterfaceNodes(iface, transitive),\n          ...getAllImplementsInterfaceNodes(type, iface),\n        ],\n      );\n    }\n  }\n}\n\nfunction validateUnionMembers(context, union) {\n  const memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(\n      `Union type ${union.name} must define one or more member types.`,\n      [union.astNode, ...union.extensionASTNodes],\n    );\n  }\n\n  const includedTypeNames = Object.create(null);\n\n  for (const memberType of memberTypes) {\n    if (includedTypeNames[memberType.name]) {\n      context.reportError(\n        `Union type ${union.name} can only include type ${memberType.name} once.`,\n        getUnionMemberTypeNodes(union, memberType.name),\n      );\n      continue;\n    }\n\n    includedTypeNames[memberType.name] = true;\n\n    if (!(0, _definition.isObjectType)(memberType)) {\n      context.reportError(\n        `Union type ${union.name} can only include Object types, ` +\n          `it cannot include ${(0, _inspect.inspect)(memberType)}.`,\n        getUnionMemberTypeNodes(union, String(memberType)),\n      );\n    }\n  }\n}\n\nfunction validateEnumValues(context, enumType) {\n  const enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(\n      `Enum type ${enumType.name} must define one or more values.`,\n      [enumType.astNode, ...enumType.extensionASTNodes],\n    );\n  }\n\n  for (const enumValue of enumValues) {\n    // Ensure valid name.\n    validateName(context, enumValue);\n  }\n}\n\nfunction validateInputFields(context, inputObj) {\n  const fields = Object.values(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(\n      `Input Object type ${inputObj.name} must define one or more fields.`,\n      [inputObj.astNode, ...inputObj.extensionASTNodes],\n    );\n  } // Ensure the arguments are valid\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an input type\n\n    if (!(0, _definition.isInputType)(field.type)) {\n      var _field$astNode2;\n\n      context.reportError(\n        `The type of ${inputObj.name}.${field.name} must be Input Type ` +\n          `but got: ${(0, _inspect.inspect)(field.type)}.`,\n        (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0\n          ? void 0\n          : _field$astNode2.type,\n      );\n    }\n\n    if (\n      (0, _definition.isRequiredInputField)(field) &&\n      field.deprecationReason != null\n    ) {\n      var _field$astNode3;\n\n      context.reportError(\n        `Required input field ${inputObj.name}.${field.name} cannot be deprecated.`,\n        [\n          getDeprecatedDirectiveNode(field.astNode),\n          (_field$astNode3 = field.astNode) === null ||\n          _field$astNode3 === void 0\n            ? void 0\n            : _field$astNode3.type,\n        ],\n      );\n    }\n  }\n}\n\nfunction createInputObjectCircularRefsValidator(context) {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors\n\n  const fieldPath = []; // Position in the type path\n\n  const fieldPathIndexByTypeName = Object.create(null);\n  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(inputObj) {\n    if (visitedTypes[inputObj.name]) {\n      return;\n    }\n\n    visitedTypes[inputObj.name] = true;\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n    const fields = Object.values(inputObj.getFields());\n\n    for (const field of fields) {\n      if (\n        (0, _definition.isNonNullType)(field.type) &&\n        (0, _definition.isInputObjectType)(field.type.ofType)\n      ) {\n        const fieldType = field.type.ofType;\n        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n        fieldPath.push(field);\n\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          const cyclePath = fieldPath.slice(cycleIndex);\n          const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join('.');\n          context.reportError(\n            `Cannot reference Input Object \"${fieldType.name}\" within itself through a series of non-null fields: \"${pathStr}\".`,\n            cyclePath.map((fieldObj) => fieldObj.astNode),\n          );\n        }\n\n        fieldPath.pop();\n      }\n    }\n\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  const { astNode, extensionASTNodes } = type;\n  const nodes =\n    astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes\n    .flatMap((typeNode) => {\n      var _typeNode$interfaces;\n\n      return (\n        /* c8 ignore next */\n        (_typeNode$interfaces = typeNode.interfaces) !== null &&\n          _typeNode$interfaces !== void 0\n          ? _typeNode$interfaces\n          : []\n      );\n    })\n    .filter((ifaceNode) => ifaceNode.name.value === iface.name);\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  const { astNode, extensionASTNodes } = union;\n  const nodes =\n    astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes\n    .flatMap((unionNode) => {\n      var _unionNode$types;\n\n      return (\n        /* c8 ignore next */\n        (_unionNode$types = unionNode.types) !== null &&\n          _unionNode$types !== void 0\n          ? _unionNode$types\n          : []\n      );\n    })\n    .filter((typeNode) => typeNode.name.value === typeName);\n}\n\nfunction getDeprecatedDirectiveNode(definitionNode) {\n  var _definitionNode$direc;\n\n  return definitionNode === null || definitionNode === void 0\n    ? void 0\n    : (_definitionNode$direc = definitionNode.directives) === null ||\n      _definitionNode$direc === void 0\n    ? void 0\n    : _definitionNode$direc.find(\n        (node) =>\n          node.name.value === _directives.GraphQLDeprecatedDirective.name,\n      );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}