{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.ValuesOfCorrectTypeRule = ValuesOfCorrectTypeRule;\nvar _didYouMean = require('../../jsutils/didYouMean.js');\nvar _inspect = require('../../jsutils/inspect.js');\nvar _keyMap = require('../../jsutils/keyMap.js');\nvar _suggestionList = require('../../jsutils/suggestionList.js');\nvar _GraphQLError = require('../../error/GraphQLError.js');\nvar _printer = require('../../language/printer.js');\nvar _definition = require('../../type/definition.js');\n\n/**\n * Value literals of correct type\n *\n * A GraphQL document is only valid if all value literals are of the type\n * expected at their position.\n *\n * See https://spec.graphql.org/draft/#sec-Values-of-Correct-Type\n */\nfunction ValuesOfCorrectTypeRule(context) {\n  return {\n    ListValue(node) {\n      // Note: TypeInfo will traverse into a list's item type, so look to the\n      // parent input type to check if it is a list.\n      const type = (0, _definition.getNullableType)(context.getParentInputType());\n      if (!(0, _definition.isListType)(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      }\n    },\n\n    ObjectValue(node) {\n      const type = (0, _definition.getNamedType)(context.getInputType());\n      if (!(0, _definition.isInputObjectType)(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      } // Ensure every required field exists.\n\n      const fieldNodeMap = (0, _keyMap.keyMap)(node.fields, field => field.name.value);\n      for (const fieldDef of Object.values(type.getFields())) {\n        const fieldNode = fieldNodeMap[fieldDef.name];\n        if (!fieldNode && (0, _definition.isRequiredInputField)(fieldDef)) {\n          const typeStr = (0, _inspect.inspect)(fieldDef.type);\n          context.reportError(new _GraphQLError.GraphQLError(`Field \"${type.name}.${fieldDef.name}\" of required type \"${typeStr}\" was not provided.`, {\n            nodes: node\n          }));\n        }\n      }\n    },\n    ObjectField(node) {\n      const parentType = (0, _definition.getNamedType)(context.getParentInputType());\n      const fieldType = context.getInputType();\n      if (!fieldType && (0, _definition.isInputObjectType)(parentType)) {\n        const suggestions = (0, _suggestionList.suggestionList)(node.name.value, Object.keys(parentType.getFields()));\n        context.reportError(new _GraphQLError.GraphQLError(`Field \"${node.name.value}\" is not defined by type \"${parentType.name}\".` + (0, _didYouMean.didYouMean)(suggestions), {\n          nodes: node\n        }));\n      }\n    },\n    NullValue(node) {\n      const type = context.getInputType();\n      if ((0, _definition.isNonNullType)(type)) {\n        context.reportError(new _GraphQLError.GraphQLError(`Expected value of type \"${(0, _inspect.inspect)(type)}\", found ${(0, _printer.print)(node)}.`, {\n          nodes: node\n        }));\n      }\n    },\n    EnumValue: node => isValidValueNode(context, node),\n    IntValue: node => isValidValueNode(context, node),\n    FloatValue: node => isValidValueNode(context, node),\n    StringValue: node => isValidValueNode(context, node),\n    BooleanValue: node => isValidValueNode(context, node)\n  };\n}\n/**\n * Any value literal may be a valid representation of a Scalar, depending on\n * that scalar type.\n */\n\nfunction isValidValueNode(context, node) {\n  // Report any error at the full type expected by the location.\n  const locationType = context.getInputType();\n  if (!locationType) {\n    return;\n  }\n  const type = (0, _definition.getNamedType)(locationType);\n  if (!(0, _definition.isLeafType)(type)) {\n    const typeStr = (0, _inspect.inspect)(locationType);\n    context.reportError(new _GraphQLError.GraphQLError(`Expected value of type \"${typeStr}\", found ${(0, _printer.print)(node)}.`, {\n      nodes: node\n    }));\n    return;\n  } // Scalars and Enums determine if a literal value is valid via parseLiteral(),\n  // which may throw or return an invalid value to indicate failure.\n\n  try {\n    const parseResult = type.parseLiteral(node, undefined\n    /* variables */);\n\n    if (parseResult === undefined) {\n      const typeStr = (0, _inspect.inspect)(locationType);\n      context.reportError(new _GraphQLError.GraphQLError(`Expected value of type \"${typeStr}\", found ${(0, _printer.print)(node)}.`, {\n        nodes: node\n      }));\n    }\n  } catch (error) {\n    const typeStr = (0, _inspect.inspect)(locationType);\n    if (error instanceof _GraphQLError.GraphQLError) {\n      context.reportError(error);\n    } else {\n      context.reportError(new _GraphQLError.GraphQLError(`Expected value of type \"${typeStr}\", found ${(0, _printer.print)(node)}; ` + error.message, {\n        nodes: node,\n        originalError: error\n      }));\n    }\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","ValuesOfCorrectTypeRule","_didYouMean","require","_inspect","_keyMap","_suggestionList","_GraphQLError","_printer","_definition","context","ListValue","node","type","getNullableType","getParentInputType","isListType","isValidValueNode","ObjectValue","getNamedType","getInputType","isInputObjectType","fieldNodeMap","keyMap","fields","field","name","fieldDef","values","getFields","fieldNode","isRequiredInputField","typeStr","inspect","reportError","GraphQLError","nodes","ObjectField","parentType","fieldType","suggestions","suggestionList","keys","didYouMean","NullValue","isNonNullType","print","EnumValue","IntValue","FloatValue","StringValue","BooleanValue","locationType","isLeafType","parseResult","parseLiteral","undefined","error","message","originalError"],"sources":["/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.ValuesOfCorrectTypeRule = ValuesOfCorrectTypeRule;\n\nvar _didYouMean = require('../../jsutils/didYouMean.js');\n\nvar _inspect = require('../../jsutils/inspect.js');\n\nvar _keyMap = require('../../jsutils/keyMap.js');\n\nvar _suggestionList = require('../../jsutils/suggestionList.js');\n\nvar _GraphQLError = require('../../error/GraphQLError.js');\n\nvar _printer = require('../../language/printer.js');\n\nvar _definition = require('../../type/definition.js');\n\n/**\n * Value literals of correct type\n *\n * A GraphQL document is only valid if all value literals are of the type\n * expected at their position.\n *\n * See https://spec.graphql.org/draft/#sec-Values-of-Correct-Type\n */\nfunction ValuesOfCorrectTypeRule(context) {\n  return {\n    ListValue(node) {\n      // Note: TypeInfo will traverse into a list's item type, so look to the\n      // parent input type to check if it is a list.\n      const type = (0, _definition.getNullableType)(\n        context.getParentInputType(),\n      );\n\n      if (!(0, _definition.isListType)(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      }\n    },\n\n    ObjectValue(node) {\n      const type = (0, _definition.getNamedType)(context.getInputType());\n\n      if (!(0, _definition.isInputObjectType)(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      } // Ensure every required field exists.\n\n      const fieldNodeMap = (0, _keyMap.keyMap)(\n        node.fields,\n        (field) => field.name.value,\n      );\n\n      for (const fieldDef of Object.values(type.getFields())) {\n        const fieldNode = fieldNodeMap[fieldDef.name];\n\n        if (!fieldNode && (0, _definition.isRequiredInputField)(fieldDef)) {\n          const typeStr = (0, _inspect.inspect)(fieldDef.type);\n          context.reportError(\n            new _GraphQLError.GraphQLError(\n              `Field \"${type.name}.${fieldDef.name}\" of required type \"${typeStr}\" was not provided.`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    ObjectField(node) {\n      const parentType = (0, _definition.getNamedType)(\n        context.getParentInputType(),\n      );\n      const fieldType = context.getInputType();\n\n      if (!fieldType && (0, _definition.isInputObjectType)(parentType)) {\n        const suggestions = (0, _suggestionList.suggestionList)(\n          node.name.value,\n          Object.keys(parentType.getFields()),\n        );\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Field \"${node.name.value}\" is not defined by type \"${parentType.name}\".` +\n              (0, _didYouMean.didYouMean)(suggestions),\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    NullValue(node) {\n      const type = context.getInputType();\n\n      if ((0, _definition.isNonNullType)(type)) {\n        context.reportError(\n          new _GraphQLError.GraphQLError(\n            `Expected value of type \"${(0, _inspect.inspect)(\n              type,\n            )}\", found ${(0, _printer.print)(node)}.`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    EnumValue: (node) => isValidValueNode(context, node),\n    IntValue: (node) => isValidValueNode(context, node),\n    FloatValue: (node) => isValidValueNode(context, node),\n    StringValue: (node) => isValidValueNode(context, node),\n    BooleanValue: (node) => isValidValueNode(context, node),\n  };\n}\n/**\n * Any value literal may be a valid representation of a Scalar, depending on\n * that scalar type.\n */\n\nfunction isValidValueNode(context, node) {\n  // Report any error at the full type expected by the location.\n  const locationType = context.getInputType();\n\n  if (!locationType) {\n    return;\n  }\n\n  const type = (0, _definition.getNamedType)(locationType);\n\n  if (!(0, _definition.isLeafType)(type)) {\n    const typeStr = (0, _inspect.inspect)(locationType);\n    context.reportError(\n      new _GraphQLError.GraphQLError(\n        `Expected value of type \"${typeStr}\", found ${(0, _printer.print)(\n          node,\n        )}.`,\n        {\n          nodes: node,\n        },\n      ),\n    );\n    return;\n  } // Scalars and Enums determine if a literal value is valid via parseLiteral(),\n  // which may throw or return an invalid value to indicate failure.\n\n  try {\n    const parseResult = type.parseLiteral(\n      node,\n      undefined,\n      /* variables */\n    );\n\n    if (parseResult === undefined) {\n      const typeStr = (0, _inspect.inspect)(locationType);\n      context.reportError(\n        new _GraphQLError.GraphQLError(\n          `Expected value of type \"${typeStr}\", found ${(0, _printer.print)(\n            node,\n          )}.`,\n          {\n            nodes: node,\n          },\n        ),\n      );\n    }\n  } catch (error) {\n    const typeStr = (0, _inspect.inspect)(locationType);\n\n    if (error instanceof _GraphQLError.GraphQLError) {\n      context.reportError(error);\n    } else {\n      context.reportError(\n        new _GraphQLError.GraphQLError(\n          `Expected value of type \"${typeStr}\", found ${(0, _printer.print)(\n            node,\n          )}; ` + error.message,\n          {\n            nodes: node,\n            originalError: error,\n          },\n        ),\n      );\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}