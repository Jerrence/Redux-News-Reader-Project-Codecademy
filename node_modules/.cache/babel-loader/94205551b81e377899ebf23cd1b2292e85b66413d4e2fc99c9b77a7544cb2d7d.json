{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.GraphQLSchema = void 0;\nexports.assertSchema = assertSchema;\nexports.isSchema = isSchema;\nvar _devAssert = require('../jsutils/devAssert.js');\nvar _inspect = require('../jsutils/inspect.js');\nvar _instanceOf = require('../jsutils/instanceOf.js');\nvar _isObjectLike = require('../jsutils/isObjectLike.js');\nvar _toObjMap = require('../jsutils/toObjMap.js');\nvar _ast = require('../language/ast.js');\nvar _definition = require('./definition.js');\nvar _directives = require('./directives.js');\nvar _introspection = require('./introspection.js');\n\n/**\n * Test if the given value is a GraphQL schema.\n */\nfunction isSchema(schema) {\n  return (0, _instanceOf.instanceOf)(schema, GraphQLSchema);\n}\nfunction assertSchema(schema) {\n  if (!isSchema(schema)) {\n    throw new Error(`Expected ${(0, _inspect.inspect)(schema)} to be a GraphQL schema.`);\n  }\n  return schema;\n}\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\n\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n * ```ts\n * const MyAppSchema = new GraphQLSchema({\n *   query: MyAppQueryRootType,\n *   mutation: MyAppMutationRootType,\n * })\n * ```\n *\n * Note: When the schema is constructed, by default only the types that are\n * reachable by traversing the root types are included, other types must be\n * explicitly referenced.\n *\n * Example:\n *\n * ```ts\n * const characterInterface = new GraphQLInterfaceType({\n *   name: 'Character',\n *   ...\n * });\n *\n * const humanType = new GraphQLObjectType({\n *   name: 'Human',\n *   interfaces: [characterInterface],\n *   ...\n * });\n *\n * const droidType = new GraphQLObjectType({\n *   name: 'Droid',\n *   interfaces: [characterInterface],\n *   ...\n * });\n *\n * const schema = new GraphQLSchema({\n *   query: new GraphQLObjectType({\n *     name: 'Query',\n *     fields: {\n *       hero: { type: characterInterface, ... },\n *     }\n *   }),\n *   ...\n *   // Since this schema references only the `Character` interface it's\n *   // necessary to explicitly list the types that implement it if\n *   // you want them to be included in the final schema.\n *   types: [humanType, droidType],\n * })\n * ```\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. `@include` and\n * `@skip`) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n * ```ts\n * const MyAppSchema = new GraphQLSchema({\n *   ...\n *   directives: specifiedDirectives.concat([ myCustomDirective ]),\n * })\n * ```\n */\nclass GraphQLSchema {\n  // Used as a cache for validateSchema().\n  constructor(config) {\n    var _config$extensionASTN, _config$directives;\n\n    // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n    this.__validationErrors = config.assumeValid === true ? [] : undefined; // Check for common mistakes during construction to produce early errors.\n\n    (0, _isObjectLike.isObjectLike)(config) || (0, _devAssert.devAssert)(false, 'Must provide configuration object.');\n    !config.types || Array.isArray(config.types) || (0, _devAssert.devAssert)(false, `\"types\" must be Array if provided but got: ${(0, _inspect.inspect)(config.types)}.`);\n    !config.directives || Array.isArray(config.directives) || (0, _devAssert.devAssert)(false, '\"directives\" must be Array if provided but got: ' + `${(0, _inspect.inspect)(config.directives)}.`);\n    this.description = config.description;\n    this.extensions = (0, _toObjMap.toObjMap)(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : _directives.specifiedDirectives; // To preserve order of user-provided types, we add first to add them to\n    // the set of \"collected\" types, so `collectReferencedTypes` ignore them.\n\n    const allReferencedTypes = new Set(config.types);\n    if (config.types != null) {\n      for (const type of config.types) {\n        // When we ready to process this type, we remove it from \"collected\" types\n        // and then add it together with all dependent types in the correct position.\n        allReferencedTypes.delete(type);\n        collectReferencedTypes(type, allReferencedTypes);\n      }\n    }\n    if (this._queryType != null) {\n      collectReferencedTypes(this._queryType, allReferencedTypes);\n    }\n    if (this._mutationType != null) {\n      collectReferencedTypes(this._mutationType, allReferencedTypes);\n    }\n    if (this._subscriptionType != null) {\n      collectReferencedTypes(this._subscriptionType, allReferencedTypes);\n    }\n    for (const directive of this._directives) {\n      // Directives are not validated until validateSchema() is called.\n      if ((0, _directives.isDirective)(directive)) {\n        for (const arg of directive.args) {\n          collectReferencedTypes(arg.type, allReferencedTypes);\n        }\n      }\n    }\n    collectReferencedTypes(_introspection.__Schema, allReferencedTypes); // Storing the resulting map for reference by the schema.\n\n    this._typeMap = Object.create(null);\n    this._subTypeMap = Object.create(null); // Keep track of all implementations by interface name.\n\n    this._implementationsMap = Object.create(null);\n    for (const namedType of allReferencedTypes) {\n      if (namedType == null) {\n        continue;\n      }\n      const typeName = namedType.name;\n      typeName || (0, _devAssert.devAssert)(false, 'One of the provided types for building the Schema is missing a name.');\n      if (this._typeMap[typeName] !== undefined) {\n        throw new Error(`Schema must contain uniquely named types but contains multiple types named \"${typeName}\".`);\n      }\n      this._typeMap[typeName] = namedType;\n      if ((0, _definition.isInterfaceType)(namedType)) {\n        // Store implementations by interface.\n        for (const iface of namedType.getInterfaces()) {\n          if ((0, _definition.isInterfaceType)(iface)) {\n            let implementations = this._implementationsMap[iface.name];\n            if (implementations === undefined) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: []\n              };\n            }\n            implementations.interfaces.push(namedType);\n          }\n        }\n      } else if ((0, _definition.isObjectType)(namedType)) {\n        // Store implementations by objects.\n        for (const iface of namedType.getInterfaces()) {\n          if ((0, _definition.isInterfaceType)(iface)) {\n            let implementations = this._implementationsMap[iface.name];\n            if (implementations === undefined) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: []\n              };\n            }\n            implementations.objects.push(namedType);\n          }\n        }\n      }\n    }\n  }\n  get [Symbol.toStringTag]() {\n    return 'GraphQLSchema';\n  }\n  getQueryType() {\n    return this._queryType;\n  }\n  getMutationType() {\n    return this._mutationType;\n  }\n  getSubscriptionType() {\n    return this._subscriptionType;\n  }\n  getRootType(operation) {\n    switch (operation) {\n      case _ast.OperationTypeNode.QUERY:\n        return this.getQueryType();\n      case _ast.OperationTypeNode.MUTATION:\n        return this.getMutationType();\n      case _ast.OperationTypeNode.SUBSCRIPTION:\n        return this.getSubscriptionType();\n    }\n  }\n  getTypeMap() {\n    return this._typeMap;\n  }\n  getType(name) {\n    return this.getTypeMap()[name];\n  }\n  getPossibleTypes(abstractType) {\n    return (0, _definition.isUnionType)(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;\n  }\n  getImplementations(interfaceType) {\n    const implementations = this._implementationsMap[interfaceType.name];\n    return implementations !== null && implementations !== void 0 ? implementations : {\n      objects: [],\n      interfaces: []\n    };\n  }\n  isSubType(abstractType, maybeSubType) {\n    let map = this._subTypeMap[abstractType.name];\n    if (map === undefined) {\n      map = Object.create(null);\n      if ((0, _definition.isUnionType)(abstractType)) {\n        for (const type of abstractType.getTypes()) {\n          map[type.name] = true;\n        }\n      } else {\n        const implementations = this.getImplementations(abstractType);\n        for (const type of implementations.objects) {\n          map[type.name] = true;\n        }\n        for (const type of implementations.interfaces) {\n          map[type.name] = true;\n        }\n      }\n      this._subTypeMap[abstractType.name] = map;\n    }\n    return map[maybeSubType.name] !== undefined;\n  }\n  getDirectives() {\n    return this._directives;\n  }\n  getDirective(name) {\n    return this.getDirectives().find(directive => directive.name === name);\n  }\n  toConfig() {\n    return {\n      description: this.description,\n      query: this.getQueryType(),\n      mutation: this.getMutationType(),\n      subscription: this.getSubscriptionType(),\n      types: Object.values(this.getTypeMap()),\n      directives: this.getDirectives(),\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n      assumeValid: this.__validationErrors !== undefined\n    };\n  }\n}\nexports.GraphQLSchema = GraphQLSchema;\nfunction collectReferencedTypes(type, typeSet) {\n  const namedType = (0, _definition.getNamedType)(type);\n  if (!typeSet.has(namedType)) {\n    typeSet.add(namedType);\n    if ((0, _definition.isUnionType)(namedType)) {\n      for (const memberType of namedType.getTypes()) {\n        collectReferencedTypes(memberType, typeSet);\n      }\n    } else if ((0, _definition.isObjectType)(namedType) || (0, _definition.isInterfaceType)(namedType)) {\n      for (const interfaceType of namedType.getInterfaces()) {\n        collectReferencedTypes(interfaceType, typeSet);\n      }\n      for (const field of Object.values(namedType.getFields())) {\n        collectReferencedTypes(field.type, typeSet);\n        for (const arg of field.args) {\n          collectReferencedTypes(arg.type, typeSet);\n        }\n      }\n    } else if ((0, _definition.isInputObjectType)(namedType)) {\n      for (const field of Object.values(namedType.getFields())) {\n        collectReferencedTypes(field.type, typeSet);\n      }\n    }\n  }\n  return typeSet;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","GraphQLSchema","assertSchema","isSchema","_devAssert","require","_inspect","_instanceOf","_isObjectLike","_toObjMap","_ast","_definition","_directives","_introspection","schema","instanceOf","Error","inspect","constructor","config","_config$extensionASTN","_config$directives","__validationErrors","assumeValid","undefined","isObjectLike","devAssert","types","Array","isArray","directives","description","extensions","toObjMap","astNode","extensionASTNodes","_queryType","query","_mutationType","mutation","_subscriptionType","subscription","specifiedDirectives","allReferencedTypes","Set","type","delete","collectReferencedTypes","directive","isDirective","arg","args","__Schema","_typeMap","create","_subTypeMap","_implementationsMap","namedType","typeName","name","isInterfaceType","iface","getInterfaces","implementations","objects","interfaces","push","isObjectType","Symbol","toStringTag","getQueryType","getMutationType","getSubscriptionType","getRootType","operation","OperationTypeNode","QUERY","MUTATION","SUBSCRIPTION","getTypeMap","getType","getPossibleTypes","abstractType","isUnionType","getTypes","getImplementations","interfaceType","isSubType","maybeSubType","map","getDirectives","getDirective","find","toConfig","values","typeSet","getNamedType","has","add","memberType","field","getFields","isInputObjectType"],"sources":["/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/graphql/type/schema.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.GraphQLSchema = void 0;\nexports.assertSchema = assertSchema;\nexports.isSchema = isSchema;\n\nvar _devAssert = require('../jsutils/devAssert.js');\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _instanceOf = require('../jsutils/instanceOf.js');\n\nvar _isObjectLike = require('../jsutils/isObjectLike.js');\n\nvar _toObjMap = require('../jsutils/toObjMap.js');\n\nvar _ast = require('../language/ast.js');\n\nvar _definition = require('./definition.js');\n\nvar _directives = require('./directives.js');\n\nvar _introspection = require('./introspection.js');\n\n/**\n * Test if the given value is a GraphQL schema.\n */\nfunction isSchema(schema) {\n  return (0, _instanceOf.instanceOf)(schema, GraphQLSchema);\n}\n\nfunction assertSchema(schema) {\n  if (!isSchema(schema)) {\n    throw new Error(\n      `Expected ${(0, _inspect.inspect)(schema)} to be a GraphQL schema.`,\n    );\n  }\n\n  return schema;\n}\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\n\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n * ```ts\n * const MyAppSchema = new GraphQLSchema({\n *   query: MyAppQueryRootType,\n *   mutation: MyAppMutationRootType,\n * })\n * ```\n *\n * Note: When the schema is constructed, by default only the types that are\n * reachable by traversing the root types are included, other types must be\n * explicitly referenced.\n *\n * Example:\n *\n * ```ts\n * const characterInterface = new GraphQLInterfaceType({\n *   name: 'Character',\n *   ...\n * });\n *\n * const humanType = new GraphQLObjectType({\n *   name: 'Human',\n *   interfaces: [characterInterface],\n *   ...\n * });\n *\n * const droidType = new GraphQLObjectType({\n *   name: 'Droid',\n *   interfaces: [characterInterface],\n *   ...\n * });\n *\n * const schema = new GraphQLSchema({\n *   query: new GraphQLObjectType({\n *     name: 'Query',\n *     fields: {\n *       hero: { type: characterInterface, ... },\n *     }\n *   }),\n *   ...\n *   // Since this schema references only the `Character` interface it's\n *   // necessary to explicitly list the types that implement it if\n *   // you want them to be included in the final schema.\n *   types: [humanType, droidType],\n * })\n * ```\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. `@include` and\n * `@skip`) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n * ```ts\n * const MyAppSchema = new GraphQLSchema({\n *   ...\n *   directives: specifiedDirectives.concat([ myCustomDirective ]),\n * })\n * ```\n */\nclass GraphQLSchema {\n  // Used as a cache for validateSchema().\n  constructor(config) {\n    var _config$extensionASTN, _config$directives;\n\n    // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n    this.__validationErrors = config.assumeValid === true ? [] : undefined; // Check for common mistakes during construction to produce early errors.\n\n    (0, _isObjectLike.isObjectLike)(config) ||\n      (0, _devAssert.devAssert)(false, 'Must provide configuration object.');\n    !config.types ||\n      Array.isArray(config.types) ||\n      (0, _devAssert.devAssert)(\n        false,\n        `\"types\" must be Array if provided but got: ${(0, _inspect.inspect)(\n          config.types,\n        )}.`,\n      );\n    !config.directives ||\n      Array.isArray(config.directives) ||\n      (0, _devAssert.devAssert)(\n        false,\n        '\"directives\" must be Array if provided but got: ' +\n          `${(0, _inspect.inspect)(config.directives)}.`,\n      );\n    this.description = config.description;\n    this.extensions = (0, _toObjMap.toObjMap)(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes =\n      (_config$extensionASTN = config.extensionASTNodes) !== null &&\n      _config$extensionASTN !== void 0\n        ? _config$extensionASTN\n        : [];\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives =\n      (_config$directives = config.directives) !== null &&\n      _config$directives !== void 0\n        ? _config$directives\n        : _directives.specifiedDirectives; // To preserve order of user-provided types, we add first to add them to\n    // the set of \"collected\" types, so `collectReferencedTypes` ignore them.\n\n    const allReferencedTypes = new Set(config.types);\n\n    if (config.types != null) {\n      for (const type of config.types) {\n        // When we ready to process this type, we remove it from \"collected\" types\n        // and then add it together with all dependent types in the correct position.\n        allReferencedTypes.delete(type);\n        collectReferencedTypes(type, allReferencedTypes);\n      }\n    }\n\n    if (this._queryType != null) {\n      collectReferencedTypes(this._queryType, allReferencedTypes);\n    }\n\n    if (this._mutationType != null) {\n      collectReferencedTypes(this._mutationType, allReferencedTypes);\n    }\n\n    if (this._subscriptionType != null) {\n      collectReferencedTypes(this._subscriptionType, allReferencedTypes);\n    }\n\n    for (const directive of this._directives) {\n      // Directives are not validated until validateSchema() is called.\n      if ((0, _directives.isDirective)(directive)) {\n        for (const arg of directive.args) {\n          collectReferencedTypes(arg.type, allReferencedTypes);\n        }\n      }\n    }\n\n    collectReferencedTypes(_introspection.__Schema, allReferencedTypes); // Storing the resulting map for reference by the schema.\n\n    this._typeMap = Object.create(null);\n    this._subTypeMap = Object.create(null); // Keep track of all implementations by interface name.\n\n    this._implementationsMap = Object.create(null);\n\n    for (const namedType of allReferencedTypes) {\n      if (namedType == null) {\n        continue;\n      }\n\n      const typeName = namedType.name;\n      typeName ||\n        (0, _devAssert.devAssert)(\n          false,\n          'One of the provided types for building the Schema is missing a name.',\n        );\n\n      if (this._typeMap[typeName] !== undefined) {\n        throw new Error(\n          `Schema must contain uniquely named types but contains multiple types named \"${typeName}\".`,\n        );\n      }\n\n      this._typeMap[typeName] = namedType;\n\n      if ((0, _definition.isInterfaceType)(namedType)) {\n        // Store implementations by interface.\n        for (const iface of namedType.getInterfaces()) {\n          if ((0, _definition.isInterfaceType)(iface)) {\n            let implementations = this._implementationsMap[iface.name];\n\n            if (implementations === undefined) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: [],\n              };\n            }\n\n            implementations.interfaces.push(namedType);\n          }\n        }\n      } else if ((0, _definition.isObjectType)(namedType)) {\n        // Store implementations by objects.\n        for (const iface of namedType.getInterfaces()) {\n          if ((0, _definition.isInterfaceType)(iface)) {\n            let implementations = this._implementationsMap[iface.name];\n\n            if (implementations === undefined) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: [],\n              };\n            }\n\n            implementations.objects.push(namedType);\n          }\n        }\n      }\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLSchema';\n  }\n\n  getQueryType() {\n    return this._queryType;\n  }\n\n  getMutationType() {\n    return this._mutationType;\n  }\n\n  getSubscriptionType() {\n    return this._subscriptionType;\n  }\n\n  getRootType(operation) {\n    switch (operation) {\n      case _ast.OperationTypeNode.QUERY:\n        return this.getQueryType();\n\n      case _ast.OperationTypeNode.MUTATION:\n        return this.getMutationType();\n\n      case _ast.OperationTypeNode.SUBSCRIPTION:\n        return this.getSubscriptionType();\n    }\n  }\n\n  getTypeMap() {\n    return this._typeMap;\n  }\n\n  getType(name) {\n    return this.getTypeMap()[name];\n  }\n\n  getPossibleTypes(abstractType) {\n    return (0, _definition.isUnionType)(abstractType)\n      ? abstractType.getTypes()\n      : this.getImplementations(abstractType).objects;\n  }\n\n  getImplementations(interfaceType) {\n    const implementations = this._implementationsMap[interfaceType.name];\n    return implementations !== null && implementations !== void 0\n      ? implementations\n      : {\n          objects: [],\n          interfaces: [],\n        };\n  }\n\n  isSubType(abstractType, maybeSubType) {\n    let map = this._subTypeMap[abstractType.name];\n\n    if (map === undefined) {\n      map = Object.create(null);\n\n      if ((0, _definition.isUnionType)(abstractType)) {\n        for (const type of abstractType.getTypes()) {\n          map[type.name] = true;\n        }\n      } else {\n        const implementations = this.getImplementations(abstractType);\n\n        for (const type of implementations.objects) {\n          map[type.name] = true;\n        }\n\n        for (const type of implementations.interfaces) {\n          map[type.name] = true;\n        }\n      }\n\n      this._subTypeMap[abstractType.name] = map;\n    }\n\n    return map[maybeSubType.name] !== undefined;\n  }\n\n  getDirectives() {\n    return this._directives;\n  }\n\n  getDirective(name) {\n    return this.getDirectives().find((directive) => directive.name === name);\n  }\n\n  toConfig() {\n    return {\n      description: this.description,\n      query: this.getQueryType(),\n      mutation: this.getMutationType(),\n      subscription: this.getSubscriptionType(),\n      types: Object.values(this.getTypeMap()),\n      directives: this.getDirectives(),\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n      assumeValid: this.__validationErrors !== undefined,\n    };\n  }\n}\n\nexports.GraphQLSchema = GraphQLSchema;\n\nfunction collectReferencedTypes(type, typeSet) {\n  const namedType = (0, _definition.getNamedType)(type);\n\n  if (!typeSet.has(namedType)) {\n    typeSet.add(namedType);\n\n    if ((0, _definition.isUnionType)(namedType)) {\n      for (const memberType of namedType.getTypes()) {\n        collectReferencedTypes(memberType, typeSet);\n      }\n    } else if (\n      (0, _definition.isObjectType)(namedType) ||\n      (0, _definition.isInterfaceType)(namedType)\n    ) {\n      for (const interfaceType of namedType.getInterfaces()) {\n        collectReferencedTypes(interfaceType, typeSet);\n      }\n\n      for (const field of Object.values(namedType.getFields())) {\n        collectReferencedTypes(field.type, typeSet);\n\n        for (const arg of field.args) {\n          collectReferencedTypes(arg.type, typeSet);\n        }\n      }\n    } else if ((0, _definition.isInputObjectType)(namedType)) {\n      for (const field of Object.values(namedType.getFields())) {\n        collectReferencedTypes(field.type, typeSet);\n      }\n    }\n  }\n\n  return typeSet;\n}\n"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,aAAa,GAAG,KAAK,CAAC;AAC9BF,OAAO,CAACG,YAAY,GAAGA,YAAY;AACnCH,OAAO,CAACI,QAAQ,GAAGA,QAAQ;AAE3B,IAAIC,UAAU,GAAGC,OAAO,CAAC,yBAAyB,CAAC;AAEnD,IAAIC,QAAQ,GAAGD,OAAO,CAAC,uBAAuB,CAAC;AAE/C,IAAIE,WAAW,GAAGF,OAAO,CAAC,0BAA0B,CAAC;AAErD,IAAIG,aAAa,GAAGH,OAAO,CAAC,4BAA4B,CAAC;AAEzD,IAAII,SAAS,GAAGJ,OAAO,CAAC,wBAAwB,CAAC;AAEjD,IAAIK,IAAI,GAAGL,OAAO,CAAC,oBAAoB,CAAC;AAExC,IAAIM,WAAW,GAAGN,OAAO,CAAC,iBAAiB,CAAC;AAE5C,IAAIO,WAAW,GAAGP,OAAO,CAAC,iBAAiB,CAAC;AAE5C,IAAIQ,cAAc,GAAGR,OAAO,CAAC,oBAAoB,CAAC;;AAElD;AACA;AACA;AACA,SAASF,QAAQ,CAACW,MAAM,EAAE;EACxB,OAAO,CAAC,CAAC,EAAEP,WAAW,CAACQ,UAAU,EAAED,MAAM,EAAEb,aAAa,CAAC;AAC3D;AAEA,SAASC,YAAY,CAACY,MAAM,EAAE;EAC5B,IAAI,CAACX,QAAQ,CAACW,MAAM,CAAC,EAAE;IACrB,MAAM,IAAIE,KAAK,CACZ,YAAW,CAAC,CAAC,EAAEV,QAAQ,CAACW,OAAO,EAAEH,MAAM,CAAE,0BAAyB,CACpE;EACH;EAEA,OAAOA,MAAM;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMb,aAAa,CAAC;EAClB;EACAiB,WAAW,CAACC,MAAM,EAAE;IAClB,IAAIC,qBAAqB,EAAEC,kBAAkB;;IAE7C;IACA;IACA,IAAI,CAACC,kBAAkB,GAAGH,MAAM,CAACI,WAAW,KAAK,IAAI,GAAG,EAAE,GAAGC,SAAS,CAAC,CAAC;;IAExE,CAAC,CAAC,EAAEhB,aAAa,CAACiB,YAAY,EAAEN,MAAM,CAAC,IACrC,CAAC,CAAC,EAAEf,UAAU,CAACsB,SAAS,EAAE,KAAK,EAAE,oCAAoC,CAAC;IACxE,CAACP,MAAM,CAACQ,KAAK,IACXC,KAAK,CAACC,OAAO,CAACV,MAAM,CAACQ,KAAK,CAAC,IAC3B,CAAC,CAAC,EAAEvB,UAAU,CAACsB,SAAS,EACtB,KAAK,EACJ,8CAA6C,CAAC,CAAC,EAAEpB,QAAQ,CAACW,OAAO,EAChEE,MAAM,CAACQ,KAAK,CACZ,GAAE,CACL;IACH,CAACR,MAAM,CAACW,UAAU,IAChBF,KAAK,CAACC,OAAO,CAACV,MAAM,CAACW,UAAU,CAAC,IAChC,CAAC,CAAC,EAAE1B,UAAU,CAACsB,SAAS,EACtB,KAAK,EACL,kDAAkD,GAC/C,GAAE,CAAC,CAAC,EAAEpB,QAAQ,CAACW,OAAO,EAAEE,MAAM,CAACW,UAAU,CAAE,GAAE,CACjD;IACH,IAAI,CAACC,WAAW,GAAGZ,MAAM,CAACY,WAAW;IACrC,IAAI,CAACC,UAAU,GAAG,CAAC,CAAC,EAAEvB,SAAS,CAACwB,QAAQ,EAAEd,MAAM,CAACa,UAAU,CAAC;IAC5D,IAAI,CAACE,OAAO,GAAGf,MAAM,CAACe,OAAO;IAC7B,IAAI,CAACC,iBAAiB,GACpB,CAACf,qBAAqB,GAAGD,MAAM,CAACgB,iBAAiB,MAAM,IAAI,IAC3Df,qBAAqB,KAAK,KAAK,CAAC,GAC5BA,qBAAqB,GACrB,EAAE;IACR,IAAI,CAACgB,UAAU,GAAGjB,MAAM,CAACkB,KAAK;IAC9B,IAAI,CAACC,aAAa,GAAGnB,MAAM,CAACoB,QAAQ;IACpC,IAAI,CAACC,iBAAiB,GAAGrB,MAAM,CAACsB,YAAY,CAAC,CAAC;;IAE9C,IAAI,CAAC7B,WAAW,GACd,CAACS,kBAAkB,GAAGF,MAAM,CAACW,UAAU,MAAM,IAAI,IACjDT,kBAAkB,KAAK,KAAK,CAAC,GACzBA,kBAAkB,GAClBT,WAAW,CAAC8B,mBAAmB,CAAC,CAAC;IACvC;;IAEA,MAAMC,kBAAkB,GAAG,IAAIC,GAAG,CAACzB,MAAM,CAACQ,KAAK,CAAC;IAEhD,IAAIR,MAAM,CAACQ,KAAK,IAAI,IAAI,EAAE;MACxB,KAAK,MAAMkB,IAAI,IAAI1B,MAAM,CAACQ,KAAK,EAAE;QAC/B;QACA;QACAgB,kBAAkB,CAACG,MAAM,CAACD,IAAI,CAAC;QAC/BE,sBAAsB,CAACF,IAAI,EAAEF,kBAAkB,CAAC;MAClD;IACF;IAEA,IAAI,IAAI,CAACP,UAAU,IAAI,IAAI,EAAE;MAC3BW,sBAAsB,CAAC,IAAI,CAACX,UAAU,EAAEO,kBAAkB,CAAC;IAC7D;IAEA,IAAI,IAAI,CAACL,aAAa,IAAI,IAAI,EAAE;MAC9BS,sBAAsB,CAAC,IAAI,CAACT,aAAa,EAAEK,kBAAkB,CAAC;IAChE;IAEA,IAAI,IAAI,CAACH,iBAAiB,IAAI,IAAI,EAAE;MAClCO,sBAAsB,CAAC,IAAI,CAACP,iBAAiB,EAAEG,kBAAkB,CAAC;IACpE;IAEA,KAAK,MAAMK,SAAS,IAAI,IAAI,CAACpC,WAAW,EAAE;MACxC;MACA,IAAI,CAAC,CAAC,EAAEA,WAAW,CAACqC,WAAW,EAAED,SAAS,CAAC,EAAE;QAC3C,KAAK,MAAME,GAAG,IAAIF,SAAS,CAACG,IAAI,EAAE;UAChCJ,sBAAsB,CAACG,GAAG,CAACL,IAAI,EAAEF,kBAAkB,CAAC;QACtD;MACF;IACF;IAEAI,sBAAsB,CAAClC,cAAc,CAACuC,QAAQ,EAAET,kBAAkB,CAAC,CAAC,CAAC;;IAErE,IAAI,CAACU,QAAQ,GAAGxD,MAAM,CAACyD,MAAM,CAAC,IAAI,CAAC;IACnC,IAAI,CAACC,WAAW,GAAG1D,MAAM,CAACyD,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;;IAExC,IAAI,CAACE,mBAAmB,GAAG3D,MAAM,CAACyD,MAAM,CAAC,IAAI,CAAC;IAE9C,KAAK,MAAMG,SAAS,IAAId,kBAAkB,EAAE;MAC1C,IAAIc,SAAS,IAAI,IAAI,EAAE;QACrB;MACF;MAEA,MAAMC,QAAQ,GAAGD,SAAS,CAACE,IAAI;MAC/BD,QAAQ,IACN,CAAC,CAAC,EAAEtD,UAAU,CAACsB,SAAS,EACtB,KAAK,EACL,sEAAsE,CACvE;MAEH,IAAI,IAAI,CAAC2B,QAAQ,CAACK,QAAQ,CAAC,KAAKlC,SAAS,EAAE;QACzC,MAAM,IAAIR,KAAK,CACZ,+EAA8E0C,QAAS,IAAG,CAC5F;MACH;MAEA,IAAI,CAACL,QAAQ,CAACK,QAAQ,CAAC,GAAGD,SAAS;MAEnC,IAAI,CAAC,CAAC,EAAE9C,WAAW,CAACiD,eAAe,EAAEH,SAAS,CAAC,EAAE;QAC/C;QACA,KAAK,MAAMI,KAAK,IAAIJ,SAAS,CAACK,aAAa,EAAE,EAAE;UAC7C,IAAI,CAAC,CAAC,EAAEnD,WAAW,CAACiD,eAAe,EAAEC,KAAK,CAAC,EAAE;YAC3C,IAAIE,eAAe,GAAG,IAAI,CAACP,mBAAmB,CAACK,KAAK,CAACF,IAAI,CAAC;YAE1D,IAAII,eAAe,KAAKvC,SAAS,EAAE;cACjCuC,eAAe,GAAG,IAAI,CAACP,mBAAmB,CAACK,KAAK,CAACF,IAAI,CAAC,GAAG;gBACvDK,OAAO,EAAE,EAAE;gBACXC,UAAU,EAAE;cACd,CAAC;YACH;YAEAF,eAAe,CAACE,UAAU,CAACC,IAAI,CAACT,SAAS,CAAC;UAC5C;QACF;MACF,CAAC,MAAM,IAAI,CAAC,CAAC,EAAE9C,WAAW,CAACwD,YAAY,EAAEV,SAAS,CAAC,EAAE;QACnD;QACA,KAAK,MAAMI,KAAK,IAAIJ,SAAS,CAACK,aAAa,EAAE,EAAE;UAC7C,IAAI,CAAC,CAAC,EAAEnD,WAAW,CAACiD,eAAe,EAAEC,KAAK,CAAC,EAAE;YAC3C,IAAIE,eAAe,GAAG,IAAI,CAACP,mBAAmB,CAACK,KAAK,CAACF,IAAI,CAAC;YAE1D,IAAII,eAAe,KAAKvC,SAAS,EAAE;cACjCuC,eAAe,GAAG,IAAI,CAACP,mBAAmB,CAACK,KAAK,CAACF,IAAI,CAAC,GAAG;gBACvDK,OAAO,EAAE,EAAE;gBACXC,UAAU,EAAE;cACd,CAAC;YACH;YAEAF,eAAe,CAACC,OAAO,CAACE,IAAI,CAACT,SAAS,CAAC;UACzC;QACF;MACF;IACF;EACF;EAEA,KAAKW,MAAM,CAACC,WAAW,IAAI;IACzB,OAAO,eAAe;EACxB;EAEAC,YAAY,GAAG;IACb,OAAO,IAAI,CAAClC,UAAU;EACxB;EAEAmC,eAAe,GAAG;IAChB,OAAO,IAAI,CAACjC,aAAa;EAC3B;EAEAkC,mBAAmB,GAAG;IACpB,OAAO,IAAI,CAAChC,iBAAiB;EAC/B;EAEAiC,WAAW,CAACC,SAAS,EAAE;IACrB,QAAQA,SAAS;MACf,KAAKhE,IAAI,CAACiE,iBAAiB,CAACC,KAAK;QAC/B,OAAO,IAAI,CAACN,YAAY,EAAE;MAE5B,KAAK5D,IAAI,CAACiE,iBAAiB,CAACE,QAAQ;QAClC,OAAO,IAAI,CAACN,eAAe,EAAE;MAE/B,KAAK7D,IAAI,CAACiE,iBAAiB,CAACG,YAAY;QACtC,OAAO,IAAI,CAACN,mBAAmB,EAAE;IAAC;EAExC;EAEAO,UAAU,GAAG;IACX,OAAO,IAAI,CAAC1B,QAAQ;EACtB;EAEA2B,OAAO,CAACrB,IAAI,EAAE;IACZ,OAAO,IAAI,CAACoB,UAAU,EAAE,CAACpB,IAAI,CAAC;EAChC;EAEAsB,gBAAgB,CAACC,YAAY,EAAE;IAC7B,OAAO,CAAC,CAAC,EAAEvE,WAAW,CAACwE,WAAW,EAAED,YAAY,CAAC,GAC7CA,YAAY,CAACE,QAAQ,EAAE,GACvB,IAAI,CAACC,kBAAkB,CAACH,YAAY,CAAC,CAAClB,OAAO;EACnD;EAEAqB,kBAAkB,CAACC,aAAa,EAAE;IAChC,MAAMvB,eAAe,GAAG,IAAI,CAACP,mBAAmB,CAAC8B,aAAa,CAAC3B,IAAI,CAAC;IACpE,OAAOI,eAAe,KAAK,IAAI,IAAIA,eAAe,KAAK,KAAK,CAAC,GACzDA,eAAe,GACf;MACEC,OAAO,EAAE,EAAE;MACXC,UAAU,EAAE;IACd,CAAC;EACP;EAEAsB,SAAS,CAACL,YAAY,EAAEM,YAAY,EAAE;IACpC,IAAIC,GAAG,GAAG,IAAI,CAAClC,WAAW,CAAC2B,YAAY,CAACvB,IAAI,CAAC;IAE7C,IAAI8B,GAAG,KAAKjE,SAAS,EAAE;MACrBiE,GAAG,GAAG5F,MAAM,CAACyD,MAAM,CAAC,IAAI,CAAC;MAEzB,IAAI,CAAC,CAAC,EAAE3C,WAAW,CAACwE,WAAW,EAAED,YAAY,CAAC,EAAE;QAC9C,KAAK,MAAMrC,IAAI,IAAIqC,YAAY,CAACE,QAAQ,EAAE,EAAE;UAC1CK,GAAG,CAAC5C,IAAI,CAACc,IAAI,CAAC,GAAG,IAAI;QACvB;MACF,CAAC,MAAM;QACL,MAAMI,eAAe,GAAG,IAAI,CAACsB,kBAAkB,CAACH,YAAY,CAAC;QAE7D,KAAK,MAAMrC,IAAI,IAAIkB,eAAe,CAACC,OAAO,EAAE;UAC1CyB,GAAG,CAAC5C,IAAI,CAACc,IAAI,CAAC,GAAG,IAAI;QACvB;QAEA,KAAK,MAAMd,IAAI,IAAIkB,eAAe,CAACE,UAAU,EAAE;UAC7CwB,GAAG,CAAC5C,IAAI,CAACc,IAAI,CAAC,GAAG,IAAI;QACvB;MACF;MAEA,IAAI,CAACJ,WAAW,CAAC2B,YAAY,CAACvB,IAAI,CAAC,GAAG8B,GAAG;IAC3C;IAEA,OAAOA,GAAG,CAACD,YAAY,CAAC7B,IAAI,CAAC,KAAKnC,SAAS;EAC7C;EAEAkE,aAAa,GAAG;IACd,OAAO,IAAI,CAAC9E,WAAW;EACzB;EAEA+E,YAAY,CAAChC,IAAI,EAAE;IACjB,OAAO,IAAI,CAAC+B,aAAa,EAAE,CAACE,IAAI,CAAE5C,SAAS,IAAKA,SAAS,CAACW,IAAI,KAAKA,IAAI,CAAC;EAC1E;EAEAkC,QAAQ,GAAG;IACT,OAAO;MACL9D,WAAW,EAAE,IAAI,CAACA,WAAW;MAC7BM,KAAK,EAAE,IAAI,CAACiC,YAAY,EAAE;MAC1B/B,QAAQ,EAAE,IAAI,CAACgC,eAAe,EAAE;MAChC9B,YAAY,EAAE,IAAI,CAAC+B,mBAAmB,EAAE;MACxC7C,KAAK,EAAE9B,MAAM,CAACiG,MAAM,CAAC,IAAI,CAACf,UAAU,EAAE,CAAC;MACvCjD,UAAU,EAAE,IAAI,CAAC4D,aAAa,EAAE;MAChC1D,UAAU,EAAE,IAAI,CAACA,UAAU;MAC3BE,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBC,iBAAiB,EAAE,IAAI,CAACA,iBAAiB;MACzCZ,WAAW,EAAE,IAAI,CAACD,kBAAkB,KAAKE;IAC3C,CAAC;EACH;AACF;AAEAzB,OAAO,CAACE,aAAa,GAAGA,aAAa;AAErC,SAAS8C,sBAAsB,CAACF,IAAI,EAAEkD,OAAO,EAAE;EAC7C,MAAMtC,SAAS,GAAG,CAAC,CAAC,EAAE9C,WAAW,CAACqF,YAAY,EAAEnD,IAAI,CAAC;EAErD,IAAI,CAACkD,OAAO,CAACE,GAAG,CAACxC,SAAS,CAAC,EAAE;IAC3BsC,OAAO,CAACG,GAAG,CAACzC,SAAS,CAAC;IAEtB,IAAI,CAAC,CAAC,EAAE9C,WAAW,CAACwE,WAAW,EAAE1B,SAAS,CAAC,EAAE;MAC3C,KAAK,MAAM0C,UAAU,IAAI1C,SAAS,CAAC2B,QAAQ,EAAE,EAAE;QAC7CrC,sBAAsB,CAACoD,UAAU,EAAEJ,OAAO,CAAC;MAC7C;IACF,CAAC,MAAM,IACL,CAAC,CAAC,EAAEpF,WAAW,CAACwD,YAAY,EAAEV,SAAS,CAAC,IACxC,CAAC,CAAC,EAAE9C,WAAW,CAACiD,eAAe,EAAEH,SAAS,CAAC,EAC3C;MACA,KAAK,MAAM6B,aAAa,IAAI7B,SAAS,CAACK,aAAa,EAAE,EAAE;QACrDf,sBAAsB,CAACuC,aAAa,EAAES,OAAO,CAAC;MAChD;MAEA,KAAK,MAAMK,KAAK,IAAIvG,MAAM,CAACiG,MAAM,CAACrC,SAAS,CAAC4C,SAAS,EAAE,CAAC,EAAE;QACxDtD,sBAAsB,CAACqD,KAAK,CAACvD,IAAI,EAAEkD,OAAO,CAAC;QAE3C,KAAK,MAAM7C,GAAG,IAAIkD,KAAK,CAACjD,IAAI,EAAE;UAC5BJ,sBAAsB,CAACG,GAAG,CAACL,IAAI,EAAEkD,OAAO,CAAC;QAC3C;MACF;IACF,CAAC,MAAM,IAAI,CAAC,CAAC,EAAEpF,WAAW,CAAC2F,iBAAiB,EAAE7C,SAAS,CAAC,EAAE;MACxD,KAAK,MAAM2C,KAAK,IAAIvG,MAAM,CAACiG,MAAM,CAACrC,SAAS,CAAC4C,SAAS,EAAE,CAAC,EAAE;QACxDtD,sBAAsB,CAACqD,KAAK,CAACvD,IAAI,EAAEkD,OAAO,CAAC;MAC7C;IACF;EACF;EAEA,OAAOA,OAAO;AAChB"},"metadata":{},"sourceType":"script","externalDependencies":[]}