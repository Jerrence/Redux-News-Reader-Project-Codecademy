{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.getArgumentValues = getArgumentValues;\nexports.getDirectiveValues = getDirectiveValues;\nexports.getVariableValues = getVariableValues;\nvar _inspect = require('../jsutils/inspect.js');\nvar _keyMap = require('../jsutils/keyMap.js');\nvar _printPathArray = require('../jsutils/printPathArray.js');\nvar _GraphQLError = require('../error/GraphQLError.js');\nvar _kinds = require('../language/kinds.js');\nvar _printer = require('../language/printer.js');\nvar _definition = require('../type/definition.js');\nvar _coerceInputValue = require('../utilities/coerceInputValue.js');\nvar _typeFromAST = require('../utilities/typeFromAST.js');\nvar _valueFromAST = require('../utilities/valueFromAST.js');\n\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nfunction getVariableValues(schema, varDefNodes, inputs, options) {\n  const errors = [];\n  const maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors;\n  try {\n    const coerced = coerceVariableValues(schema, varDefNodes, inputs, error => {\n      if (maxErrors != null && errors.length >= maxErrors) {\n        throw new _GraphQLError.GraphQLError('Too many errors processing variables, error limit reached. Execution aborted.');\n      }\n      errors.push(error);\n    });\n    if (errors.length === 0) {\n      return {\n        coerced\n      };\n    }\n  } catch (error) {\n    errors.push(error);\n  }\n  return {\n    errors\n  };\n}\nfunction coerceVariableValues(schema, varDefNodes, inputs, onError) {\n  const coercedValues = {};\n  for (const varDefNode of varDefNodes) {\n    const varName = varDefNode.variable.name.value;\n    const varType = (0, _typeFromAST.typeFromAST)(schema, varDefNode.type);\n    if (!(0, _definition.isInputType)(varType)) {\n      // Must use input types for variables. This should be caught during\n      // validation, however is checked again here for safety.\n      const varTypeStr = (0, _printer.print)(varDefNode.type);\n      onError(new _GraphQLError.GraphQLError(`Variable \"$${varName}\" expected value of type \"${varTypeStr}\" which cannot be used as an input type.`, {\n        nodes: varDefNode.type\n      }));\n      continue;\n    }\n    if (!hasOwnProperty(inputs, varName)) {\n      if (varDefNode.defaultValue) {\n        coercedValues[varName] = (0, _valueFromAST.valueFromAST)(varDefNode.defaultValue, varType);\n      } else if ((0, _definition.isNonNullType)(varType)) {\n        const varTypeStr = (0, _inspect.inspect)(varType);\n        onError(new _GraphQLError.GraphQLError(`Variable \"$${varName}\" of required type \"${varTypeStr}\" was not provided.`, {\n          nodes: varDefNode\n        }));\n      }\n      continue;\n    }\n    const value = inputs[varName];\n    if (value === null && (0, _definition.isNonNullType)(varType)) {\n      const varTypeStr = (0, _inspect.inspect)(varType);\n      onError(new _GraphQLError.GraphQLError(`Variable \"$${varName}\" of non-null type \"${varTypeStr}\" must not be null.`, {\n        nodes: varDefNode\n      }));\n      continue;\n    }\n    coercedValues[varName] = (0, _coerceInputValue.coerceInputValue)(value, varType, (path, invalidValue, error) => {\n      let prefix = `Variable \"$${varName}\" got invalid value ` + (0, _inspect.inspect)(invalidValue);\n      if (path.length > 0) {\n        prefix += ` at \"${varName}${(0, _printPathArray.printPathArray)(path)}\"`;\n      }\n      onError(new _GraphQLError.GraphQLError(prefix + '; ' + error.message, {\n        nodes: varDefNode,\n        originalError: error.originalError\n      }));\n    });\n  }\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nfunction getArgumentValues(def, node, variableValues) {\n  var _node$arguments;\n  const coercedValues = {}; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n\n  const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];\n  const argNodeMap = (0, _keyMap.keyMap)(argumentNodes, arg => arg.name.value);\n  for (const argDef of def.args) {\n    const name = argDef.name;\n    const argType = argDef.type;\n    const argumentNode = argNodeMap[name];\n    if (!argumentNode) {\n      if (argDef.defaultValue !== undefined) {\n        coercedValues[name] = argDef.defaultValue;\n      } else if ((0, _definition.isNonNullType)(argType)) {\n        throw new _GraphQLError.GraphQLError(`Argument \"${name}\" of required type \"${(0, _inspect.inspect)(argType)}\" ` + 'was not provided.', {\n          nodes: node\n        });\n      }\n      continue;\n    }\n    const valueNode = argumentNode.value;\n    let isNull = valueNode.kind === _kinds.Kind.NULL;\n    if (valueNode.kind === _kinds.Kind.VARIABLE) {\n      const variableName = valueNode.name.value;\n      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {\n        if (argDef.defaultValue !== undefined) {\n          coercedValues[name] = argDef.defaultValue;\n        } else if ((0, _definition.isNonNullType)(argType)) {\n          throw new _GraphQLError.GraphQLError(`Argument \"${name}\" of required type \"${(0, _inspect.inspect)(argType)}\" ` + `was provided the variable \"$${variableName}\" which was not provided a runtime value.`, {\n            nodes: valueNode\n          });\n        }\n        continue;\n      }\n      isNull = variableValues[variableName] == null;\n    }\n    if (isNull && (0, _definition.isNonNullType)(argType)) {\n      throw new _GraphQLError.GraphQLError(`Argument \"${name}\" of non-null type \"${(0, _inspect.inspect)(argType)}\" ` + 'must not be null.', {\n        nodes: valueNode\n      });\n    }\n    const coercedValue = (0, _valueFromAST.valueFromAST)(valueNode, argType, variableValues);\n    if (coercedValue === undefined) {\n      // Note: ValuesOfCorrectTypeRule validation should catch this before\n      // execution. This is a runtime check to ensure execution does not\n      // continue with an invalid argument value.\n      throw new _GraphQLError.GraphQLError(`Argument \"${name}\" has invalid value ${(0, _printer.print)(valueNode)}.`, {\n        nodes: valueNode\n      });\n    }\n    coercedValues[name] = coercedValue;\n  }\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a directive definition\n * and a AST node which may contain directives. Optionally also accepts a map\n * of variable values.\n *\n * If the directive does not exist on the node, returns undefined.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nfunction getDirectiveValues(directiveDef, node, variableValues) {\n  var _node$directives;\n  const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(directive => directive.name.value === directiveDef.name);\n  if (directiveNode) {\n    return getArgumentValues(directiveDef, directiveNode, variableValues);\n  }\n}\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","getArgumentValues","getDirectiveValues","getVariableValues","_inspect","require","_keyMap","_printPathArray","_GraphQLError","_kinds","_printer","_definition","_coerceInputValue","_typeFromAST","_valueFromAST","schema","varDefNodes","inputs","options","errors","maxErrors","coerced","coerceVariableValues","error","length","GraphQLError","push","onError","coercedValues","varDefNode","varName","variable","name","varType","typeFromAST","type","isInputType","varTypeStr","print","nodes","hasOwnProperty","defaultValue","valueFromAST","isNonNullType","inspect","coerceInputValue","path","invalidValue","prefix","printPathArray","message","originalError","def","node","variableValues","_node$arguments","argumentNodes","arguments","argNodeMap","keyMap","arg","argDef","args","argType","argumentNode","undefined","valueNode","isNull","kind","Kind","NULL","VARIABLE","variableName","coercedValue","directiveDef","_node$directives","directiveNode","directives","find","directive","obj","prop","prototype","call"],"sources":["/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/graphql/execution/values.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.getArgumentValues = getArgumentValues;\nexports.getDirectiveValues = getDirectiveValues;\nexports.getVariableValues = getVariableValues;\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _keyMap = require('../jsutils/keyMap.js');\n\nvar _printPathArray = require('../jsutils/printPathArray.js');\n\nvar _GraphQLError = require('../error/GraphQLError.js');\n\nvar _kinds = require('../language/kinds.js');\n\nvar _printer = require('../language/printer.js');\n\nvar _definition = require('../type/definition.js');\n\nvar _coerceInputValue = require('../utilities/coerceInputValue.js');\n\nvar _typeFromAST = require('../utilities/typeFromAST.js');\n\nvar _valueFromAST = require('../utilities/valueFromAST.js');\n\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nfunction getVariableValues(schema, varDefNodes, inputs, options) {\n  const errors = [];\n  const maxErrors =\n    options === null || options === void 0 ? void 0 : options.maxErrors;\n\n  try {\n    const coerced = coerceVariableValues(\n      schema,\n      varDefNodes,\n      inputs,\n      (error) => {\n        if (maxErrors != null && errors.length >= maxErrors) {\n          throw new _GraphQLError.GraphQLError(\n            'Too many errors processing variables, error limit reached. Execution aborted.',\n          );\n        }\n\n        errors.push(error);\n      },\n    );\n\n    if (errors.length === 0) {\n      return {\n        coerced,\n      };\n    }\n  } catch (error) {\n    errors.push(error);\n  }\n\n  return {\n    errors,\n  };\n}\n\nfunction coerceVariableValues(schema, varDefNodes, inputs, onError) {\n  const coercedValues = {};\n\n  for (const varDefNode of varDefNodes) {\n    const varName = varDefNode.variable.name.value;\n    const varType = (0, _typeFromAST.typeFromAST)(schema, varDefNode.type);\n\n    if (!(0, _definition.isInputType)(varType)) {\n      // Must use input types for variables. This should be caught during\n      // validation, however is checked again here for safety.\n      const varTypeStr = (0, _printer.print)(varDefNode.type);\n      onError(\n        new _GraphQLError.GraphQLError(\n          `Variable \"$${varName}\" expected value of type \"${varTypeStr}\" which cannot be used as an input type.`,\n          {\n            nodes: varDefNode.type,\n          },\n        ),\n      );\n      continue;\n    }\n\n    if (!hasOwnProperty(inputs, varName)) {\n      if (varDefNode.defaultValue) {\n        coercedValues[varName] = (0, _valueFromAST.valueFromAST)(\n          varDefNode.defaultValue,\n          varType,\n        );\n      } else if ((0, _definition.isNonNullType)(varType)) {\n        const varTypeStr = (0, _inspect.inspect)(varType);\n        onError(\n          new _GraphQLError.GraphQLError(\n            `Variable \"$${varName}\" of required type \"${varTypeStr}\" was not provided.`,\n            {\n              nodes: varDefNode,\n            },\n          ),\n        );\n      }\n\n      continue;\n    }\n\n    const value = inputs[varName];\n\n    if (value === null && (0, _definition.isNonNullType)(varType)) {\n      const varTypeStr = (0, _inspect.inspect)(varType);\n      onError(\n        new _GraphQLError.GraphQLError(\n          `Variable \"$${varName}\" of non-null type \"${varTypeStr}\" must not be null.`,\n          {\n            nodes: varDefNode,\n          },\n        ),\n      );\n      continue;\n    }\n\n    coercedValues[varName] = (0, _coerceInputValue.coerceInputValue)(\n      value,\n      varType,\n      (path, invalidValue, error) => {\n        let prefix =\n          `Variable \"$${varName}\" got invalid value ` +\n          (0, _inspect.inspect)(invalidValue);\n\n        if (path.length > 0) {\n          prefix += ` at \"${varName}${(0, _printPathArray.printPathArray)(\n            path,\n          )}\"`;\n        }\n\n        onError(\n          new _GraphQLError.GraphQLError(prefix + '; ' + error.message, {\n            nodes: varDefNode,\n            originalError: error.originalError,\n          }),\n        );\n      },\n    );\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nfunction getArgumentValues(def, node, variableValues) {\n  var _node$arguments;\n\n  const coercedValues = {}; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n\n  const argumentNodes =\n    (_node$arguments = node.arguments) !== null && _node$arguments !== void 0\n      ? _node$arguments\n      : [];\n  const argNodeMap = (0, _keyMap.keyMap)(\n    argumentNodes,\n    (arg) => arg.name.value,\n  );\n\n  for (const argDef of def.args) {\n    const name = argDef.name;\n    const argType = argDef.type;\n    const argumentNode = argNodeMap[name];\n\n    if (!argumentNode) {\n      if (argDef.defaultValue !== undefined) {\n        coercedValues[name] = argDef.defaultValue;\n      } else if ((0, _definition.isNonNullType)(argType)) {\n        throw new _GraphQLError.GraphQLError(\n          `Argument \"${name}\" of required type \"${(0, _inspect.inspect)(\n            argType,\n          )}\" ` + 'was not provided.',\n          {\n            nodes: node,\n          },\n        );\n      }\n\n      continue;\n    }\n\n    const valueNode = argumentNode.value;\n    let isNull = valueNode.kind === _kinds.Kind.NULL;\n\n    if (valueNode.kind === _kinds.Kind.VARIABLE) {\n      const variableName = valueNode.name.value;\n\n      if (\n        variableValues == null ||\n        !hasOwnProperty(variableValues, variableName)\n      ) {\n        if (argDef.defaultValue !== undefined) {\n          coercedValues[name] = argDef.defaultValue;\n        } else if ((0, _definition.isNonNullType)(argType)) {\n          throw new _GraphQLError.GraphQLError(\n            `Argument \"${name}\" of required type \"${(0, _inspect.inspect)(\n              argType,\n            )}\" ` +\n              `was provided the variable \"$${variableName}\" which was not provided a runtime value.`,\n            {\n              nodes: valueNode,\n            },\n          );\n        }\n\n        continue;\n      }\n\n      isNull = variableValues[variableName] == null;\n    }\n\n    if (isNull && (0, _definition.isNonNullType)(argType)) {\n      throw new _GraphQLError.GraphQLError(\n        `Argument \"${name}\" of non-null type \"${(0, _inspect.inspect)(\n          argType,\n        )}\" ` + 'must not be null.',\n        {\n          nodes: valueNode,\n        },\n      );\n    }\n\n    const coercedValue = (0, _valueFromAST.valueFromAST)(\n      valueNode,\n      argType,\n      variableValues,\n    );\n\n    if (coercedValue === undefined) {\n      // Note: ValuesOfCorrectTypeRule validation should catch this before\n      // execution. This is a runtime check to ensure execution does not\n      // continue with an invalid argument value.\n      throw new _GraphQLError.GraphQLError(\n        `Argument \"${name}\" has invalid value ${(0, _printer.print)(\n          valueNode,\n        )}.`,\n        {\n          nodes: valueNode,\n        },\n      );\n    }\n\n    coercedValues[name] = coercedValue;\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a directive definition\n * and a AST node which may contain directives. Optionally also accepts a map\n * of variable values.\n *\n * If the directive does not exist on the node, returns undefined.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nfunction getDirectiveValues(directiveDef, node, variableValues) {\n  var _node$directives;\n\n  const directiveNode =\n    (_node$directives = node.directives) === null || _node$directives === void 0\n      ? void 0\n      : _node$directives.find(\n          (directive) => directive.name.value === directiveDef.name,\n        );\n\n  if (directiveNode) {\n    return getArgumentValues(directiveDef, directiveNode, variableValues);\n  }\n}\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}