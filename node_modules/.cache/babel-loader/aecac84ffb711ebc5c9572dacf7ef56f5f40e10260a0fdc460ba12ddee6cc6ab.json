{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.DangerousChangeType = exports.BreakingChangeType = void 0;\nexports.findBreakingChanges = findBreakingChanges;\nexports.findDangerousChanges = findDangerousChanges;\nvar _inspect = require('../jsutils/inspect.js');\nvar _invariant = require('../jsutils/invariant.js');\nvar _keyMap = require('../jsutils/keyMap.js');\nvar _printer = require('../language/printer.js');\nvar _definition = require('../type/definition.js');\nvar _scalars = require('../type/scalars.js');\nvar _astFromValue = require('./astFromValue.js');\nvar _sortValueNode = require('./sortValueNode.js');\nvar BreakingChangeType;\nexports.BreakingChangeType = BreakingChangeType;\n(function (BreakingChangeType) {\n  BreakingChangeType['TYPE_REMOVED'] = 'TYPE_REMOVED';\n  BreakingChangeType['TYPE_CHANGED_KIND'] = 'TYPE_CHANGED_KIND';\n  BreakingChangeType['TYPE_REMOVED_FROM_UNION'] = 'TYPE_REMOVED_FROM_UNION';\n  BreakingChangeType['VALUE_REMOVED_FROM_ENUM'] = 'VALUE_REMOVED_FROM_ENUM';\n  BreakingChangeType['REQUIRED_INPUT_FIELD_ADDED'] = 'REQUIRED_INPUT_FIELD_ADDED';\n  BreakingChangeType['IMPLEMENTED_INTERFACE_REMOVED'] = 'IMPLEMENTED_INTERFACE_REMOVED';\n  BreakingChangeType['FIELD_REMOVED'] = 'FIELD_REMOVED';\n  BreakingChangeType['FIELD_CHANGED_KIND'] = 'FIELD_CHANGED_KIND';\n  BreakingChangeType['REQUIRED_ARG_ADDED'] = 'REQUIRED_ARG_ADDED';\n  BreakingChangeType['ARG_REMOVED'] = 'ARG_REMOVED';\n  BreakingChangeType['ARG_CHANGED_KIND'] = 'ARG_CHANGED_KIND';\n  BreakingChangeType['DIRECTIVE_REMOVED'] = 'DIRECTIVE_REMOVED';\n  BreakingChangeType['DIRECTIVE_ARG_REMOVED'] = 'DIRECTIVE_ARG_REMOVED';\n  BreakingChangeType['REQUIRED_DIRECTIVE_ARG_ADDED'] = 'REQUIRED_DIRECTIVE_ARG_ADDED';\n  BreakingChangeType['DIRECTIVE_REPEATABLE_REMOVED'] = 'DIRECTIVE_REPEATABLE_REMOVED';\n  BreakingChangeType['DIRECTIVE_LOCATION_REMOVED'] = 'DIRECTIVE_LOCATION_REMOVED';\n})(BreakingChangeType || (exports.BreakingChangeType = BreakingChangeType = {}));\nvar DangerousChangeType;\nexports.DangerousChangeType = DangerousChangeType;\n(function (DangerousChangeType) {\n  DangerousChangeType['VALUE_ADDED_TO_ENUM'] = 'VALUE_ADDED_TO_ENUM';\n  DangerousChangeType['TYPE_ADDED_TO_UNION'] = 'TYPE_ADDED_TO_UNION';\n  DangerousChangeType['OPTIONAL_INPUT_FIELD_ADDED'] = 'OPTIONAL_INPUT_FIELD_ADDED';\n  DangerousChangeType['OPTIONAL_ARG_ADDED'] = 'OPTIONAL_ARG_ADDED';\n  DangerousChangeType['IMPLEMENTED_INTERFACE_ADDED'] = 'IMPLEMENTED_INTERFACE_ADDED';\n  DangerousChangeType['ARG_DEFAULT_VALUE_CHANGE'] = 'ARG_DEFAULT_VALUE_CHANGE';\n})(DangerousChangeType || (exports.DangerousChangeType = DangerousChangeType = {}));\n\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\nfunction findBreakingChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(change => change.type in BreakingChangeType);\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\nfunction findDangerousChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(change => change.type in DangerousChangeType);\n}\nfunction findSchemaChanges(oldSchema, newSchema) {\n  return [...findTypeChanges(oldSchema, newSchema), ...findDirectiveChanges(oldSchema, newSchema)];\n}\nfunction findDirectiveChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const directivesDiff = diff(oldSchema.getDirectives(), newSchema.getDirectives());\n  for (const oldDirective of directivesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.DIRECTIVE_REMOVED,\n      description: `${oldDirective.name} was removed.`\n    });\n  }\n  for (const [oldDirective, newDirective] of directivesDiff.persisted) {\n    const argsDiff = diff(oldDirective.args, newDirective.args);\n    for (const newArg of argsDiff.added) {\n      if ((0, _definition.isRequiredArgument)(newArg)) {\n        schemaChanges.push({\n          type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n          description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`\n        });\n      }\n    }\n    for (const oldArg of argsDiff.removed) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n        description: `${oldArg.name} was removed from ${oldDirective.name}.`\n      });\n    }\n    if (oldDirective.isRepeatable && !newDirective.isRepeatable) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,\n        description: `Repeatable flag was removed from ${oldDirective.name}.`\n      });\n    }\n    for (const location of oldDirective.locations) {\n      if (!newDirective.locations.includes(location)) {\n        schemaChanges.push({\n          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n          description: `${location} was removed from ${oldDirective.name}.`\n        });\n      }\n    }\n  }\n  return schemaChanges;\n}\nfunction findTypeChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const typesDiff = diff(Object.values(oldSchema.getTypeMap()), Object.values(newSchema.getTypeMap()));\n  for (const oldType of typesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED,\n      description: (0, _scalars.isSpecifiedScalarType)(oldType) ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.` : `${oldType.name} was removed.`\n    });\n  }\n  for (const [oldType, newType] of typesDiff.persisted) {\n    if ((0, _definition.isEnumType)(oldType) && (0, _definition.isEnumType)(newType)) {\n      schemaChanges.push(...findEnumTypeChanges(oldType, newType));\n    } else if ((0, _definition.isUnionType)(oldType) && (0, _definition.isUnionType)(newType)) {\n      schemaChanges.push(...findUnionTypeChanges(oldType, newType));\n    } else if ((0, _definition.isInputObjectType)(oldType) && (0, _definition.isInputObjectType)(newType)) {\n      schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));\n    } else if ((0, _definition.isObjectType)(oldType) && (0, _definition.isObjectType)(newType)) {\n      schemaChanges.push(...findFieldChanges(oldType, newType), ...findImplementedInterfacesChanges(oldType, newType));\n    } else if ((0, _definition.isInterfaceType)(oldType) && (0, _definition.isInterfaceType)(newType)) {\n      schemaChanges.push(...findFieldChanges(oldType, newType), ...findImplementedInterfacesChanges(oldType, newType));\n    } else if (oldType.constructor !== newType.constructor) {\n      schemaChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description: `${oldType.name} changed from ` + `${typeKindName(oldType)} to ${typeKindName(newType)}.`\n      });\n    }\n  }\n  return schemaChanges;\n}\nfunction findInputObjectTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));\n  for (const newField of fieldsDiff.added) {\n    if ((0, _definition.isRequiredInputField)(newField)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n        description: `A required field ${newField.name} on input type ${oldType.name} was added.`\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n        description: `An optional field ${newField.name} on input type ${oldType.name} was added.`\n      });\n    }\n  }\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`\n    });\n  }\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldField.type, newField.type);\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description: `${oldType.name}.${oldField.name} changed type from ` + `${String(oldField.type)} to ${String(newField.type)}.`\n      });\n    }\n  }\n  return schemaChanges;\n}\nfunction findUnionTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());\n  for (const newPossibleType of possibleTypesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n      description: `${newPossibleType.name} was added to union type ${oldType.name}.`\n    });\n  }\n  for (const oldPossibleType of possibleTypesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n      description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`\n    });\n  }\n  return schemaChanges;\n}\nfunction findEnumTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const valuesDiff = diff(oldType.getValues(), newType.getValues());\n  for (const newValue of valuesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n      description: `${newValue.name} was added to enum type ${oldType.name}.`\n    });\n  }\n  for (const oldValue of valuesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n      description: `${oldValue.name} was removed from enum type ${oldType.name}.`\n    });\n  }\n  return schemaChanges;\n}\nfunction findImplementedInterfacesChanges(oldType, newType) {\n  const schemaChanges = [];\n  const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());\n  for (const newInterface of interfacesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,\n      description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`\n    });\n  }\n  for (const oldInterface of interfacesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,\n      description: `${oldType.name} no longer implements interface ${oldInterface.name}.`\n    });\n  }\n  return schemaChanges;\n}\nfunction findFieldChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`\n    });\n  }\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    schemaChanges.push(...findArgChanges(oldType, oldField, newField));\n    const isSafe = isChangeSafeForObjectOrInterfaceField(oldField.type, newField.type);\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description: `${oldType.name}.${oldField.name} changed type from ` + `${String(oldField.type)} to ${String(newField.type)}.`\n      });\n    }\n  }\n  return schemaChanges;\n}\nfunction findArgChanges(oldType, oldField, newField) {\n  const schemaChanges = [];\n  const argsDiff = diff(oldField.args, newField.args);\n  for (const oldArg of argsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.ARG_REMOVED,\n      description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`\n    });\n  }\n  for (const [oldArg, newArg] of argsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArg.type, newArg.type);\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.ARG_CHANGED_KIND,\n        description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ` + `${String(oldArg.type)} to ${String(newArg.type)}.`\n      });\n    } else if (oldArg.defaultValue !== undefined) {\n      if (newArg.defaultValue === undefined) {\n        schemaChanges.push({\n          type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`\n        });\n      } else {\n        // Since we looking only for client's observable changes we should\n        // compare default values in the same representation as they are\n        // represented inside introspection.\n        const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);\n        const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);\n        if (oldValueStr !== newValueStr) {\n          schemaChanges.push({\n            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`\n          });\n        }\n      }\n    }\n  }\n  for (const newArg of argsDiff.added) {\n    if ((0, _definition.isRequiredArgument)(newArg)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_ARG_ADDED,\n        description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n        description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`\n      });\n    }\n  }\n  return schemaChanges;\n}\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if ((0, _definition.isListType)(oldType)) {\n    return (\n      // if they're both lists, make sure the underlying types are compatible\n      (0, _definition.isListType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) ||\n      // moving from nullable to non-null of the same underlying type is safe\n      (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  }\n  if ((0, _definition.isNonNullType)(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);\n  }\n  return (\n    // if they're both named types, see if their names are equivalent\n    (0, _definition.isNamedType)(newType) && oldType.name === newType.name ||\n    // moving from nullable to non-null of the same underlying type is safe\n    (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n  );\n}\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if ((0, _definition.isListType)(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return (0, _definition.isListType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);\n  }\n  if ((0, _definition.isNonNullType)(oldType)) {\n    return (\n      // if they're both non-null, make sure the underlying types are\n      // compatible\n      (0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) ||\n      // moving from non-null to nullable of the same underlying type is safe\n      !(0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)\n    );\n  } // if they're both named types, see if their names are equivalent\n\n  return (0, _definition.isNamedType)(newType) && oldType.name === newType.name;\n}\nfunction typeKindName(type) {\n  if ((0, _definition.isScalarType)(type)) {\n    return 'a Scalar type';\n  }\n  if ((0, _definition.isObjectType)(type)) {\n    return 'an Object type';\n  }\n  if ((0, _definition.isInterfaceType)(type)) {\n    return 'an Interface type';\n  }\n  if ((0, _definition.isUnionType)(type)) {\n    return 'a Union type';\n  }\n  if ((0, _definition.isEnumType)(type)) {\n    return 'an Enum type';\n  }\n  if ((0, _definition.isInputObjectType)(type)) {\n    return 'an Input type';\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n  false || (0, _invariant.invariant)(false, 'Unexpected type: ' + (0, _inspect.inspect)(type));\n}\nfunction stringifyValue(value, type) {\n  const ast = (0, _astFromValue.astFromValue)(value, type);\n  ast != null || (0, _invariant.invariant)(false);\n  return (0, _printer.print)((0, _sortValueNode.sortValueNode)(ast));\n}\nfunction diff(oldArray, newArray) {\n  const added = [];\n  const removed = [];\n  const persisted = [];\n  const oldMap = (0, _keyMap.keyMap)(oldArray, _ref => {\n    let {\n      name\n    } = _ref;\n    return name;\n  });\n  const newMap = (0, _keyMap.keyMap)(newArray, _ref2 => {\n    let {\n      name\n    } = _ref2;\n    return name;\n  });\n  for (const oldItem of oldArray) {\n    const newItem = newMap[oldItem.name];\n    if (newItem === undefined) {\n      removed.push(oldItem);\n    } else {\n      persisted.push([oldItem, newItem]);\n    }\n  }\n  for (const newItem of newArray) {\n    if (oldMap[newItem.name] === undefined) {\n      added.push(newItem);\n    }\n  }\n  return {\n    added,\n    persisted,\n    removed\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","DangerousChangeType","BreakingChangeType","findBreakingChanges","findDangerousChanges","_inspect","require","_invariant","_keyMap","_printer","_definition","_scalars","_astFromValue","_sortValueNode","oldSchema","newSchema","findSchemaChanges","filter","change","type","findTypeChanges","findDirectiveChanges","schemaChanges","directivesDiff","diff","getDirectives","oldDirective","removed","push","DIRECTIVE_REMOVED","description","name","newDirective","persisted","argsDiff","args","newArg","added","isRequiredArgument","REQUIRED_DIRECTIVE_ARG_ADDED","oldArg","DIRECTIVE_ARG_REMOVED","isRepeatable","DIRECTIVE_REPEATABLE_REMOVED","location","locations","includes","DIRECTIVE_LOCATION_REMOVED","typesDiff","values","getTypeMap","oldType","TYPE_REMOVED","isSpecifiedScalarType","newType","isEnumType","findEnumTypeChanges","isUnionType","findUnionTypeChanges","isInputObjectType","findInputObjectTypeChanges","isObjectType","findFieldChanges","findImplementedInterfacesChanges","isInterfaceType","constructor","TYPE_CHANGED_KIND","typeKindName","fieldsDiff","getFields","newField","isRequiredInputField","REQUIRED_INPUT_FIELD_ADDED","OPTIONAL_INPUT_FIELD_ADDED","oldField","FIELD_REMOVED","isSafe","isChangeSafeForInputObjectFieldOrFieldArg","FIELD_CHANGED_KIND","String","possibleTypesDiff","getTypes","newPossibleType","TYPE_ADDED_TO_UNION","oldPossibleType","TYPE_REMOVED_FROM_UNION","valuesDiff","getValues","newValue","VALUE_ADDED_TO_ENUM","oldValue","VALUE_REMOVED_FROM_ENUM","interfacesDiff","getInterfaces","newInterface","IMPLEMENTED_INTERFACE_ADDED","oldInterface","IMPLEMENTED_INTERFACE_REMOVED","findArgChanges","isChangeSafeForObjectOrInterfaceField","ARG_REMOVED","ARG_CHANGED_KIND","defaultValue","undefined","ARG_DEFAULT_VALUE_CHANGE","oldValueStr","stringifyValue","newValueStr","REQUIRED_ARG_ADDED","OPTIONAL_ARG_ADDED","isListType","ofType","isNonNullType","isNamedType","isScalarType","invariant","inspect","ast","astFromValue","print","sortValueNode","oldArray","newArray","oldMap","keyMap","newMap","oldItem","newItem"],"sources":["/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/graphql/utilities/findBreakingChanges.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.DangerousChangeType = exports.BreakingChangeType = void 0;\nexports.findBreakingChanges = findBreakingChanges;\nexports.findDangerousChanges = findDangerousChanges;\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _invariant = require('../jsutils/invariant.js');\n\nvar _keyMap = require('../jsutils/keyMap.js');\n\nvar _printer = require('../language/printer.js');\n\nvar _definition = require('../type/definition.js');\n\nvar _scalars = require('../type/scalars.js');\n\nvar _astFromValue = require('./astFromValue.js');\n\nvar _sortValueNode = require('./sortValueNode.js');\n\nvar BreakingChangeType;\nexports.BreakingChangeType = BreakingChangeType;\n\n(function (BreakingChangeType) {\n  BreakingChangeType['TYPE_REMOVED'] = 'TYPE_REMOVED';\n  BreakingChangeType['TYPE_CHANGED_KIND'] = 'TYPE_CHANGED_KIND';\n  BreakingChangeType['TYPE_REMOVED_FROM_UNION'] = 'TYPE_REMOVED_FROM_UNION';\n  BreakingChangeType['VALUE_REMOVED_FROM_ENUM'] = 'VALUE_REMOVED_FROM_ENUM';\n  BreakingChangeType['REQUIRED_INPUT_FIELD_ADDED'] =\n    'REQUIRED_INPUT_FIELD_ADDED';\n  BreakingChangeType['IMPLEMENTED_INTERFACE_REMOVED'] =\n    'IMPLEMENTED_INTERFACE_REMOVED';\n  BreakingChangeType['FIELD_REMOVED'] = 'FIELD_REMOVED';\n  BreakingChangeType['FIELD_CHANGED_KIND'] = 'FIELD_CHANGED_KIND';\n  BreakingChangeType['REQUIRED_ARG_ADDED'] = 'REQUIRED_ARG_ADDED';\n  BreakingChangeType['ARG_REMOVED'] = 'ARG_REMOVED';\n  BreakingChangeType['ARG_CHANGED_KIND'] = 'ARG_CHANGED_KIND';\n  BreakingChangeType['DIRECTIVE_REMOVED'] = 'DIRECTIVE_REMOVED';\n  BreakingChangeType['DIRECTIVE_ARG_REMOVED'] = 'DIRECTIVE_ARG_REMOVED';\n  BreakingChangeType['REQUIRED_DIRECTIVE_ARG_ADDED'] =\n    'REQUIRED_DIRECTIVE_ARG_ADDED';\n  BreakingChangeType['DIRECTIVE_REPEATABLE_REMOVED'] =\n    'DIRECTIVE_REPEATABLE_REMOVED';\n  BreakingChangeType['DIRECTIVE_LOCATION_REMOVED'] =\n    'DIRECTIVE_LOCATION_REMOVED';\n})(\n  BreakingChangeType || (exports.BreakingChangeType = BreakingChangeType = {}),\n);\n\nvar DangerousChangeType;\nexports.DangerousChangeType = DangerousChangeType;\n\n(function (DangerousChangeType) {\n  DangerousChangeType['VALUE_ADDED_TO_ENUM'] = 'VALUE_ADDED_TO_ENUM';\n  DangerousChangeType['TYPE_ADDED_TO_UNION'] = 'TYPE_ADDED_TO_UNION';\n  DangerousChangeType['OPTIONAL_INPUT_FIELD_ADDED'] =\n    'OPTIONAL_INPUT_FIELD_ADDED';\n  DangerousChangeType['OPTIONAL_ARG_ADDED'] = 'OPTIONAL_ARG_ADDED';\n  DangerousChangeType['IMPLEMENTED_INTERFACE_ADDED'] =\n    'IMPLEMENTED_INTERFACE_ADDED';\n  DangerousChangeType['ARG_DEFAULT_VALUE_CHANGE'] = 'ARG_DEFAULT_VALUE_CHANGE';\n})(\n  DangerousChangeType ||\n    (exports.DangerousChangeType = DangerousChangeType = {}),\n);\n\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\nfunction findBreakingChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(\n    (change) => change.type in BreakingChangeType,\n  );\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\nfunction findDangerousChanges(oldSchema, newSchema) {\n  // @ts-expect-error\n  return findSchemaChanges(oldSchema, newSchema).filter(\n    (change) => change.type in DangerousChangeType,\n  );\n}\n\nfunction findSchemaChanges(oldSchema, newSchema) {\n  return [\n    ...findTypeChanges(oldSchema, newSchema),\n    ...findDirectiveChanges(oldSchema, newSchema),\n  ];\n}\n\nfunction findDirectiveChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const directivesDiff = diff(\n    oldSchema.getDirectives(),\n    newSchema.getDirectives(),\n  );\n\n  for (const oldDirective of directivesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.DIRECTIVE_REMOVED,\n      description: `${oldDirective.name} was removed.`,\n    });\n  }\n\n  for (const [oldDirective, newDirective] of directivesDiff.persisted) {\n    const argsDiff = diff(oldDirective.args, newDirective.args);\n\n    for (const newArg of argsDiff.added) {\n      if ((0, _definition.isRequiredArgument)(newArg)) {\n        schemaChanges.push({\n          type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n          description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`,\n        });\n      }\n    }\n\n    for (const oldArg of argsDiff.removed) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n        description: `${oldArg.name} was removed from ${oldDirective.name}.`,\n      });\n    }\n\n    if (oldDirective.isRepeatable && !newDirective.isRepeatable) {\n      schemaChanges.push({\n        type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,\n        description: `Repeatable flag was removed from ${oldDirective.name}.`,\n      });\n    }\n\n    for (const location of oldDirective.locations) {\n      if (!newDirective.locations.includes(location)) {\n        schemaChanges.push({\n          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n          description: `${location} was removed from ${oldDirective.name}.`,\n        });\n      }\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findTypeChanges(oldSchema, newSchema) {\n  const schemaChanges = [];\n  const typesDiff = diff(\n    Object.values(oldSchema.getTypeMap()),\n    Object.values(newSchema.getTypeMap()),\n  );\n\n  for (const oldType of typesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED,\n      description: (0, _scalars.isSpecifiedScalarType)(oldType)\n        ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.`\n        : `${oldType.name} was removed.`,\n    });\n  }\n\n  for (const [oldType, newType] of typesDiff.persisted) {\n    if (\n      (0, _definition.isEnumType)(oldType) &&\n      (0, _definition.isEnumType)(newType)\n    ) {\n      schemaChanges.push(...findEnumTypeChanges(oldType, newType));\n    } else if (\n      (0, _definition.isUnionType)(oldType) &&\n      (0, _definition.isUnionType)(newType)\n    ) {\n      schemaChanges.push(...findUnionTypeChanges(oldType, newType));\n    } else if (\n      (0, _definition.isInputObjectType)(oldType) &&\n      (0, _definition.isInputObjectType)(newType)\n    ) {\n      schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));\n    } else if (\n      (0, _definition.isObjectType)(oldType) &&\n      (0, _definition.isObjectType)(newType)\n    ) {\n      schemaChanges.push(\n        ...findFieldChanges(oldType, newType),\n        ...findImplementedInterfacesChanges(oldType, newType),\n      );\n    } else if (\n      (0, _definition.isInterfaceType)(oldType) &&\n      (0, _definition.isInterfaceType)(newType)\n    ) {\n      schemaChanges.push(\n        ...findFieldChanges(oldType, newType),\n        ...findImplementedInterfacesChanges(oldType, newType),\n      );\n    } else if (oldType.constructor !== newType.constructor) {\n      schemaChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description:\n          `${oldType.name} changed from ` +\n          `${typeKindName(oldType)} to ${typeKindName(newType)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findInputObjectTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(\n    Object.values(oldType.getFields()),\n    Object.values(newType.getFields()),\n  );\n\n  for (const newField of fieldsDiff.added) {\n    if ((0, _definition.isRequiredInputField)(newField)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n        description: `A required field ${newField.name} on input type ${oldType.name} was added.`,\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n        description: `An optional field ${newField.name} on input type ${oldType.name} was added.`,\n      });\n    }\n  }\n\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`,\n    });\n  }\n\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(\n      oldField.type,\n      newField.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} changed type from ` +\n          `${String(oldField.type)} to ${String(newField.type)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findUnionTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());\n\n  for (const newPossibleType of possibleTypesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n      description: `${newPossibleType.name} was added to union type ${oldType.name}.`,\n    });\n  }\n\n  for (const oldPossibleType of possibleTypesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n      description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findEnumTypeChanges(oldType, newType) {\n  const schemaChanges = [];\n  const valuesDiff = diff(oldType.getValues(), newType.getValues());\n\n  for (const newValue of valuesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n      description: `${newValue.name} was added to enum type ${oldType.name}.`,\n    });\n  }\n\n  for (const oldValue of valuesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n      description: `${oldValue.name} was removed from enum type ${oldType.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findImplementedInterfacesChanges(oldType, newType) {\n  const schemaChanges = [];\n  const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());\n\n  for (const newInterface of interfacesDiff.added) {\n    schemaChanges.push({\n      type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,\n      description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`,\n    });\n  }\n\n  for (const oldInterface of interfacesDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,\n      description: `${oldType.name} no longer implements interface ${oldInterface.name}.`,\n    });\n  }\n\n  return schemaChanges;\n}\n\nfunction findFieldChanges(oldType, newType) {\n  const schemaChanges = [];\n  const fieldsDiff = diff(\n    Object.values(oldType.getFields()),\n    Object.values(newType.getFields()),\n  );\n\n  for (const oldField of fieldsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.FIELD_REMOVED,\n      description: `${oldType.name}.${oldField.name} was removed.`,\n    });\n  }\n\n  for (const [oldField, newField] of fieldsDiff.persisted) {\n    schemaChanges.push(...findArgChanges(oldType, oldField, newField));\n    const isSafe = isChangeSafeForObjectOrInterfaceField(\n      oldField.type,\n      newField.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.FIELD_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} changed type from ` +\n          `${String(oldField.type)} to ${String(newField.type)}.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction findArgChanges(oldType, oldField, newField) {\n  const schemaChanges = [];\n  const argsDiff = diff(oldField.args, newField.args);\n\n  for (const oldArg of argsDiff.removed) {\n    schemaChanges.push({\n      type: BreakingChangeType.ARG_REMOVED,\n      description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`,\n    });\n  }\n\n  for (const [oldArg, newArg] of argsDiff.persisted) {\n    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(\n      oldArg.type,\n      newArg.type,\n    );\n\n    if (!isSafe) {\n      schemaChanges.push({\n        type: BreakingChangeType.ARG_CHANGED_KIND,\n        description:\n          `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ` +\n          `${String(oldArg.type)} to ${String(newArg.type)}.`,\n      });\n    } else if (oldArg.defaultValue !== undefined) {\n      if (newArg.defaultValue === undefined) {\n        schemaChanges.push({\n          type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`,\n        });\n      } else {\n        // Since we looking only for client's observable changes we should\n        // compare default values in the same representation as they are\n        // represented inside introspection.\n        const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);\n        const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);\n\n        if (oldValueStr !== newValueStr) {\n          schemaChanges.push({\n            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`,\n          });\n        }\n      }\n    }\n  }\n\n  for (const newArg of argsDiff.added) {\n    if ((0, _definition.isRequiredArgument)(newArg)) {\n      schemaChanges.push({\n        type: BreakingChangeType.REQUIRED_ARG_ADDED,\n        description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`,\n      });\n    } else {\n      schemaChanges.push({\n        type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n        description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`,\n      });\n    }\n  }\n\n  return schemaChanges;\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if ((0, _definition.isListType)(oldType)) {\n    return (\n      // if they're both lists, make sure the underlying types are compatible\n      ((0, _definition.isListType)(newType) &&\n        isChangeSafeForObjectOrInterfaceField(\n          oldType.ofType,\n          newType.ofType,\n        )) || // moving from nullable to non-null of the same underlying type is safe\n      ((0, _definition.isNonNullType)(newType) &&\n        isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType))\n    );\n  }\n\n  if ((0, _definition.isNonNullType)(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return (\n      (0, _definition.isNonNullType)(newType) &&\n      isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType)\n    );\n  }\n\n  return (\n    // if they're both named types, see if their names are equivalent\n    ((0, _definition.isNamedType)(newType) && oldType.name === newType.name) || // moving from nullable to non-null of the same underlying type is safe\n    ((0, _definition.isNonNullType)(newType) &&\n      isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType))\n  );\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if ((0, _definition.isListType)(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return (\n      (0, _definition.isListType)(newType) &&\n      isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType)\n    );\n  }\n\n  if ((0, _definition.isNonNullType)(oldType)) {\n    return (\n      // if they're both non-null, make sure the underlying types are\n      // compatible\n      ((0, _definition.isNonNullType)(newType) &&\n        isChangeSafeForInputObjectFieldOrFieldArg(\n          oldType.ofType,\n          newType.ofType,\n        )) || // moving from non-null to nullable of the same underlying type is safe\n      (!(0, _definition.isNonNullType)(newType) &&\n        isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType))\n    );\n  } // if they're both named types, see if their names are equivalent\n\n  return (0, _definition.isNamedType)(newType) && oldType.name === newType.name;\n}\n\nfunction typeKindName(type) {\n  if ((0, _definition.isScalarType)(type)) {\n    return 'a Scalar type';\n  }\n\n  if ((0, _definition.isObjectType)(type)) {\n    return 'an Object type';\n  }\n\n  if ((0, _definition.isInterfaceType)(type)) {\n    return 'an Interface type';\n  }\n\n  if ((0, _definition.isUnionType)(type)) {\n    return 'a Union type';\n  }\n\n  if ((0, _definition.isEnumType)(type)) {\n    return 'an Enum type';\n  }\n\n  if ((0, _definition.isInputObjectType)(type)) {\n    return 'an Input type';\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n  false ||\n    (0, _invariant.invariant)(\n      false,\n      'Unexpected type: ' + (0, _inspect.inspect)(type),\n    );\n}\n\nfunction stringifyValue(value, type) {\n  const ast = (0, _astFromValue.astFromValue)(value, type);\n  ast != null || (0, _invariant.invariant)(false);\n  return (0, _printer.print)((0, _sortValueNode.sortValueNode)(ast));\n}\n\nfunction diff(oldArray, newArray) {\n  const added = [];\n  const removed = [];\n  const persisted = [];\n  const oldMap = (0, _keyMap.keyMap)(oldArray, ({ name }) => name);\n  const newMap = (0, _keyMap.keyMap)(newArray, ({ name }) => name);\n\n  for (const oldItem of oldArray) {\n    const newItem = newMap[oldItem.name];\n\n    if (newItem === undefined) {\n      removed.push(oldItem);\n    } else {\n      persisted.push([oldItem, newItem]);\n    }\n  }\n\n  for (const newItem of newArray) {\n    if (oldMap[newItem.name] === undefined) {\n      added.push(newItem);\n    }\n  }\n\n  return {\n    added,\n    persisted,\n    removed,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}