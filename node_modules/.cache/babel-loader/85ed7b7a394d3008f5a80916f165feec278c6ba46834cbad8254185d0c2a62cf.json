{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.coerceInputValue = coerceInputValue;\nvar _didYouMean = require('../jsutils/didYouMean.js');\nvar _inspect = require('../jsutils/inspect.js');\nvar _invariant = require('../jsutils/invariant.js');\nvar _isIterableObject = require('../jsutils/isIterableObject.js');\nvar _isObjectLike = require('../jsutils/isObjectLike.js');\nvar _Path = require('../jsutils/Path.js');\nvar _printPathArray = require('../jsutils/printPathArray.js');\nvar _suggestionList = require('../jsutils/suggestionList.js');\nvar _GraphQLError = require('../error/GraphQLError.js');\nvar _definition = require('../type/definition.js');\n\n/**\n * Coerces a JavaScript value given a GraphQL Input Type.\n */\nfunction coerceInputValue(inputValue, type) {\n  let onError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOnError;\n  return coerceInputValueImpl(inputValue, type, onError, undefined);\n}\nfunction defaultOnError(path, invalidValue, error) {\n  let errorPrefix = 'Invalid value ' + (0, _inspect.inspect)(invalidValue);\n  if (path.length > 0) {\n    errorPrefix += ` at \"value${(0, _printPathArray.printPathArray)(path)}\"`;\n  }\n  error.message = errorPrefix + ': ' + error.message;\n  throw error;\n}\nfunction coerceInputValueImpl(inputValue, type, onError, path) {\n  if ((0, _definition.isNonNullType)(type)) {\n    if (inputValue != null) {\n      return coerceInputValueImpl(inputValue, type.ofType, onError, path);\n    }\n    onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected non-nullable type \"${(0, _inspect.inspect)(type)}\" not to be null.`));\n    return;\n  }\n  if (inputValue == null) {\n    // Explicitly return the value null.\n    return null;\n  }\n  if ((0, _definition.isListType)(type)) {\n    const itemType = type.ofType;\n    if ((0, _isIterableObject.isIterableObject)(inputValue)) {\n      return Array.from(inputValue, (itemValue, index) => {\n        const itemPath = (0, _Path.addPath)(path, index, undefined);\n        return coerceInputValueImpl(itemValue, itemType, onError, itemPath);\n      });\n    } // Lists accept a non-list value as a list of one.\n\n    return [coerceInputValueImpl(inputValue, itemType, onError, path)];\n  }\n  if ((0, _definition.isInputObjectType)(type)) {\n    if (!(0, _isObjectLike.isObjectLike)(inputValue)) {\n      onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected type \"${type.name}\" to be an object.`));\n      return;\n    }\n    const coercedValue = {};\n    const fieldDefs = type.getFields();\n    for (const field of Object.values(fieldDefs)) {\n      const fieldValue = inputValue[field.name];\n      if (fieldValue === undefined) {\n        if (field.defaultValue !== undefined) {\n          coercedValue[field.name] = field.defaultValue;\n        } else if ((0, _definition.isNonNullType)(field.type)) {\n          const typeStr = (0, _inspect.inspect)(field.type);\n          onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Field \"${field.name}\" of required type \"${typeStr}\" was not provided.`));\n        }\n        continue;\n      }\n      coercedValue[field.name] = coerceInputValueImpl(fieldValue, field.type, onError, (0, _Path.addPath)(path, field.name, type.name));\n    } // Ensure every provided field is defined.\n\n    for (const fieldName of Object.keys(inputValue)) {\n      if (!fieldDefs[fieldName]) {\n        const suggestions = (0, _suggestionList.suggestionList)(fieldName, Object.keys(type.getFields()));\n        onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Field \"${fieldName}\" is not defined by type \"${type.name}\".` + (0, _didYouMean.didYouMean)(suggestions)));\n      }\n    }\n    return coercedValue;\n  }\n  if ((0, _definition.isLeafType)(type)) {\n    let parseResult; // Scalars and Enums determine if a input value is valid via parseValue(),\n    // which can throw to indicate failure. If it throws, maintain a reference\n    // to the original error.\n\n    try {\n      parseResult = type.parseValue(inputValue);\n    } catch (error) {\n      if (error instanceof _GraphQLError.GraphQLError) {\n        onError((0, _Path.pathToArray)(path), inputValue, error);\n      } else {\n        onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected type \"${type.name}\". ` + error.message, {\n          originalError: error\n        }));\n      }\n      return;\n    }\n    if (parseResult === undefined) {\n      onError((0, _Path.pathToArray)(path), inputValue, new _GraphQLError.GraphQLError(`Expected type \"${type.name}\".`));\n    }\n    return parseResult;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n  false || (0, _invariant.invariant)(false, 'Unexpected input type: ' + (0, _inspect.inspect)(type));\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","coerceInputValue","_didYouMean","require","_inspect","_invariant","_isIterableObject","_isObjectLike","_Path","_printPathArray","_suggestionList","_GraphQLError","_definition","inputValue","type","onError","defaultOnError","coerceInputValueImpl","undefined","path","invalidValue","error","errorPrefix","inspect","length","printPathArray","message","isNonNullType","ofType","pathToArray","GraphQLError","isListType","itemType","isIterableObject","Array","from","itemValue","index","itemPath","addPath","isInputObjectType","isObjectLike","name","coercedValue","fieldDefs","getFields","field","values","fieldValue","defaultValue","typeStr","fieldName","keys","suggestions","suggestionList","didYouMean","isLeafType","parseResult","parseValue","originalError","invariant"],"sources":["/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/graphql/utilities/coerceInputValue.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.coerceInputValue = coerceInputValue;\n\nvar _didYouMean = require('../jsutils/didYouMean.js');\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _invariant = require('../jsutils/invariant.js');\n\nvar _isIterableObject = require('../jsutils/isIterableObject.js');\n\nvar _isObjectLike = require('../jsutils/isObjectLike.js');\n\nvar _Path = require('../jsutils/Path.js');\n\nvar _printPathArray = require('../jsutils/printPathArray.js');\n\nvar _suggestionList = require('../jsutils/suggestionList.js');\n\nvar _GraphQLError = require('../error/GraphQLError.js');\n\nvar _definition = require('../type/definition.js');\n\n/**\n * Coerces a JavaScript value given a GraphQL Input Type.\n */\nfunction coerceInputValue(inputValue, type, onError = defaultOnError) {\n  return coerceInputValueImpl(inputValue, type, onError, undefined);\n}\n\nfunction defaultOnError(path, invalidValue, error) {\n  let errorPrefix = 'Invalid value ' + (0, _inspect.inspect)(invalidValue);\n\n  if (path.length > 0) {\n    errorPrefix += ` at \"value${(0, _printPathArray.printPathArray)(path)}\"`;\n  }\n\n  error.message = errorPrefix + ': ' + error.message;\n  throw error;\n}\n\nfunction coerceInputValueImpl(inputValue, type, onError, path) {\n  if ((0, _definition.isNonNullType)(type)) {\n    if (inputValue != null) {\n      return coerceInputValueImpl(inputValue, type.ofType, onError, path);\n    }\n\n    onError(\n      (0, _Path.pathToArray)(path),\n      inputValue,\n      new _GraphQLError.GraphQLError(\n        `Expected non-nullable type \"${(0, _inspect.inspect)(\n          type,\n        )}\" not to be null.`,\n      ),\n    );\n    return;\n  }\n\n  if (inputValue == null) {\n    // Explicitly return the value null.\n    return null;\n  }\n\n  if ((0, _definition.isListType)(type)) {\n    const itemType = type.ofType;\n\n    if ((0, _isIterableObject.isIterableObject)(inputValue)) {\n      return Array.from(inputValue, (itemValue, index) => {\n        const itemPath = (0, _Path.addPath)(path, index, undefined);\n        return coerceInputValueImpl(itemValue, itemType, onError, itemPath);\n      });\n    } // Lists accept a non-list value as a list of one.\n\n    return [coerceInputValueImpl(inputValue, itemType, onError, path)];\n  }\n\n  if ((0, _definition.isInputObjectType)(type)) {\n    if (!(0, _isObjectLike.isObjectLike)(inputValue)) {\n      onError(\n        (0, _Path.pathToArray)(path),\n        inputValue,\n        new _GraphQLError.GraphQLError(\n          `Expected type \"${type.name}\" to be an object.`,\n        ),\n      );\n      return;\n    }\n\n    const coercedValue = {};\n    const fieldDefs = type.getFields();\n\n    for (const field of Object.values(fieldDefs)) {\n      const fieldValue = inputValue[field.name];\n\n      if (fieldValue === undefined) {\n        if (field.defaultValue !== undefined) {\n          coercedValue[field.name] = field.defaultValue;\n        } else if ((0, _definition.isNonNullType)(field.type)) {\n          const typeStr = (0, _inspect.inspect)(field.type);\n          onError(\n            (0, _Path.pathToArray)(path),\n            inputValue,\n            new _GraphQLError.GraphQLError(\n              `Field \"${field.name}\" of required type \"${typeStr}\" was not provided.`,\n            ),\n          );\n        }\n\n        continue;\n      }\n\n      coercedValue[field.name] = coerceInputValueImpl(\n        fieldValue,\n        field.type,\n        onError,\n        (0, _Path.addPath)(path, field.name, type.name),\n      );\n    } // Ensure every provided field is defined.\n\n    for (const fieldName of Object.keys(inputValue)) {\n      if (!fieldDefs[fieldName]) {\n        const suggestions = (0, _suggestionList.suggestionList)(\n          fieldName,\n          Object.keys(type.getFields()),\n        );\n        onError(\n          (0, _Path.pathToArray)(path),\n          inputValue,\n          new _GraphQLError.GraphQLError(\n            `Field \"${fieldName}\" is not defined by type \"${type.name}\".` +\n              (0, _didYouMean.didYouMean)(suggestions),\n          ),\n        );\n      }\n    }\n\n    return coercedValue;\n  }\n\n  if ((0, _definition.isLeafType)(type)) {\n    let parseResult; // Scalars and Enums determine if a input value is valid via parseValue(),\n    // which can throw to indicate failure. If it throws, maintain a reference\n    // to the original error.\n\n    try {\n      parseResult = type.parseValue(inputValue);\n    } catch (error) {\n      if (error instanceof _GraphQLError.GraphQLError) {\n        onError((0, _Path.pathToArray)(path), inputValue, error);\n      } else {\n        onError(\n          (0, _Path.pathToArray)(path),\n          inputValue,\n          new _GraphQLError.GraphQLError(\n            `Expected type \"${type.name}\". ` + error.message,\n            {\n              originalError: error,\n            },\n          ),\n        );\n      }\n\n      return;\n    }\n\n    if (parseResult === undefined) {\n      onError(\n        (0, _Path.pathToArray)(path),\n        inputValue,\n        new _GraphQLError.GraphQLError(`Expected type \"${type.name}\".`),\n      );\n    }\n\n    return parseResult;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible types have been considered.\n\n  false ||\n    (0, _invariant.invariant)(\n      false,\n      'Unexpected input type: ' + (0, _inspect.inspect)(type),\n    );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}