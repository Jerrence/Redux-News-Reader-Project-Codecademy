{"ast":null,"code":"/**\n * Mock Service Worker.\n * @see https://github.com/mswjs/msw\n * - Please do NOT modify this file.\n * - Please do NOT serve this file on production.\n */\n/* eslint-disable */\n/* tslint:disable */\n\nconst INTEGRITY_CHECKSUM = '65d33ca82955e1c5928aed19d1bdf3f9';\nconst bypassHeaderName = 'x-msw-bypass';\nlet clients = {};\nself.addEventListener('install', function () {\n  return self.skipWaiting();\n});\nself.addEventListener('activate', async function (event) {\n  return self.clients.claim();\n});\nself.addEventListener('message', async function (event) {\n  const clientId = event.source.id;\n  const client = await event.currentTarget.clients.get(clientId);\n  const allClients = await self.clients.matchAll();\n  const allClientIds = allClients.map(client => client.id);\n  switch (event.data) {\n    case 'KEEPALIVE_REQUEST':\n      {\n        sendToClient(client, {\n          type: 'KEEPALIVE_RESPONSE'\n        });\n        break;\n      }\n    case 'INTEGRITY_CHECK_REQUEST':\n      {\n        sendToClient(client, {\n          type: 'INTEGRITY_CHECK_RESPONSE',\n          payload: INTEGRITY_CHECKSUM\n        });\n        break;\n      }\n    case 'MOCK_ACTIVATE':\n      {\n        clients = ensureKeys(allClientIds, clients);\n        clients[clientId] = true;\n        sendToClient(client, {\n          type: 'MOCKING_ENABLED',\n          payload: true\n        });\n        break;\n      }\n    case 'MOCK_DEACTIVATE':\n      {\n        clients = ensureKeys(allClientIds, clients);\n        clients[clientId] = false;\n        break;\n      }\n    case 'CLIENT_CLOSED':\n      {\n        const remainingClients = allClients.filter(client => {\n          return client.id !== clientId;\n        });\n\n        // Unregister itself when there are no more clients\n        if (remainingClients.length === 0) {\n          self.registration.unregister();\n        }\n        break;\n      }\n  }\n});\nself.addEventListener('fetch', function (event) {\n  const {\n    clientId,\n    request\n  } = event;\n  const requestClone = request.clone();\n  const getOriginalResponse = () => fetch(requestClone);\n\n  // Bypass navigation requests.\n  if (request.mode === 'navigate') {\n    return;\n  }\n\n  // Bypass mocking if the current client isn't present in the internal clients map\n  // (i.e. has the mocking disabled).\n  if (!clients[clientId]) {\n    return;\n  }\n\n  // Opening the DevTools triggers the \"only-if-cached\" request\n  // that cannot be handled by the worker. Bypass such requests.\n  if (request.cache === 'only-if-cached' && request.mode !== 'same-origin') {\n    return;\n  }\n  event.respondWith(new Promise(async (resolve, reject) => {\n    const client = await event.target.clients.get(clientId);\n\n    // Bypass mocking when the request client is not active.\n    if (!client) {\n      return resolve(getOriginalResponse());\n    }\n\n    // Bypass requests with the explicit bypass header\n    if (requestClone.headers.get(bypassHeaderName) === 'true') {\n      const modifiedHeaders = serializeHeaders(requestClone.headers);\n\n      // Remove the bypass header to comply with the CORS preflight check\n      delete modifiedHeaders[bypassHeaderName];\n      const originalRequest = new Request(requestClone, {\n        headers: new Headers(modifiedHeaders)\n      });\n      return resolve(fetch(originalRequest));\n    }\n    const reqHeaders = serializeHeaders(request.headers);\n    const body = await request.text();\n    const rawClientMessage = await sendToClient(client, {\n      type: 'REQUEST',\n      payload: {\n        url: request.url,\n        method: request.method,\n        headers: reqHeaders,\n        cache: request.cache,\n        mode: request.mode,\n        credentials: request.credentials,\n        destination: request.destination,\n        integrity: request.integrity,\n        redirect: request.redirect,\n        referrer: request.referrer,\n        referrerPolicy: request.referrerPolicy,\n        body,\n        bodyUsed: request.bodyUsed,\n        keepalive: request.keepalive\n      }\n    });\n    const clientMessage = rawClientMessage;\n    switch (clientMessage.type) {\n      case 'MOCK_SUCCESS':\n        {\n          setTimeout(resolve.bind(this, createResponse(clientMessage)), clientMessage.payload.delay);\n          break;\n        }\n      case 'MOCK_NOT_FOUND':\n        {\n          return resolve(getOriginalResponse());\n        }\n      case 'NETWORK_ERROR':\n        {\n          const {\n            name,\n            message\n          } = clientMessage.payload;\n          const networkError = new Error(message);\n          networkError.name = name;\n\n          // Rejecting a request Promise emulates a network error.\n          return reject(networkError);\n        }\n      case 'INTERNAL_ERROR':\n        {\n          const parsedBody = JSON.parse(clientMessage.payload.body);\n          console.error(`\\\n[MSW] Request handler function for \"%s %s\" has thrown the following exception:\n\n${parsedBody.errorType}: ${parsedBody.message}\n(see more detailed error stack trace in the mocked response body)\n\nThis exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error.\nIf you wish to mock an error response, please refer to this guide: https://mswjs.io/docs/recipes/mocking-error-responses\\\n  `, request.method, request.url);\n          return resolve(createResponse(clientMessage));\n        }\n    }\n  }).catch(error => {\n    console.error('[MSW] Failed to mock a \"%s\" request to \"%s\": %s', request.method, request.url, error);\n  }));\n});\nfunction serializeHeaders(headers) {\n  const reqHeaders = {};\n  headers.forEach((value, name) => {\n    reqHeaders[name] = reqHeaders[name] ? [].concat(reqHeaders[name]).concat(value) : value;\n  });\n  return reqHeaders;\n}\nfunction sendToClient(client, message) {\n  return new Promise((resolve, reject) => {\n    const channel = new MessageChannel();\n    channel.port1.onmessage = event => {\n      if (event.data && event.data.error) {\n        reject(event.data.error);\n      } else {\n        resolve(event.data);\n      }\n    };\n    client.postMessage(JSON.stringify(message), [channel.port2]);\n  });\n}\nfunction createResponse(clientMessage) {\n  return new Response(clientMessage.payload.body, {\n    ...clientMessage.payload,\n    headers: clientMessage.payload.headers\n  });\n}\nfunction ensureKeys(keys, obj) {\n  return Object.keys(obj).reduce((acc, key) => {\n    if (keys.includes(key)) {\n      acc[key] = obj[key];\n    }\n    return acc;\n  }, {});\n}","map":{"version":3,"names":["INTEGRITY_CHECKSUM","bypassHeaderName","clients","self","addEventListener","skipWaiting","event","claim","clientId","source","id","client","currentTarget","get","allClients","matchAll","allClientIds","map","data","sendToClient","type","payload","ensureKeys","remainingClients","filter","length","registration","unregister","request","requestClone","clone","getOriginalResponse","fetch","mode","cache","respondWith","Promise","resolve","reject","target","headers","modifiedHeaders","serializeHeaders","originalRequest","Request","Headers","reqHeaders","body","text","rawClientMessage","url","method","credentials","destination","integrity","redirect","referrer","referrerPolicy","bodyUsed","keepalive","clientMessage","setTimeout","bind","createResponse","delay","name","message","networkError","Error","parsedBody","JSON","parse","console","error","errorType","catch","forEach","value","concat","channel","MessageChannel","port1","onmessage","postMessage","stringify","port2","Response","keys","obj","Object","reduce","acc","key","includes"],"sources":["/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/src/mockServiceWorker.js"],"sourcesContent":["/**\n * Mock Service Worker.\n * @see https://github.com/mswjs/msw\n * - Please do NOT modify this file.\n * - Please do NOT serve this file on production.\n */\n/* eslint-disable */\n/* tslint:disable */\n\nconst INTEGRITY_CHECKSUM = '65d33ca82955e1c5928aed19d1bdf3f9'\nconst bypassHeaderName = 'x-msw-bypass'\n\nlet clients = {}\n\nself.addEventListener('install', function () {\n  return self.skipWaiting()\n})\n\nself.addEventListener('activate', async function (event) {\n  return self.clients.claim()\n})\n\nself.addEventListener('message', async function (event) {\n  const clientId = event.source.id\n  const client = await event.currentTarget.clients.get(clientId)\n  const allClients = await self.clients.matchAll()\n  const allClientIds = allClients.map((client) => client.id)\n\n  switch (event.data) {\n    case 'KEEPALIVE_REQUEST': {\n      sendToClient(client, {\n        type: 'KEEPALIVE_RESPONSE',\n      })\n      break\n    }\n\n    case 'INTEGRITY_CHECK_REQUEST': {\n      sendToClient(client, {\n        type: 'INTEGRITY_CHECK_RESPONSE',\n        payload: INTEGRITY_CHECKSUM,\n      })\n      break\n    }\n\n    case 'MOCK_ACTIVATE': {\n      clients = ensureKeys(allClientIds, clients)\n      clients[clientId] = true\n\n      sendToClient(client, {\n        type: 'MOCKING_ENABLED',\n        payload: true,\n      })\n      break\n    }\n\n    case 'MOCK_DEACTIVATE': {\n      clients = ensureKeys(allClientIds, clients)\n      clients[clientId] = false\n      break\n    }\n\n    case 'CLIENT_CLOSED': {\n      const remainingClients = allClients.filter((client) => {\n        return client.id !== clientId\n      })\n\n      // Unregister itself when there are no more clients\n      if (remainingClients.length === 0) {\n        self.registration.unregister()\n      }\n\n      break\n    }\n  }\n})\n\nself.addEventListener('fetch', function (event) {\n  const { clientId, request } = event\n  const requestClone = request.clone()\n  const getOriginalResponse = () => fetch(requestClone)\n\n  // Bypass navigation requests.\n  if (request.mode === 'navigate') {\n    return\n  }\n\n  // Bypass mocking if the current client isn't present in the internal clients map\n  // (i.e. has the mocking disabled).\n  if (!clients[clientId]) {\n    return\n  }\n\n  // Opening the DevTools triggers the \"only-if-cached\" request\n  // that cannot be handled by the worker. Bypass such requests.\n  if (request.cache === 'only-if-cached' && request.mode !== 'same-origin') {\n    return\n  }\n\n  event.respondWith(\n    new Promise(async (resolve, reject) => {\n      const client = await event.target.clients.get(clientId)\n\n      // Bypass mocking when the request client is not active.\n      if (!client) {\n        return resolve(getOriginalResponse())\n      }\n\n      // Bypass requests with the explicit bypass header\n      if (requestClone.headers.get(bypassHeaderName) === 'true') {\n        const modifiedHeaders = serializeHeaders(requestClone.headers)\n\n        // Remove the bypass header to comply with the CORS preflight check\n        delete modifiedHeaders[bypassHeaderName]\n\n        const originalRequest = new Request(requestClone, {\n          headers: new Headers(modifiedHeaders),\n        })\n\n        return resolve(fetch(originalRequest))\n      }\n\n      const reqHeaders = serializeHeaders(request.headers)\n      const body = await request.text()\n\n      const rawClientMessage = await sendToClient(client, {\n        type: 'REQUEST',\n        payload: {\n          url: request.url,\n          method: request.method,\n          headers: reqHeaders,\n          cache: request.cache,\n          mode: request.mode,\n          credentials: request.credentials,\n          destination: request.destination,\n          integrity: request.integrity,\n          redirect: request.redirect,\n          referrer: request.referrer,\n          referrerPolicy: request.referrerPolicy,\n          body,\n          bodyUsed: request.bodyUsed,\n          keepalive: request.keepalive,\n        },\n      })\n\n      const clientMessage = rawClientMessage\n\n      switch (clientMessage.type) {\n        case 'MOCK_SUCCESS': {\n          setTimeout(\n            resolve.bind(this, createResponse(clientMessage)),\n            clientMessage.payload.delay,\n          )\n          break\n        }\n\n        case 'MOCK_NOT_FOUND': {\n          return resolve(getOriginalResponse())\n        }\n\n        case 'NETWORK_ERROR': {\n          const { name, message } = clientMessage.payload\n          const networkError = new Error(message)\n          networkError.name = name\n\n          // Rejecting a request Promise emulates a network error.\n          return reject(networkError)\n        }\n\n        case 'INTERNAL_ERROR': {\n          const parsedBody = JSON.parse(clientMessage.payload.body)\n\n          console.error(\n            `\\\n[MSW] Request handler function for \"%s %s\" has thrown the following exception:\n\n${parsedBody.errorType}: ${parsedBody.message}\n(see more detailed error stack trace in the mocked response body)\n\nThis exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error.\nIf you wish to mock an error response, please refer to this guide: https://mswjs.io/docs/recipes/mocking-error-responses\\\n  `,\n            request.method,\n            request.url,\n          )\n\n          return resolve(createResponse(clientMessage))\n        }\n      }\n    }).catch((error) => {\n      console.error(\n        '[MSW] Failed to mock a \"%s\" request to \"%s\": %s',\n        request.method,\n        request.url,\n        error,\n      )\n    }),\n  )\n})\n\nfunction serializeHeaders(headers) {\n  const reqHeaders = {}\n  headers.forEach((value, name) => {\n    reqHeaders[name] = reqHeaders[name]\n      ? [].concat(reqHeaders[name]).concat(value)\n      : value\n  })\n  return reqHeaders\n}\n\nfunction sendToClient(client, message) {\n  return new Promise((resolve, reject) => {\n    const channel = new MessageChannel()\n\n    channel.port1.onmessage = (event) => {\n      if (event.data && event.data.error) {\n        reject(event.data.error)\n      } else {\n        resolve(event.data)\n      }\n    }\n\n    client.postMessage(JSON.stringify(message), [channel.port2])\n  })\n}\n\nfunction createResponse(clientMessage) {\n  return new Response(clientMessage.payload.body, {\n    ...clientMessage.payload,\n    headers: clientMessage.payload.headers,\n  })\n}\n\nfunction ensureKeys(keys, obj) {\n  return Object.keys(obj).reduce((acc, key) => {\n    if (keys.includes(key)) {\n      acc[key] = obj[key]\n    }\n\n    return acc\n  }, {})\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}