{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.extendSchema = extendSchema;\nexports.extendSchemaImpl = extendSchemaImpl;\nvar _devAssert = require('../jsutils/devAssert.js');\nvar _inspect = require('../jsutils/inspect.js');\nvar _invariant = require('../jsutils/invariant.js');\nvar _keyMap = require('../jsutils/keyMap.js');\nvar _mapValue = require('../jsutils/mapValue.js');\nvar _kinds = require('../language/kinds.js');\nvar _predicates = require('../language/predicates.js');\nvar _definition = require('../type/definition.js');\nvar _directives = require('../type/directives.js');\nvar _introspection = require('../type/introspection.js');\nvar _scalars = require('../type/scalars.js');\nvar _schema = require('../type/schema.js');\nvar _validate = require('../validation/validate.js');\nvar _values = require('../execution/values.js');\nvar _valueFromAST = require('./valueFromAST.js');\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n */\nfunction extendSchema(schema, documentAST, options) {\n  (0, _schema.assertSchema)(schema);\n  documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, 'Must provide valid Document AST.');\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    (0, _validate.assertValidSDLExtension)(documentAST, schema);\n  }\n  const schemaConfig = schema.toConfig();\n  const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);\n  return schemaConfig === extendedConfig ? schema : new _schema.GraphQLSchema(extendedConfig);\n}\n/**\n * @internal\n */\n\nfunction extendSchemaImpl(schemaConfig, documentAST, options) {\n  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;\n\n  // Collect the type definitions and extensions found in the document.\n  const typeDefs = [];\n  const typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  const directiveDefs = [];\n  let schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  const schemaExtensions = [];\n  for (const def of documentAST.definitions) {\n    if (def.kind === _kinds.Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === _kinds.Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(def);\n    } else if ((0, _predicates.isTypeDefinitionNode)(def)) {\n      typeDefs.push(def);\n    } else if ((0, _predicates.isTypeExtensionNode)(def)) {\n      const extendedTypeName = def.name.value;\n      const existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];\n    } else if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n  if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {\n    return schemaConfig;\n  }\n  const typeMap = Object.create(null);\n  for (const existingType of schemaConfig.types) {\n    typeMap[existingType.name] = extendNamedType(existingType);\n  }\n  for (const typeNode of typeDefs) {\n    var _stdTypeMap$name;\n    const name = typeNode.name.value;\n    typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);\n  }\n  const operationTypes = {\n    // Get the extended root operation types.\n    query: schemaConfig.query && replaceNamedType(schemaConfig.query),\n    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),\n    subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),\n    // Then, incorporate schema definition and all schema extensions.\n    ...(schemaDef && getOperationTypes([schemaDef])),\n    ...getOperationTypes(schemaExtensions)\n  }; // Then produce and return a Schema config with these types.\n\n  return {\n    description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value,\n    ...operationTypes,\n    types: Object.values(typeMap),\n    directives: [...schemaConfig.directives.map(replaceDirective), ...directiveDefs.map(buildDirective)],\n    extensions: Object.create(null),\n    astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,\n    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),\n    assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false\n  }; // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function replaceType(type) {\n    if ((0, _definition.isListType)(type)) {\n      // @ts-expect-error\n      return new _definition.GraphQLList(replaceType(type.ofType));\n    }\n    if ((0, _definition.isNonNullType)(type)) {\n      // @ts-expect-error\n      return new _definition.GraphQLNonNull(replaceType(type.ofType));\n    } // @ts-expect-error FIXME\n\n    return replaceNamedType(type);\n  }\n  function replaceNamedType(type) {\n    // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    return typeMap[type.name];\n  }\n  function replaceDirective(directive) {\n    const config = directive.toConfig();\n    return new _directives.GraphQLDirective({\n      ...config,\n      args: (0, _mapValue.mapValue)(config.args, extendArg)\n    });\n  }\n  function extendNamedType(type) {\n    if ((0, _introspection.isIntrospectionType)(type) || (0, _scalars.isSpecifiedScalarType)(type)) {\n      // Builtin types are not extended.\n      return type;\n    }\n    if ((0, _definition.isScalarType)(type)) {\n      return extendScalarType(type);\n    }\n    if ((0, _definition.isObjectType)(type)) {\n      return extendObjectType(type);\n    }\n    if ((0, _definition.isInterfaceType)(type)) {\n      return extendInterfaceType(type);\n    }\n    if ((0, _definition.isUnionType)(type)) {\n      return extendUnionType(type);\n    }\n    if ((0, _definition.isEnumType)(type)) {\n      return extendEnumType(type);\n    }\n    if ((0, _definition.isInputObjectType)(type)) {\n      return extendInputObjectType(type);\n    }\n    /* c8 ignore next 3 */\n    // Not reachable, all possible type definition nodes have been considered.\n\n    false || (0, _invariant.invariant)(false, 'Unexpected type: ' + (0, _inspect.inspect)(type));\n  }\n  function extendInputObjectType(type) {\n    var _typeExtensionsMap$co;\n    const config = type.toConfig();\n    const extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];\n    return new _definition.GraphQLInputObjectType({\n      ...config,\n      fields: () => ({\n        ...(0, _mapValue.mapValue)(config.fields, field => ({\n          ...field,\n          type: replaceType(field.type)\n        })),\n        ...buildInputFieldMap(extensions)\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    });\n  }\n  function extendEnumType(type) {\n    var _typeExtensionsMap$ty;\n    const config = type.toConfig();\n    const extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];\n    return new _definition.GraphQLEnumType({\n      ...config,\n      values: {\n        ...config.values,\n        ...buildEnumValueMap(extensions)\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    });\n  }\n  function extendScalarType(type) {\n    var _typeExtensionsMap$co2;\n    const config = type.toConfig();\n    const extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];\n    let specifiedByURL = config.specifiedByURL;\n    for (const extensionNode of extensions) {\n      var _getSpecifiedByURL;\n      specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== void 0 ? _getSpecifiedByURL : specifiedByURL;\n    }\n    return new _definition.GraphQLScalarType({\n      ...config,\n      specifiedByURL,\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    });\n  }\n  function extendObjectType(type) {\n    var _typeExtensionsMap$co3;\n    const config = type.toConfig();\n    const extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];\n    return new _definition.GraphQLObjectType({\n      ...config,\n      interfaces: () => [...type.getInterfaces().map(replaceNamedType), ...buildInterfaces(extensions)],\n      fields: () => ({\n        ...(0, _mapValue.mapValue)(config.fields, extendField),\n        ...buildFieldMap(extensions)\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    });\n  }\n  function extendInterfaceType(type) {\n    var _typeExtensionsMap$co4;\n    const config = type.toConfig();\n    const extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];\n    return new _definition.GraphQLInterfaceType({\n      ...config,\n      interfaces: () => [...type.getInterfaces().map(replaceNamedType), ...buildInterfaces(extensions)],\n      fields: () => ({\n        ...(0, _mapValue.mapValue)(config.fields, extendField),\n        ...buildFieldMap(extensions)\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    });\n  }\n  function extendUnionType(type) {\n    var _typeExtensionsMap$co5;\n    const config = type.toConfig();\n    const extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];\n    return new _definition.GraphQLUnionType({\n      ...config,\n      types: () => [...type.getTypes().map(replaceNamedType), ...buildUnionTypes(extensions)],\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    });\n  }\n  function extendField(field) {\n    return {\n      ...field,\n      type: replaceType(field.type),\n      args: field.args && (0, _mapValue.mapValue)(field.args, extendArg)\n    };\n  }\n  function extendArg(arg) {\n    return {\n      ...arg,\n      type: replaceType(arg.type)\n    };\n  }\n  function getOperationTypes(nodes) {\n    const opTypes = {};\n    for (const node of nodes) {\n      var _node$operationTypes;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const operationTypesNodes = /* c8 ignore next */\n      (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];\n      for (const operationType of operationTypesNodes) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        // @ts-expect-error\n        opTypes[operationType.operation] = getNamedType(operationType.type);\n      }\n    }\n    return opTypes;\n  }\n  function getNamedType(node) {\n    var _stdTypeMap$name2;\n    const name = node.name.value;\n    const type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];\n    if (type === undefined) {\n      throw new Error(`Unknown type: \"${name}\".`);\n    }\n    return type;\n  }\n  function getWrappedType(node) {\n    if (node.kind === _kinds.Kind.LIST_TYPE) {\n      return new _definition.GraphQLList(getWrappedType(node.type));\n    }\n    if (node.kind === _kinds.Kind.NON_NULL_TYPE) {\n      return new _definition.GraphQLNonNull(getWrappedType(node.type));\n    }\n    return getNamedType(node);\n  }\n  function buildDirective(node) {\n    var _node$description;\n    return new _directives.GraphQLDirective({\n      name: node.name.value,\n      description: (_node$description = node.description) === null || _node$description === void 0 ? void 0 : _node$description.value,\n      // @ts-expect-error\n      locations: node.locations.map(_ref => {\n        let {\n          value\n        } = _ref;\n        return value;\n      }),\n      isRepeatable: node.repeatable,\n      args: buildArgumentMap(node.arguments),\n      astNode: node\n    });\n  }\n  function buildFieldMap(nodes) {\n    const fieldConfigMap = Object.create(null);\n    for (const node of nodes) {\n      var _node$fields;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const nodeFields = /* c8 ignore next */\n      (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];\n      for (const field of nodeFields) {\n        var _field$description;\n        fieldConfigMap[field.name.value] = {\n          // Note: While this could make assertions to get the correctly typed\n          // value, that would throw immediately while type system validation\n          // with validateSchema() will produce more actionable results.\n          type: getWrappedType(field.type),\n          description: (_field$description = field.description) === null || _field$description === void 0 ? void 0 : _field$description.value,\n          args: buildArgumentMap(field.arguments),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field\n        };\n      }\n    }\n    return fieldConfigMap;\n  }\n  function buildArgumentMap(args) {\n    // FIXME: https://github.com/graphql/graphql-js/issues/2203\n    const argsNodes = /* c8 ignore next */\n    args !== null && args !== void 0 ? args : [];\n    const argConfigMap = Object.create(null);\n    for (const arg of argsNodes) {\n      var _arg$description;\n\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      const type = getWrappedType(arg.type);\n      argConfigMap[arg.name.value] = {\n        type,\n        description: (_arg$description = arg.description) === null || _arg$description === void 0 ? void 0 : _arg$description.value,\n        defaultValue: (0, _valueFromAST.valueFromAST)(arg.defaultValue, type),\n        deprecationReason: getDeprecationReason(arg),\n        astNode: arg\n      };\n    }\n    return argConfigMap;\n  }\n  function buildInputFieldMap(nodes) {\n    const inputFieldMap = Object.create(null);\n    for (const node of nodes) {\n      var _node$fields2;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const fieldsNodes = /* c8 ignore next */\n      (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : [];\n      for (const field of fieldsNodes) {\n        var _field$description2;\n\n        // Note: While this could make assertions to get the correctly typed\n        // value, that would throw immediately while type system validation\n        // with validateSchema() will produce more actionable results.\n        const type = getWrappedType(field.type);\n        inputFieldMap[field.name.value] = {\n          type,\n          description: (_field$description2 = field.description) === null || _field$description2 === void 0 ? void 0 : _field$description2.value,\n          defaultValue: (0, _valueFromAST.valueFromAST)(field.defaultValue, type),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field\n        };\n      }\n    }\n    return inputFieldMap;\n  }\n  function buildEnumValueMap(nodes) {\n    const enumValueMap = Object.create(null);\n    for (const node of nodes) {\n      var _node$values;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const valuesNodes = /* c8 ignore next */\n      (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];\n      for (const value of valuesNodes) {\n        var _value$description;\n        enumValueMap[value.name.value] = {\n          description: (_value$description = value.description) === null || _value$description === void 0 ? void 0 : _value$description.value,\n          deprecationReason: getDeprecationReason(value),\n          astNode: value\n        };\n      }\n    }\n    return enumValueMap;\n  }\n  function buildInterfaces(nodes) {\n    // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    // @ts-expect-error\n    return nodes.flatMap(\n    // FIXME: https://github.com/graphql/graphql-js/issues/2203\n    node => {\n      var _node$interfaces$map, _node$interfaces;\n      return (/* c8 ignore next */\n        (_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === void 0 ? void 0 : _node$interfaces.map(getNamedType)) !== null && _node$interfaces$map !== void 0 ? _node$interfaces$map : []\n      );\n    });\n  }\n  function buildUnionTypes(nodes) {\n    // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    // @ts-expect-error\n    return nodes.flatMap(\n    // FIXME: https://github.com/graphql/graphql-js/issues/2203\n    node => {\n      var _node$types$map, _node$types;\n      return (/* c8 ignore next */\n        (_node$types$map = (_node$types = node.types) === null || _node$types === void 0 ? void 0 : _node$types.map(getNamedType)) !== null && _node$types$map !== void 0 ? _node$types$map : []\n      );\n    });\n  }\n  function buildType(astNode) {\n    var _typeExtensionsMap$na;\n    const name = astNode.name.value;\n    const extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];\n    switch (astNode.kind) {\n      case _kinds.Kind.OBJECT_TYPE_DEFINITION:\n        {\n          var _astNode$description;\n          const allNodes = [astNode, ...extensionASTNodes];\n          return new _definition.GraphQLObjectType({\n            name,\n            description: (_astNode$description = astNode.description) === null || _astNode$description === void 0 ? void 0 : _astNode$description.value,\n            interfaces: () => buildInterfaces(allNodes),\n            fields: () => buildFieldMap(allNodes),\n            astNode,\n            extensionASTNodes\n          });\n        }\n      case _kinds.Kind.INTERFACE_TYPE_DEFINITION:\n        {\n          var _astNode$description2;\n          const allNodes = [astNode, ...extensionASTNodes];\n          return new _definition.GraphQLInterfaceType({\n            name,\n            description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === void 0 ? void 0 : _astNode$description2.value,\n            interfaces: () => buildInterfaces(allNodes),\n            fields: () => buildFieldMap(allNodes),\n            astNode,\n            extensionASTNodes\n          });\n        }\n      case _kinds.Kind.ENUM_TYPE_DEFINITION:\n        {\n          var _astNode$description3;\n          const allNodes = [astNode, ...extensionASTNodes];\n          return new _definition.GraphQLEnumType({\n            name,\n            description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === void 0 ? void 0 : _astNode$description3.value,\n            values: buildEnumValueMap(allNodes),\n            astNode,\n            extensionASTNodes\n          });\n        }\n      case _kinds.Kind.UNION_TYPE_DEFINITION:\n        {\n          var _astNode$description4;\n          const allNodes = [astNode, ...extensionASTNodes];\n          return new _definition.GraphQLUnionType({\n            name,\n            description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === void 0 ? void 0 : _astNode$description4.value,\n            types: () => buildUnionTypes(allNodes),\n            astNode,\n            extensionASTNodes\n          });\n        }\n      case _kinds.Kind.SCALAR_TYPE_DEFINITION:\n        {\n          var _astNode$description5;\n          return new _definition.GraphQLScalarType({\n            name,\n            description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === void 0 ? void 0 : _astNode$description5.value,\n            specifiedByURL: getSpecifiedByURL(astNode),\n            astNode,\n            extensionASTNodes\n          });\n        }\n      case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        {\n          var _astNode$description6;\n          const allNodes = [astNode, ...extensionASTNodes];\n          return new _definition.GraphQLInputObjectType({\n            name,\n            description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === void 0 ? void 0 : _astNode$description6.value,\n            fields: () => buildInputFieldMap(allNodes),\n            astNode,\n            extensionASTNodes\n          });\n        }\n    }\n  }\n}\nconst stdTypeMap = (0, _keyMap.keyMap)([..._scalars.specifiedScalarTypes, ..._introspection.introspectionTypes], type => type.name);\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\nfunction getDeprecationReason(node) {\n  const deprecated = (0, _values.getDirectiveValues)(_directives.GraphQLDeprecatedDirective, node); // @ts-expect-error validated by `getDirectiveValues`\n\n  return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;\n}\n/**\n * Given a scalar node, returns the string value for the specifiedByURL.\n */\n\nfunction getSpecifiedByURL(node) {\n  const specifiedBy = (0, _values.getDirectiveValues)(_directives.GraphQLSpecifiedByDirective, node); // @ts-expect-error validated by `getDirectiveValues`\n\n  return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","extendSchema","extendSchemaImpl","_devAssert","require","_inspect","_invariant","_keyMap","_mapValue","_kinds","_predicates","_definition","_directives","_introspection","_scalars","_schema","_validate","_values","_valueFromAST","schema","documentAST","options","assertSchema","kind","Kind","DOCUMENT","devAssert","assumeValid","assumeValidSDL","assertValidSDLExtension","schemaConfig","toConfig","extendedConfig","GraphQLSchema","_schemaDef","_schemaDef$descriptio","_schemaDef2","_options$assumeValid","typeDefs","typeExtensionsMap","create","directiveDefs","schemaDef","schemaExtensions","def","definitions","SCHEMA_DEFINITION","SCHEMA_EXTENSION","push","isTypeDefinitionNode","isTypeExtensionNode","extendedTypeName","name","existingTypeExtensions","concat","DIRECTIVE_DEFINITION","keys","length","typeMap","existingType","types","extendNamedType","typeNode","_stdTypeMap$name","stdTypeMap","buildType","operationTypes","query","replaceNamedType","mutation","subscription","getOperationTypes","description","values","directives","map","replaceDirective","buildDirective","extensions","astNode","extensionASTNodes","replaceType","type","isListType","GraphQLList","ofType","isNonNullType","GraphQLNonNull","directive","config","GraphQLDirective","args","mapValue","extendArg","isIntrospectionType","isSpecifiedScalarType","isScalarType","extendScalarType","isObjectType","extendObjectType","isInterfaceType","extendInterfaceType","isUnionType","extendUnionType","isEnumType","extendEnumType","isInputObjectType","extendInputObjectType","invariant","inspect","_typeExtensionsMap$co","GraphQLInputObjectType","fields","field","buildInputFieldMap","_typeExtensionsMap$ty","GraphQLEnumType","buildEnumValueMap","_typeExtensionsMap$co2","specifiedByURL","extensionNode","_getSpecifiedByURL","getSpecifiedByURL","GraphQLScalarType","_typeExtensionsMap$co3","GraphQLObjectType","interfaces","getInterfaces","buildInterfaces","extendField","buildFieldMap","_typeExtensionsMap$co4","GraphQLInterfaceType","_typeExtensionsMap$co5","GraphQLUnionType","getTypes","buildUnionTypes","arg","nodes","opTypes","node","_node$operationTypes","operationTypesNodes","operationType","operation","getNamedType","_stdTypeMap$name2","undefined","Error","getWrappedType","LIST_TYPE","NON_NULL_TYPE","_node$description","locations","isRepeatable","repeatable","buildArgumentMap","arguments","fieldConfigMap","_node$fields","nodeFields","_field$description","deprecationReason","getDeprecationReason","argsNodes","argConfigMap","_arg$description","defaultValue","valueFromAST","inputFieldMap","_node$fields2","fieldsNodes","_field$description2","enumValueMap","_node$values","valuesNodes","_value$description","flatMap","_node$interfaces$map","_node$interfaces","_node$types$map","_node$types","_typeExtensionsMap$na","OBJECT_TYPE_DEFINITION","_astNode$description","allNodes","INTERFACE_TYPE_DEFINITION","_astNode$description2","ENUM_TYPE_DEFINITION","_astNode$description3","UNION_TYPE_DEFINITION","_astNode$description4","SCALAR_TYPE_DEFINITION","_astNode$description5","INPUT_OBJECT_TYPE_DEFINITION","_astNode$description6","keyMap","specifiedScalarTypes","introspectionTypes","deprecated","getDirectiveValues","GraphQLDeprecatedDirective","reason","specifiedBy","GraphQLSpecifiedByDirective","url"],"sources":["/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/graphql/utilities/extendSchema.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.extendSchema = extendSchema;\nexports.extendSchemaImpl = extendSchemaImpl;\n\nvar _devAssert = require('../jsutils/devAssert.js');\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _invariant = require('../jsutils/invariant.js');\n\nvar _keyMap = require('../jsutils/keyMap.js');\n\nvar _mapValue = require('../jsutils/mapValue.js');\n\nvar _kinds = require('../language/kinds.js');\n\nvar _predicates = require('../language/predicates.js');\n\nvar _definition = require('../type/definition.js');\n\nvar _directives = require('../type/directives.js');\n\nvar _introspection = require('../type/introspection.js');\n\nvar _scalars = require('../type/scalars.js');\n\nvar _schema = require('../type/schema.js');\n\nvar _validate = require('../validation/validate.js');\n\nvar _values = require('../execution/values.js');\n\nvar _valueFromAST = require('./valueFromAST.js');\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n */\nfunction extendSchema(schema, documentAST, options) {\n  (0, _schema.assertSchema)(schema);\n  (documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT) ||\n    (0, _devAssert.devAssert)(false, 'Must provide valid Document AST.');\n\n  if (\n    (options === null || options === void 0 ? void 0 : options.assumeValid) !==\n      true &&\n    (options === null || options === void 0\n      ? void 0\n      : options.assumeValidSDL) !== true\n  ) {\n    (0, _validate.assertValidSDLExtension)(documentAST, schema);\n  }\n\n  const schemaConfig = schema.toConfig();\n  const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);\n  return schemaConfig === extendedConfig\n    ? schema\n    : new _schema.GraphQLSchema(extendedConfig);\n}\n/**\n * @internal\n */\n\nfunction extendSchemaImpl(schemaConfig, documentAST, options) {\n  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;\n\n  // Collect the type definitions and extensions found in the document.\n  const typeDefs = [];\n  const typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  const directiveDefs = [];\n  let schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  const schemaExtensions = [];\n\n  for (const def of documentAST.definitions) {\n    if (def.kind === _kinds.Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === _kinds.Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(def);\n    } else if ((0, _predicates.isTypeDefinitionNode)(def)) {\n      typeDefs.push(def);\n    } else if ((0, _predicates.isTypeExtensionNode)(def)) {\n      const extendedTypeName = def.name.value;\n      const existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n      typeExtensionsMap[extendedTypeName] = existingTypeExtensions\n        ? existingTypeExtensions.concat([def])\n        : [def];\n    } else if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n  if (\n    Object.keys(typeExtensionsMap).length === 0 &&\n    typeDefs.length === 0 &&\n    directiveDefs.length === 0 &&\n    schemaExtensions.length === 0 &&\n    schemaDef == null\n  ) {\n    return schemaConfig;\n  }\n\n  const typeMap = Object.create(null);\n\n  for (const existingType of schemaConfig.types) {\n    typeMap[existingType.name] = extendNamedType(existingType);\n  }\n\n  for (const typeNode of typeDefs) {\n    var _stdTypeMap$name;\n\n    const name = typeNode.name.value;\n    typeMap[name] =\n      (_stdTypeMap$name = stdTypeMap[name]) !== null &&\n      _stdTypeMap$name !== void 0\n        ? _stdTypeMap$name\n        : buildType(typeNode);\n  }\n\n  const operationTypes = {\n    // Get the extended root operation types.\n    query: schemaConfig.query && replaceNamedType(schemaConfig.query),\n    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),\n    subscription:\n      schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),\n    // Then, incorporate schema definition and all schema extensions.\n    ...(schemaDef && getOperationTypes([schemaDef])),\n    ...getOperationTypes(schemaExtensions),\n  }; // Then produce and return a Schema config with these types.\n\n  return {\n    description:\n      (_schemaDef = schemaDef) === null || _schemaDef === void 0\n        ? void 0\n        : (_schemaDef$descriptio = _schemaDef.description) === null ||\n          _schemaDef$descriptio === void 0\n        ? void 0\n        : _schemaDef$descriptio.value,\n    ...operationTypes,\n    types: Object.values(typeMap),\n    directives: [\n      ...schemaConfig.directives.map(replaceDirective),\n      ...directiveDefs.map(buildDirective),\n    ],\n    extensions: Object.create(null),\n    astNode:\n      (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0\n        ? _schemaDef2\n        : schemaConfig.astNode,\n    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),\n    assumeValid:\n      (_options$assumeValid =\n        options === null || options === void 0\n          ? void 0\n          : options.assumeValid) !== null && _options$assumeValid !== void 0\n        ? _options$assumeValid\n        : false,\n  }; // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function replaceType(type) {\n    if ((0, _definition.isListType)(type)) {\n      // @ts-expect-error\n      return new _definition.GraphQLList(replaceType(type.ofType));\n    }\n\n    if ((0, _definition.isNonNullType)(type)) {\n      // @ts-expect-error\n      return new _definition.GraphQLNonNull(replaceType(type.ofType));\n    } // @ts-expect-error FIXME\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    return typeMap[type.name];\n  }\n\n  function replaceDirective(directive) {\n    const config = directive.toConfig();\n    return new _directives.GraphQLDirective({\n      ...config,\n      args: (0, _mapValue.mapValue)(config.args, extendArg),\n    });\n  }\n\n  function extendNamedType(type) {\n    if (\n      (0, _introspection.isIntrospectionType)(type) ||\n      (0, _scalars.isSpecifiedScalarType)(type)\n    ) {\n      // Builtin types are not extended.\n      return type;\n    }\n\n    if ((0, _definition.isScalarType)(type)) {\n      return extendScalarType(type);\n    }\n\n    if ((0, _definition.isObjectType)(type)) {\n      return extendObjectType(type);\n    }\n\n    if ((0, _definition.isInterfaceType)(type)) {\n      return extendInterfaceType(type);\n    }\n\n    if ((0, _definition.isUnionType)(type)) {\n      return extendUnionType(type);\n    }\n\n    if ((0, _definition.isEnumType)(type)) {\n      return extendEnumType(type);\n    }\n\n    if ((0, _definition.isInputObjectType)(type)) {\n      return extendInputObjectType(type);\n    }\n    /* c8 ignore next 3 */\n    // Not reachable, all possible type definition nodes have been considered.\n\n    false ||\n      (0, _invariant.invariant)(\n        false,\n        'Unexpected type: ' + (0, _inspect.inspect)(type),\n      );\n  }\n\n  function extendInputObjectType(type) {\n    var _typeExtensionsMap$co;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co !== void 0\n        ? _typeExtensionsMap$co\n        : [];\n    return new _definition.GraphQLInputObjectType({\n      ...config,\n      fields: () => ({\n        ...(0, _mapValue.mapValue)(config.fields, (field) => ({\n          ...field,\n          type: replaceType(field.type),\n        })),\n        ...buildInputFieldMap(extensions),\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendEnumType(type) {\n    var _typeExtensionsMap$ty;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null &&\n      _typeExtensionsMap$ty !== void 0\n        ? _typeExtensionsMap$ty\n        : [];\n    return new _definition.GraphQLEnumType({\n      ...config,\n      values: { ...config.values, ...buildEnumValueMap(extensions) },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendScalarType(type) {\n    var _typeExtensionsMap$co2;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co2 !== void 0\n        ? _typeExtensionsMap$co2\n        : [];\n    let specifiedByURL = config.specifiedByURL;\n\n    for (const extensionNode of extensions) {\n      var _getSpecifiedByURL;\n\n      specifiedByURL =\n        (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null &&\n        _getSpecifiedByURL !== void 0\n          ? _getSpecifiedByURL\n          : specifiedByURL;\n    }\n\n    return new _definition.GraphQLScalarType({\n      ...config,\n      specifiedByURL,\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendObjectType(type) {\n    var _typeExtensionsMap$co3;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co3 !== void 0\n        ? _typeExtensionsMap$co3\n        : [];\n    return new _definition.GraphQLObjectType({\n      ...config,\n      interfaces: () => [\n        ...type.getInterfaces().map(replaceNamedType),\n        ...buildInterfaces(extensions),\n      ],\n      fields: () => ({\n        ...(0, _mapValue.mapValue)(config.fields, extendField),\n        ...buildFieldMap(extensions),\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendInterfaceType(type) {\n    var _typeExtensionsMap$co4;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co4 !== void 0\n        ? _typeExtensionsMap$co4\n        : [];\n    return new _definition.GraphQLInterfaceType({\n      ...config,\n      interfaces: () => [\n        ...type.getInterfaces().map(replaceNamedType),\n        ...buildInterfaces(extensions),\n      ],\n      fields: () => ({\n        ...(0, _mapValue.mapValue)(config.fields, extendField),\n        ...buildFieldMap(extensions),\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendUnionType(type) {\n    var _typeExtensionsMap$co5;\n\n    const config = type.toConfig();\n    const extensions =\n      (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null &&\n      _typeExtensionsMap$co5 !== void 0\n        ? _typeExtensionsMap$co5\n        : [];\n    return new _definition.GraphQLUnionType({\n      ...config,\n      types: () => [\n        ...type.getTypes().map(replaceNamedType),\n        ...buildUnionTypes(extensions),\n      ],\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendField(field) {\n    return {\n      ...field,\n      type: replaceType(field.type),\n      args: field.args && (0, _mapValue.mapValue)(field.args, extendArg),\n    };\n  }\n\n  function extendArg(arg) {\n    return { ...arg, type: replaceType(arg.type) };\n  }\n\n  function getOperationTypes(nodes) {\n    const opTypes = {};\n\n    for (const node of nodes) {\n      var _node$operationTypes;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const operationTypesNodes =\n        /* c8 ignore next */\n        (_node$operationTypes = node.operationTypes) !== null &&\n        _node$operationTypes !== void 0\n          ? _node$operationTypes\n          : [];\n\n      for (const operationType of operationTypesNodes) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        // @ts-expect-error\n        opTypes[operationType.operation] = getNamedType(operationType.type);\n      }\n    }\n\n    return opTypes;\n  }\n\n  function getNamedType(node) {\n    var _stdTypeMap$name2;\n\n    const name = node.name.value;\n    const type =\n      (_stdTypeMap$name2 = stdTypeMap[name]) !== null &&\n      _stdTypeMap$name2 !== void 0\n        ? _stdTypeMap$name2\n        : typeMap[name];\n\n    if (type === undefined) {\n      throw new Error(`Unknown type: \"${name}\".`);\n    }\n\n    return type;\n  }\n\n  function getWrappedType(node) {\n    if (node.kind === _kinds.Kind.LIST_TYPE) {\n      return new _definition.GraphQLList(getWrappedType(node.type));\n    }\n\n    if (node.kind === _kinds.Kind.NON_NULL_TYPE) {\n      return new _definition.GraphQLNonNull(getWrappedType(node.type));\n    }\n\n    return getNamedType(node);\n  }\n\n  function buildDirective(node) {\n    var _node$description;\n\n    return new _directives.GraphQLDirective({\n      name: node.name.value,\n      description:\n        (_node$description = node.description) === null ||\n        _node$description === void 0\n          ? void 0\n          : _node$description.value,\n      // @ts-expect-error\n      locations: node.locations.map(({ value }) => value),\n      isRepeatable: node.repeatable,\n      args: buildArgumentMap(node.arguments),\n      astNode: node,\n    });\n  }\n\n  function buildFieldMap(nodes) {\n    const fieldConfigMap = Object.create(null);\n\n    for (const node of nodes) {\n      var _node$fields;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const nodeFields =\n        /* c8 ignore next */\n        (_node$fields = node.fields) !== null && _node$fields !== void 0\n          ? _node$fields\n          : [];\n\n      for (const field of nodeFields) {\n        var _field$description;\n\n        fieldConfigMap[field.name.value] = {\n          // Note: While this could make assertions to get the correctly typed\n          // value, that would throw immediately while type system validation\n          // with validateSchema() will produce more actionable results.\n          type: getWrappedType(field.type),\n          description:\n            (_field$description = field.description) === null ||\n            _field$description === void 0\n              ? void 0\n              : _field$description.value,\n          args: buildArgumentMap(field.arguments),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field,\n        };\n      }\n    }\n\n    return fieldConfigMap;\n  }\n\n  function buildArgumentMap(args) {\n    // FIXME: https://github.com/graphql/graphql-js/issues/2203\n    const argsNodes =\n      /* c8 ignore next */\n      args !== null && args !== void 0 ? args : [];\n    const argConfigMap = Object.create(null);\n\n    for (const arg of argsNodes) {\n      var _arg$description;\n\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      const type = getWrappedType(arg.type);\n      argConfigMap[arg.name.value] = {\n        type,\n        description:\n          (_arg$description = arg.description) === null ||\n          _arg$description === void 0\n            ? void 0\n            : _arg$description.value,\n        defaultValue: (0, _valueFromAST.valueFromAST)(arg.defaultValue, type),\n        deprecationReason: getDeprecationReason(arg),\n        astNode: arg,\n      };\n    }\n\n    return argConfigMap;\n  }\n\n  function buildInputFieldMap(nodes) {\n    const inputFieldMap = Object.create(null);\n\n    for (const node of nodes) {\n      var _node$fields2;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const fieldsNodes =\n        /* c8 ignore next */\n        (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0\n          ? _node$fields2\n          : [];\n\n      for (const field of fieldsNodes) {\n        var _field$description2;\n\n        // Note: While this could make assertions to get the correctly typed\n        // value, that would throw immediately while type system validation\n        // with validateSchema() will produce more actionable results.\n        const type = getWrappedType(field.type);\n        inputFieldMap[field.name.value] = {\n          type,\n          description:\n            (_field$description2 = field.description) === null ||\n            _field$description2 === void 0\n              ? void 0\n              : _field$description2.value,\n          defaultValue: (0, _valueFromAST.valueFromAST)(\n            field.defaultValue,\n            type,\n          ),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field,\n        };\n      }\n    }\n\n    return inputFieldMap;\n  }\n\n  function buildEnumValueMap(nodes) {\n    const enumValueMap = Object.create(null);\n\n    for (const node of nodes) {\n      var _node$values;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const valuesNodes =\n        /* c8 ignore next */\n        (_node$values = node.values) !== null && _node$values !== void 0\n          ? _node$values\n          : [];\n\n      for (const value of valuesNodes) {\n        var _value$description;\n\n        enumValueMap[value.name.value] = {\n          description:\n            (_value$description = value.description) === null ||\n            _value$description === void 0\n              ? void 0\n              : _value$description.value,\n          deprecationReason: getDeprecationReason(value),\n          astNode: value,\n        };\n      }\n    }\n\n    return enumValueMap;\n  }\n\n  function buildInterfaces(nodes) {\n    // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    // @ts-expect-error\n    return nodes.flatMap(\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      (node) => {\n        var _node$interfaces$map, _node$interfaces;\n\n        return (\n          /* c8 ignore next */\n          (_node$interfaces$map =\n            (_node$interfaces = node.interfaces) === null ||\n            _node$interfaces === void 0\n              ? void 0\n              : _node$interfaces.map(getNamedType)) !== null &&\n            _node$interfaces$map !== void 0\n            ? _node$interfaces$map\n            : []\n        );\n      },\n    );\n  }\n\n  function buildUnionTypes(nodes) {\n    // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    // @ts-expect-error\n    return nodes.flatMap(\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      (node) => {\n        var _node$types$map, _node$types;\n\n        return (\n          /* c8 ignore next */\n          (_node$types$map =\n            (_node$types = node.types) === null || _node$types === void 0\n              ? void 0\n              : _node$types.map(getNamedType)) !== null &&\n            _node$types$map !== void 0\n            ? _node$types$map\n            : []\n        );\n      },\n    );\n  }\n\n  function buildType(astNode) {\n    var _typeExtensionsMap$na;\n\n    const name = astNode.name.value;\n    const extensionASTNodes =\n      (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null &&\n      _typeExtensionsMap$na !== void 0\n        ? _typeExtensionsMap$na\n        : [];\n\n    switch (astNode.kind) {\n      case _kinds.Kind.OBJECT_TYPE_DEFINITION: {\n        var _astNode$description;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new _definition.GraphQLObjectType({\n          name,\n          description:\n            (_astNode$description = astNode.description) === null ||\n            _astNode$description === void 0\n              ? void 0\n              : _astNode$description.value,\n          interfaces: () => buildInterfaces(allNodes),\n          fields: () => buildFieldMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case _kinds.Kind.INTERFACE_TYPE_DEFINITION: {\n        var _astNode$description2;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new _definition.GraphQLInterfaceType({\n          name,\n          description:\n            (_astNode$description2 = astNode.description) === null ||\n            _astNode$description2 === void 0\n              ? void 0\n              : _astNode$description2.value,\n          interfaces: () => buildInterfaces(allNodes),\n          fields: () => buildFieldMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case _kinds.Kind.ENUM_TYPE_DEFINITION: {\n        var _astNode$description3;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new _definition.GraphQLEnumType({\n          name,\n          description:\n            (_astNode$description3 = astNode.description) === null ||\n            _astNode$description3 === void 0\n              ? void 0\n              : _astNode$description3.value,\n          values: buildEnumValueMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case _kinds.Kind.UNION_TYPE_DEFINITION: {\n        var _astNode$description4;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new _definition.GraphQLUnionType({\n          name,\n          description:\n            (_astNode$description4 = astNode.description) === null ||\n            _astNode$description4 === void 0\n              ? void 0\n              : _astNode$description4.value,\n          types: () => buildUnionTypes(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case _kinds.Kind.SCALAR_TYPE_DEFINITION: {\n        var _astNode$description5;\n\n        return new _definition.GraphQLScalarType({\n          name,\n          description:\n            (_astNode$description5 = astNode.description) === null ||\n            _astNode$description5 === void 0\n              ? void 0\n              : _astNode$description5.value,\n          specifiedByURL: getSpecifiedByURL(astNode),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n\n      case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION: {\n        var _astNode$description6;\n\n        const allNodes = [astNode, ...extensionASTNodes];\n        return new _definition.GraphQLInputObjectType({\n          name,\n          description:\n            (_astNode$description6 = astNode.description) === null ||\n            _astNode$description6 === void 0\n              ? void 0\n              : _astNode$description6.value,\n          fields: () => buildInputFieldMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n    }\n  }\n}\n\nconst stdTypeMap = (0, _keyMap.keyMap)(\n  [..._scalars.specifiedScalarTypes, ..._introspection.introspectionTypes],\n  (type) => type.name,\n);\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\nfunction getDeprecationReason(node) {\n  const deprecated = (0, _values.getDirectiveValues)(\n    _directives.GraphQLDeprecatedDirective,\n    node,\n  ); // @ts-expect-error validated by `getDirectiveValues`\n\n  return deprecated === null || deprecated === void 0\n    ? void 0\n    : deprecated.reason;\n}\n/**\n * Given a scalar node, returns the string value for the specifiedByURL.\n */\n\nfunction getSpecifiedByURL(node) {\n  const specifiedBy = (0, _values.getDirectiveValues)(\n    _directives.GraphQLSpecifiedByDirective,\n    node,\n  ); // @ts-expect-error validated by `getDirectiveValues`\n\n  return specifiedBy === null || specifiedBy === void 0\n    ? void 0\n    : specifiedBy.url;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}