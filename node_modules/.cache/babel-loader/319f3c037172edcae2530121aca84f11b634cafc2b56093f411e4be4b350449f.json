{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.valueFromAST = valueFromAST;\nvar _inspect = require('../jsutils/inspect.js');\nvar _invariant = require('../jsutils/invariant.js');\nvar _keyMap = require('../jsutils/keyMap.js');\nvar _kinds = require('../language/kinds.js');\nvar _definition = require('../type/definition.js');\n\n/**\n * Produces a JavaScript value given a GraphQL Value AST.\n *\n * A GraphQL type must be provided, which will be used to interpret different\n * GraphQL Value literals.\n *\n * Returns `undefined` when the value could not be validly coerced according to\n * the provided type.\n *\n * | GraphQL Value        | JSON Value    |\n * | -------------------- | ------------- |\n * | Input Object         | Object        |\n * | List                 | Array         |\n * | Boolean              | Boolean       |\n * | String               | String        |\n * | Int / Float          | Number        |\n * | Enum Value           | Unknown       |\n * | NullValue            | null          |\n *\n */\nfunction valueFromAST(valueNode, type, variables) {\n  if (!valueNode) {\n    // When there is no node, then there is also no value.\n    // Importantly, this is different from returning the value null.\n    return;\n  }\n  if (valueNode.kind === _kinds.Kind.VARIABLE) {\n    const variableName = valueNode.name.value;\n    if (variables == null || variables[variableName] === undefined) {\n      // No valid return value.\n      return;\n    }\n    const variableValue = variables[variableName];\n    if (variableValue === null && (0, _definition.isNonNullType)(type)) {\n      return; // Invalid: intentionally return no value.\n    } // Note: This does no further checking that this variable is correct.\n    // This assumes that this query has been validated and the variable\n    // usage here is of the correct type.\n\n    return variableValue;\n  }\n  if ((0, _definition.isNonNullType)(type)) {\n    if (valueNode.kind === _kinds.Kind.NULL) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return valueFromAST(valueNode, type.ofType, variables);\n  }\n  if (valueNode.kind === _kinds.Kind.NULL) {\n    // This is explicitly returning the value null.\n    return null;\n  }\n  if ((0, _definition.isListType)(type)) {\n    const itemType = type.ofType;\n    if (valueNode.kind === _kinds.Kind.LIST) {\n      const coercedValues = [];\n      for (const itemNode of valueNode.values) {\n        if (isMissingVariable(itemNode, variables)) {\n          // If an array contains a missing variable, it is either coerced to\n          // null or if the item type is non-null, it considered invalid.\n          if ((0, _definition.isNonNullType)(itemType)) {\n            return; // Invalid: intentionally return no value.\n          }\n\n          coercedValues.push(null);\n        } else {\n          const itemValue = valueFromAST(itemNode, itemType, variables);\n          if (itemValue === undefined) {\n            return; // Invalid: intentionally return no value.\n          }\n\n          coercedValues.push(itemValue);\n        }\n      }\n      return coercedValues;\n    }\n    const coercedValue = valueFromAST(valueNode, itemType, variables);\n    if (coercedValue === undefined) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return [coercedValue];\n  }\n  if ((0, _definition.isInputObjectType)(type)) {\n    if (valueNode.kind !== _kinds.Kind.OBJECT) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    const coercedObj = Object.create(null);\n    const fieldNodes = (0, _keyMap.keyMap)(valueNode.fields, field => field.name.value);\n    for (const field of Object.values(type.getFields())) {\n      const fieldNode = fieldNodes[field.name];\n      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {\n        if (field.defaultValue !== undefined) {\n          coercedObj[field.name] = field.defaultValue;\n        } else if ((0, _definition.isNonNullType)(field.type)) {\n          return; // Invalid: intentionally return no value.\n        }\n\n        continue;\n      }\n      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);\n      if (fieldValue === undefined) {\n        return; // Invalid: intentionally return no value.\n      }\n\n      coercedObj[field.name] = fieldValue;\n    }\n    return coercedObj;\n  }\n  if ((0, _definition.isLeafType)(type)) {\n    // Scalars and Enums fulfill parsing a literal value via parseLiteral().\n    // Invalid values represent a failure to parse correctly, in which case\n    // no value is returned.\n    let result;\n    try {\n      result = type.parseLiteral(valueNode, variables);\n    } catch (_error) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    if (result === undefined) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return result;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible input types have been considered.\n\n  false || (0, _invariant.invariant)(false, 'Unexpected input type: ' + (0, _inspect.inspect)(type));\n} // Returns true if the provided valueNode is a variable which is not defined\n// in the set of variables.\n\nfunction isMissingVariable(valueNode, variables) {\n  return valueNode.kind === _kinds.Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === undefined);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","valueFromAST","_inspect","require","_invariant","_keyMap","_kinds","_definition","valueNode","type","variables","kind","Kind","VARIABLE","variableName","name","undefined","variableValue","isNonNullType","NULL","ofType","isListType","itemType","LIST","coercedValues","itemNode","values","isMissingVariable","push","itemValue","coercedValue","isInputObjectType","OBJECT","coercedObj","create","fieldNodes","keyMap","fields","field","getFields","fieldNode","defaultValue","fieldValue","isLeafType","result","parseLiteral","_error","invariant","inspect"],"sources":["/Users/lawrence/Documents/Codecademy/Redux News Reader (project)/node_modules/graphql/utilities/valueFromAST.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.valueFromAST = valueFromAST;\n\nvar _inspect = require('../jsutils/inspect.js');\n\nvar _invariant = require('../jsutils/invariant.js');\n\nvar _keyMap = require('../jsutils/keyMap.js');\n\nvar _kinds = require('../language/kinds.js');\n\nvar _definition = require('../type/definition.js');\n\n/**\n * Produces a JavaScript value given a GraphQL Value AST.\n *\n * A GraphQL type must be provided, which will be used to interpret different\n * GraphQL Value literals.\n *\n * Returns `undefined` when the value could not be validly coerced according to\n * the provided type.\n *\n * | GraphQL Value        | JSON Value    |\n * | -------------------- | ------------- |\n * | Input Object         | Object        |\n * | List                 | Array         |\n * | Boolean              | Boolean       |\n * | String               | String        |\n * | Int / Float          | Number        |\n * | Enum Value           | Unknown       |\n * | NullValue            | null          |\n *\n */\nfunction valueFromAST(valueNode, type, variables) {\n  if (!valueNode) {\n    // When there is no node, then there is also no value.\n    // Importantly, this is different from returning the value null.\n    return;\n  }\n\n  if (valueNode.kind === _kinds.Kind.VARIABLE) {\n    const variableName = valueNode.name.value;\n\n    if (variables == null || variables[variableName] === undefined) {\n      // No valid return value.\n      return;\n    }\n\n    const variableValue = variables[variableName];\n\n    if (variableValue === null && (0, _definition.isNonNullType)(type)) {\n      return; // Invalid: intentionally return no value.\n    } // Note: This does no further checking that this variable is correct.\n    // This assumes that this query has been validated and the variable\n    // usage here is of the correct type.\n\n    return variableValue;\n  }\n\n  if ((0, _definition.isNonNullType)(type)) {\n    if (valueNode.kind === _kinds.Kind.NULL) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return valueFromAST(valueNode, type.ofType, variables);\n  }\n\n  if (valueNode.kind === _kinds.Kind.NULL) {\n    // This is explicitly returning the value null.\n    return null;\n  }\n\n  if ((0, _definition.isListType)(type)) {\n    const itemType = type.ofType;\n\n    if (valueNode.kind === _kinds.Kind.LIST) {\n      const coercedValues = [];\n\n      for (const itemNode of valueNode.values) {\n        if (isMissingVariable(itemNode, variables)) {\n          // If an array contains a missing variable, it is either coerced to\n          // null or if the item type is non-null, it considered invalid.\n          if ((0, _definition.isNonNullType)(itemType)) {\n            return; // Invalid: intentionally return no value.\n          }\n\n          coercedValues.push(null);\n        } else {\n          const itemValue = valueFromAST(itemNode, itemType, variables);\n\n          if (itemValue === undefined) {\n            return; // Invalid: intentionally return no value.\n          }\n\n          coercedValues.push(itemValue);\n        }\n      }\n\n      return coercedValues;\n    }\n\n    const coercedValue = valueFromAST(valueNode, itemType, variables);\n\n    if (coercedValue === undefined) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return [coercedValue];\n  }\n\n  if ((0, _definition.isInputObjectType)(type)) {\n    if (valueNode.kind !== _kinds.Kind.OBJECT) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    const coercedObj = Object.create(null);\n    const fieldNodes = (0, _keyMap.keyMap)(\n      valueNode.fields,\n      (field) => field.name.value,\n    );\n\n    for (const field of Object.values(type.getFields())) {\n      const fieldNode = fieldNodes[field.name];\n\n      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {\n        if (field.defaultValue !== undefined) {\n          coercedObj[field.name] = field.defaultValue;\n        } else if ((0, _definition.isNonNullType)(field.type)) {\n          return; // Invalid: intentionally return no value.\n        }\n\n        continue;\n      }\n\n      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);\n\n      if (fieldValue === undefined) {\n        return; // Invalid: intentionally return no value.\n      }\n\n      coercedObj[field.name] = fieldValue;\n    }\n\n    return coercedObj;\n  }\n\n  if ((0, _definition.isLeafType)(type)) {\n    // Scalars and Enums fulfill parsing a literal value via parseLiteral().\n    // Invalid values represent a failure to parse correctly, in which case\n    // no value is returned.\n    let result;\n\n    try {\n      result = type.parseLiteral(valueNode, variables);\n    } catch (_error) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    if (result === undefined) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return result;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible input types have been considered.\n\n  false ||\n    (0, _invariant.invariant)(\n      false,\n      'Unexpected input type: ' + (0, _inspect.inspect)(type),\n    );\n} // Returns true if the provided valueNode is a variable which is not defined\n// in the set of variables.\n\nfunction isMissingVariable(valueNode, variables) {\n  return (\n    valueNode.kind === _kinds.Kind.VARIABLE &&\n    (variables == null || variables[valueNode.name.value] === undefined)\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}